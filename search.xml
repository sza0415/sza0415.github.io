<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ARFoundation学习</title>
    <url>/ARFoundationLearning/</url>
    <content><![CDATA[<h1 id="About-ARFoundation"><a href="#About-ARFoundation" class="headerlink" title="About ARFoundation"></a>About ARFoundation</h1><h2 id="ARSession"><a href="#ARSession" class="headerlink" title="ARSession"></a>ARSession</h2><p>An AR scene should include an <code>ARSession</code> component. The AR Session controls the lifecycle of an AR experience, enabling or disabling AR on the target platform. The <code>ARSession</code> can be on any <code>GameObject</code></p>
<p>An AR scene should include an <code>ARSession</code> component. The AR Session controls the lifecycle of an AR experience, enabling or disabling AR on the target platform. The <code>ARSession</code> can be on any <code>GameObject</code></p>
<h2 id="ARSessionOrigin"><a href="#ARSessionOrigin" class="headerlink" title="ARSessionOrigin"></a>ARSessionOrigin</h2><p>The purpose of the <code>ARSessionOrigin</code> is to transform trackable features (such as planar surfaces and feature points) into their final position, orientation, and scale in the Unity scene. Because AR devices provide their data in “session space”, an unscaled space relative to the beginning of the AR session, the <code>ARSessionOrigin</code> performs the appropriate transformation into Unity space.</p>
<h2 id="Tracked-Pose-Driver"><a href="#Tracked-Pose-Driver" class="headerlink" title="Tracked Pose Driver"></a>Tracked Pose Driver</h2><p>Parented to the <code>ARSessionOrigin</code>‘s’ <code>GameObject</code> should be (at least) one camera, which will be used to render any trackables you wish to visualize. The camera should also have a <code>TrackedPoseDriver</code> component on it, which will drive the camera’s local position and rotation according to the device’s tracking information. This setup allows the camera’s local space to match the AR “session space”.</p>
<h1 id="ARFoundation－图像跟踪"><a href="#ARFoundation－图像跟踪" class="headerlink" title="ARFoundation－图像跟踪"></a>ARFoundation－图像跟踪</h1><p><a href="https://blog.csdn.net/yolon3000/article/details/96502120">https://blog.csdn.net/yolon3000/article/details/96502120</a></p>
<p>图像跟踪技术，是指通过图像处理技术对摄像头中拍摄到的2D图像进行定位，并对其姿态进行跟踪的技术。</p>
<p>在ARFoundation中，图像跟踪的操作使用分成两步，第一步是建立一个参考图像库Create-&gt;XR-&gt;Reference Image Library，第二步是在场景中挂载AR Tracked Image Manager组件，并将一个需要实例化的Prefab赋给其Tracked Image Prefab即可</p>
<img src="image-20241114144129407.png" class title="image-20241114144129407.png">

<p>Max Number of Moving Images属性指定了最大的可跟踪的动态图像数，因为动态图像跟踪是一个非常消耗CPU性能的任务，过多的动态图像跟踪会导致应用卡顿。</p>
<h2 id="图像跟踪启用与禁用"><a href="#图像跟踪启用与禁用" class="headerlink" title="图像跟踪启用与禁用"></a>图像跟踪启用与禁用</h2><p>在ARFoundation中，实例化出来的虚拟对象并不会随着被跟踪物体的消失而消失，而是会继续停留在原来的位置上，这有时就会变得很不合适。而且，图像跟踪是一个非常消耗性能的操作，在不使用图像跟踪时一定要把图像跟踪功能关闭。参考平面检测功能的关闭与启用，类似的我们可以编写如下代码来控制图像跟踪的启用与禁用以及所跟踪对象的显示与隐藏。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Text m_TogglePlaneDetectionText;</span><br><span class="line"><span class="keyword">private</span> ARTrackedImageManager mARTrackedImageManager;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    mARTrackedImageManager = GetComponent&lt;ARTrackedImageManager&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">region</span> 启用与禁用图像跟踪</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ToggleImageTracking</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    mARTrackedImageManager.enabled = !mARTrackedImageManager.enabled;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> planeDetectionMessage = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (mARTrackedImageManager.enabled)</span><br><span class="line">    &#123;</span><br><span class="line">        planeDetectionMessage = <span class="string">&quot;禁用图像跟踪&quot;</span>;</span><br><span class="line">        SetAllImagesActive(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        planeDetectionMessage = <span class="string">&quot;启用图像跟踪&quot;</span>;</span><br><span class="line">        SetAllImagesActive(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (m_TogglePlaneDetectionText != <span class="literal">null</span>)</span><br><span class="line">        m_TogglePlaneDetectionText.text = planeDetectionMessage;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetAllImagesActive</span>(<span class="params"><span class="built_in">bool</span> <span class="keyword">value</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> img <span class="keyword">in</span> mARTrackedImageManager.trackables)</span><br><span class="line">        img.gameObject.SetActive(<span class="keyword">value</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endregion</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong><code>enabled</code>属性（主要用于组件）</strong></p>
<ul>
<li><strong>功能</strong>：<code>enabled</code>是许多 Unity 组件（如<code>MonoBehaviour</code>、<code>ARTrackedImageManager</code>等）都具有的一个属性。它用于控制组件是否处于启用状态。</li>
</ul>
<p><strong><code>SetActive</code>方法（用于游戏对象）</strong></p>
<ul>
<li><strong>功能</strong>：<code>SetActive</code>是<code>GameObject</code>类的一个方法，用于控制游戏对象是否在场景中处于活动（可见和可交互）状态。当<code>SetActive(true)</code>时，游戏对象及其所有子对象（如果有）会变为可见状态，并且可以与场景中的其他对象进行交互，如接收碰撞检测、触发事件等；当<code>SetActive(false)</code>时，游戏对象及其所有子对象会被隐藏，并且不会参与场景中的大多数交互活动，如不会触发碰撞事件，也不会被渲染出来（不可见）。</li>
</ul>
<h2 id="多图像跟踪"><a href="#多图像跟踪" class="headerlink" title="多图像跟踪"></a>多图像跟踪</h2><p>在AR Tracked Image Manager组件中，有一个Tracked Image Prefab属性，这个属性即为需要实例化的虚拟对象。默认，ARFoundation是支持多图像跟踪的，如下图所示。</p>
<p>但在AR应用运行时，只能有一个AR Tracked Image Manager组件运行（多个AR Tracked Image Manager组件会导致跟踪冲突），即只能设置一个Tracked Image Prefab，即不能实例化多个虚拟对象，这将极大的限制跟踪图像的实际应用，所以为了实例化多个虚拟对象，我们只能动态的修改Tracked Image Prefab属性。</p>
<p>经过测试，我们发现在ARFoundation中，AR Tracked Image Manager组件在trackedImagesChanged事件触发之前就已经实例化了虚拟对象。</p>
<blockquote>
<p>直接看官网给的解释，也会方便我们后续的理解：</p>
<h2 id="Tracked-Image-Prefab"><a href="#Tracked-Image-Prefab" class="headerlink" title="Tracked Image Prefab"></a>Tracked Image Prefab</h2><p>The <a href="https://docs.unity3d.com/Packages/com.unity.xr.arfoundation@4.1/api/UnityEngine.XR.ARFoundation.ARTrackedImageManager.html">ARTrackedImageManager</a> has a <a href="https://docs.unity3d.com/Packages/com.unity.xr.arfoundation@4.1/api/UnityEngine.XR.ARFoundation.ARTrackedImageManager.html#UnityEngine_XR_ARFoundation_ARTrackedImageManager_trackedImagePrefab">“Tracked Image Prefab”</a> field; however, this is not intended for content. When an image is detected, ARFoundation will create a new <a href="https://docs.unity3d.com/2019.4/Documentation/Manual/GameObjects.html">GameObject</a> to represent it.</p>
<p>ARTrackedImageManager（增强现实跟踪图像管理器）有一个 “跟踪图像预制体（Tracked Image Prefab）” 字段；然而，这个字段不是用于（直接关联）内容的（<font color="DodgerBlue">这也就解释了预制体中的预字</font>）。当一个图像被检测到时，ARFoundation（增强现实基础框架）将会创建一个新的游戏对象（GameObject）来表示它。</p>
<p>If “Tracked Image Prefab” is <code>null</code>, then ARFoundation simply creates a GameObject with an <a href="https://docs.unity3d.com/Packages/com.unity.xr.arfoundation@4.1/api/UnityEngine.XR.ARFoundation.ARTrackedImage.html">ARTrackedImage</a> component on it. However, if you want <em>every tracked image</em> to also include additional components, you can provide a prefab for ARFoundation to instantiate for each detected image. In other words, the purpose of the prefab field is to <em>extend</em> the default behavior of tracked images; it is not the recommended way to <em>place content</em> in the world.</p>
<p>如果“跟踪图像预制件”为空，则 ARFoundation 只会创建一个带有 ARTrackedImage 组件的 GameObject。但是，如果您希望每个跟踪图像也包含其他组件，则可以为每个检测到的图像提供一个预制件，供 ARFoundation 实例化。换句话说，预制件字段的目的是扩展跟踪图像的默认行为；这不是在世界中放置内容的推荐方式。</p>
<p><code>Tracked Image Prefab</code>为空，<code>ARTrackedImageManager</code>依然会创建一个GameObject，该GameObject会添加所检测到ARTrackedImage（Reference Image Library中设置的待检测的图像集）的组件；而<code>Tracked Image Prefab</code>不为空，那么GameObject下则会多一个预制件，ARTrackedImageManager则会根据该预制件对检测到的图像位置进行实例化。</p>
</blockquote>
<p>因此我们的解决思路是：在AR Tracked Image Manager组件Tracked Image Prefab中设置第一个需要实例化的Prefab（<font color="dodgerblue">若Tracked Image Prefab为空，那么当检测到第一个待检测图像added时候，ARTrackedImageManager不会为其实例化</font>），然后在trackedImagesChanged事件里捕捉到图像added操作，更改Tracked Image Prefab为下一个需要实例化的Prefab，这样来达到动态调整虚拟对象的目的。如正常设置Tracked Image Prefab为Spider Prefab，在检测到Spider图像后，我们将Tracked Image Prefab修改为Cat Prefab，这样，再检测到Cat图像后就会实例化Cat Prefab了。</p>
<img src="image-20241114170149978.png" class title="image-20241114170149978">

<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.XR.ARFoundation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MultiImageTracking</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    ARTrackedImageManager ImgTrackedManager;</span><br><span class="line">    <span class="keyword">public</span> GameObject[] ObjectPrefabs;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        ImgTrackedManager = GetComponent&lt;ARTrackedImageManager&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnEnable</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        ImgTrackedManager.trackedImagesChanged += OnTrackedImagesChanged;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnDisable</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        ImgTrackedManager.trackedImagesChanged -= OnTrackedImagesChanged;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnTrackedImagesChanged</span>(<span class="params">ARTrackedImagesChangedEventArgs eventArgs</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (eventArgs.added.Count != <span class="number">0</span>)Debug.Log(eventArgs.added.Count); </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> trackedImage <span class="keyword">in</span> eventArgs.added)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Debug.Log(trackedImage.referenceImage.name);</span></span><br><span class="line">            OnImagesChanged(trackedImage.referenceImage.name);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//    foreach (var trackedImage in eventArgs.updated)</span></span><br><span class="line">    <span class="comment">//    &#123;</span></span><br><span class="line">    <span class="comment">//        OnImagesChanged(trackedImage.referenceImage.name);</span></span><br><span class="line">    <span class="comment">//    &#125;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnImagesChanged</span>(<span class="params"><span class="built_in">string</span> referenceImageName</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (referenceImageName == <span class="string">&quot;prefab1&quot;</span>)</span><br><span class="line">        &#123;           </span><br><span class="line">            ImgTrackedManager.trackedImagePrefab = ObjectPrefabs[<span class="number">1</span>];</span><br><span class="line">            Debug.Log(<span class="string">&quot;Tracked Name is ..&quot;</span> + referenceImageName);</span><br><span class="line">            Debug.Log(<span class="string">&quot;Prefab Name is ..&quot;</span> + ImgTrackedManager.trackedImagePrefab.name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (referenceImageName == <span class="string">&quot;prefab2&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(<span class="string">&quot;Tracked Name is ..&quot;</span> + referenceImageName);</span><br><span class="line">            Debug.Log(<span class="string">&quot;Prefab Name is ..&quot;</span> + ImgTrackedManager.trackedImagePrefab.name);</span><br><span class="line">            ImgTrackedManager.trackedImagePrefab = ObjectPrefabs[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>读者可能已经看到，这种方式其实有个很大的弊端，即必须要按顺序检测图像，因为我们无法在用户检测图像之前预测用户可能会检测的2D图像。为解决这个问题，就不能让AR Tracked Image Manager组件实例化对象，而由我们自己负责虚拟对象的实例化。将AR Tracked Image Manager组件下的Tracked Image Prefab属性清空，为MultiImageTracking脚本的ObjectPrefabs数组赋上相应的值，并编写如下代码。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.XR.ARFoundation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MultiImageTracking</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    ARTrackedImageManager ImgTrackedmanager;</span><br><span class="line">    <span class="keyword">public</span> GameObject[] ObjectPrefabs;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        ImgTrackedmanager = GetComponent&lt;ARTrackedImageManager&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnEnable</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        ImgTrackedmanager.trackedImagesChanged += OnTrackedImagesChanged;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnDisable</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        ImgTrackedmanager.trackedImagesChanged -= OnTrackedImagesChanged;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnTrackedImagesChanged</span>(<span class="params">ARTrackedImagesChangedEventArgs eventArgs</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> trackedImage <span class="keyword">in</span> eventArgs.added)</span><br><span class="line">        &#123;</span><br><span class="line">            OnImagesChanged(trackedImage);</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">// foreach (var trackedImage in eventArgs.updated)</span></span><br><span class="line">       <span class="comment">// &#123;</span></span><br><span class="line">       <span class="comment">//     OnImagesChanged(trackedImage.referenceImage.name);</span></span><br><span class="line">       <span class="comment">// &#125;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnImagesChanged</span>(<span class="params">ARTrackedImage referenceImage</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (referenceImage.referenceImage.name == <span class="string">&quot;Spider&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Instantiate(ObjectPrefabs[<span class="number">0</span>], referenceImage.transform);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (referenceImage.referenceImage.name == <span class="string">&quot;Cat&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Instantiate(ObjectPrefabs[<span class="number">1</span>], referenceImage.transform);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h1 id="AR-tracked-image-manager"><a href="#AR-tracked-image-manager" class="headerlink" title="AR tracked image manager"></a>AR tracked image manager</h1><p>The tracked image manager is a type of <a href="https://docs.unity3d.com/Packages/com.unity.xr.arfoundation@4.1/manual/trackable-managers.html">trackable manager</a> and performs <code>2D image tracking</code>.</p>
<p>The tracked image manager <code>creates</code> <a href="https://docs.unity3d.com/2019.4/Documentation/Manual/GameObjects.html">GameObjects</a> for <code>each detected image</code> in the environment. </p>
<p><code>Before </code> an image can be detected, the manager must be instructed to look for a set of reference images compiled into a reference image library. It <u><code>only</code> detects images in this library</u>.</p>
<h3 id="Responding-to-detected-images"><a href="#Responding-to-detected-images" class="headerlink" title="Responding to detected images"></a>Responding to detected images</h3><p><code>Subscribe </code> to the ARTrackedImageManager’s <a href="https://docs.unity3d.com/Packages/com.unity.xr.arfoundation@4.1/api/UnityEngine.XR.ARFoundation.ARTrackedImageManager.html#UnityEngine_XR_ARFoundation_ARTrackedImageManager_trackedImagesChanged">trackedImagesChanged</a> <code>event</code> to be notified whenever an image is <code>added</code> (i.e., first detected), ≈<code>removed</code>, or <code>updated</code>:</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">SerializeField</span>]</span><br><span class="line">ARTrackedImageManager m_TrackedImageManager;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnEnable</span>()</span> =&gt; m_TrackedImageManager.trackedImagesChanged += OnChanged;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnDisable</span>()</span> =&gt; m_TrackedImageManager.trackedImagesChanged -= OnChanged;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnChanged</span>(<span class="params">ARTrackedImagesChangedEventArgs eventArgs</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> newImage <span class="keyword">in</span> eventArgs.added)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Handle added event</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> updatedImage <span class="keyword">in</span> eventArgs.updated)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Handle updated event</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> removedImage <span class="keyword">in</span> eventArgs.removed)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Handle removed event</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>You can also get all the currently tracked images with the ARTrackedImageManager’s <a href="https://docs.unity3d.com/Packages/com.unity.xr.arfoundation@4.1/api/UnityEngine.XR.ARFoundation.ARTrackableManager-4.html#UnityEngine_XR_ARFoundation_ARTrackableManager_4_trackables">trackables</a> property. This acts like an <a href="https://learn.microsoft.com/dotnet/api/system.collections.ienumerable">IEnumerable</a> collection, so you can use it in a <code>foreach</code> statement:</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ListAllImages</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    Debug.Log(</span><br><span class="line">        <span class="string">$&quot;There are <span class="subst">&#123;m_TrackedImageManager.trackables.count&#125;</span> images being tracked.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> trackedImage <span class="keyword">in</span> m_TrackedImageManager.trackables)</span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">$&quot;Image: <span class="subst">&#123;trackedImage.referenceImage.name&#125;</span> is at &quot;</span> +</span><br><span class="line">                  <span class="string">$&quot;<span class="subst">&#123;trackedImage.transform.position&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Or access a specific image by its <a href="https://docs.unity3d.com/Packages/com.unity.xr.arsubsystems@4.1/api/UnityEngine.XR.ARSubsystems.TrackableId.html">TrackableId</a>:</p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="function">ARTrackedImage <span class="title">GetImageAt</span>(<span class="params">TrackableId trackableId</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> m_TrackedImageManager.trackables[trackableId];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Class-ARTrackedImageManager"><a href="#Class-ARTrackedImageManager" class="headerlink" title="Class ARTrackedImageManager"></a>Class ARTrackedImageManager</h2><ul>
<li><p>Properties</p>
<ul>
<li><p>trackedImagePrefab</p>
<p>If not null, instantiates this prefab for each detected image.</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> GameObject trackedImagePrefab &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br></pre></td></tr></table></figure>

<p>The purpose of this property is to <em>extend</em> the functionality of <a href="https://docs.unity3d.com/Packages/com.unity.xr.arfoundation@4.1/api/UnityEngine.XR.ARFoundation.ARTrackedImage.html">ARTrackedImage</a>s. It is not the recommended way to instantiate <em>content</em> associated with an <a href="https://docs.unity3d.com/Packages/com.unity.xr.arfoundation@4.1/api/UnityEngine.XR.ARFoundation.ARTrackedImage.html">ARTrackedImage</a>. （该属性只是为了扩展ARTrackedImage的功能，当不是为空时，会自动为其实例化，但是这个并不是为ARTrackedImage实例化的推荐方式）</p>
</li>
<li><p>referenceLibrary</p>
<p>Get or set the reference image library, the set of images to search for in the physical environment.</p>
<p>Declaration</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> IReferenceImageLibrary referenceLibrary &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>其他属性可以在<a href="https://docs.unity3d.com/Packages/com.unity.xr.arfoundation@4.1/api/UnityEngine.XR.ARFoundation.ARTrackedImageManager.html#UnityEngine_XR_ARFoundation_ARTrackedImageManager_trackedImagesChanged">Class ARTrackedImageManager</a>查看</p>
</li>
</ul>
</li>
<li><p>Methods </p>
<p>重点讲解OnTrackablesChanged</p>
<ul>
<li><p>OnTrackablesChanged(List<ARTrackedImage>, List<ARTrackedImage>, List<ARTrackedImage>)</ARTrackedImage></ARTrackedImage></ARTrackedImage></p>
<p>Invokes the <a href="https://docs.unity3d.com/Packages/com.unity.xr.arfoundation@4.1/api/UnityEngine.XR.ARFoundation.ARTrackedImageManager.html#UnityEngine_XR_ARFoundation_ARTrackedImageManager_trackedImagesChanged">trackedImagesChanged</a> event.</p>
<p> Declaration</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnTrackablesChanged</span>(<span class="params">List&lt;ARTrackedImage&gt; added, List&lt;ARTrackedImage&gt; updated, List&lt;ARTrackedImage&gt; removed</span>)</span></span><br></pre></td></tr></table></figure>

<p> Parameters</p>
<table>
<thead>
<tr>
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="left">List<ARTrackedImage></ARTrackedImage></td>
<td align="left"><em>added</em></td>
<td align="left">A list of images added this frame.</td>
</tr>
<tr>
<td align="left">List<ARTrackedImage></ARTrackedImage></td>
<td align="left"><em>updated</em></td>
<td align="left">A list of images updated this frame.</td>
</tr>
<tr>
<td align="left">List<ARTrackedImage></ARTrackedImage></td>
<td align="left"><em>removed</em></td>
<td align="left">A list of images removed this frame.</td>
</tr>
</tbody></table>
<img src="0798c75c9e2f80e0554f7c7cbc93bb95.png" class title="img">



<p><code>added</code> 参数是一个列表，其中包含了自上一帧以来新添加的可跟踪对象 。这些对象是在当前帧中被 AR 系统检测到并添加到跟踪列表中的。</p>
<p><code>updated</code> 列表包含了自上一帧以来发生了更新的可跟踪对象。这些对象已经被 AR 系统跟踪，并且在当前帧中其某些属性或状态发生了变化，例如位置、旋转、缩放等。</p>
<p><code>removed</code> 列表则包含了自上一帧以来被移除的可跟踪对象，即这些对象在上一帧还在被跟踪，但在当前帧中由于某种原因不再被 AR 系统跟踪，例如超出了跟踪范围、被遮挡时间过长等。</p>
<img src="image-20241115142916837.png" class title="image-20241115142916837">

<p>Tracking State</p>
<p>There are three possible tracking states for <code>ARTrackedImages</code>:</p>
<table>
<thead>
<tr>
<th align="center">TrackingState</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><a href="https://docs.unity3d.com/Packages/com.unity.xr.arsubsystems@4.0/api/UnityEngine.XR.ARSubsystems.TrackingState.html#UnityEngine_XR_ARSubsystems_TrackingState_None">None</a></td>
<td align="left">The image is not being tracked. Note that this may be the initial state when the image is first detected.</td>
</tr>
<tr>
<td align="center"><a href="https://docs.unity3d.com/Packages/com.unity.xr.arsubsystems@4.0/api/UnityEngine.XR.ARSubsystems.TrackingState.html#UnityEngine_XR_ARSubsystems_TrackingState_Limited">Limited</a></td>
<td align="left">The image is being tracked, but not as well. The situations in which an image is considered <code>Limited</code> instead of <code>Tracking</code> depend on the underlying AR framework. Examples that may cause <code>Limited</code> tracking include: Obscuring the image so that it is not visible to the camera.The image is not tracked as a moving image. This can happen, for example, if the <code>maxNumberOfMovingImages</code> is exceeded.</td>
</tr>
<tr>
<td align="center"><a href="https://docs.unity3d.com/Packages/com.unity.xr.arsubsystems@4.0/api/UnityEngine.XR.ARSubsystems.TrackingState.html#UnityEngine_XR_ARSubsystems_TrackingState_Tracking">Tracking</a></td>
<td align="left">The underlying AR SDK reports that it is actively tracking the image.</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p>Events</p>
<ul>
<li><p>trackedImagesChanged</p>
<p>Invoked once per frame with information about the <a href="https://docs.unity3d.com/Packages/com.unity.xr.arfoundation@4.1/api/UnityEngine.XR.ARFoundation.ARTrackedImage.html">ARTrackedImage</a>s that have changed, i.e., been added, updated, or removed. This happens just before <a href="https://docs.unity3d.com/Packages/com.unity.xr.arfoundation@4.1/api/UnityEngine.XR.ARFoundation.ARTrackedImage.html">ARTrackedImage</a>s are destroyed, so you can set <code>ARTrackedImage.destroyOnRemoval</code> to <code>false</code> from this event to suppress this behavior.</p>
<h5 id="Declaration"><a href="#Declaration" class="headerlink" title="Declaration"></a>Declaration</h5><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">event</span> Action&lt;ARTrackedImagesChangedEventArgs&gt; trackedImagesChanged</span><br></pre></td></tr></table></figure>

<h5 id="Event-Type"><a href="#Event-Type" class="headerlink" title="Event Type"></a>Event Type</h5><table>
<thead>
<tr>
<th align="left">Type</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Action<ARTrackedImagesChangedEventArgs></ARTrackedImagesChangedEventArgs></td>
<td align="left"></td>
</tr>
</tbody></table>
</li>
</ul>
</li>
</ul>
<p>​	</p>
<img src="image-20241115142640377.png" class title="image-20241115142640377">

<p><a href="https://github.com/Unity-Technologies/arfoundation-samples/issues/365">https://github.com/Unity-Technologies/arfoundation-samples/issues/365</a></p>
<p>ƒ</p>
]]></content>
  </entry>
  <entry>
    <title>Maven</title>
    <url>/Maven/</url>
    <content><![CDATA[<h1 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h1><p>Maven是apache旗下的一个开源项目，是一款用于管理和构建java项目的工具，它基于项目对象模型（POM，project object model）的概念，通过一小段描述信息来guan</p>
<p>Maven的作用：</p>
<ul>
<li><p>方便快捷地管理项目依赖地资源jar包，避免版本冲突问题</p>
</li>
<li><p>提供统一、标准地项目结构</p>
<ul>
<li><p>一个使用Maven管理的普通的Java项目，它的目录结构默认如下：</p>
</li>
<li><pre><code class="xml">a-maven-project
├── pom.xml
├── src
│   ├── main
│   │   ├── java
│   │   └── resources
│   └── test
│       ├── java
│       └── resources
└── target
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 项目的根目录`a-maven-project`是项目名，它有一个项目描述文件`pom.xml`，存放Java源码的目录是`src/main/java`，存放资源文件的目录是`src/main/resources`，存放测试源码的目录是`src/test/java`，存放测试资源的目录是`src/test/resources`，最后，所有编译、打包生成的文件都放在`target`目录里。这些就是一个Maven项目的标准目录结构。</span><br><span class="line"></span><br><span class="line">  所有的目录结构都是约定好的标准结构，我们千万不要随意修改目录结构。使用标准结构不需要做任何配置，Maven就可以正常使用。</span><br><span class="line"></span><br><span class="line">- 最关键的一个项目描述文件`pom.xml`，它的内容长得像下面：</span><br><span class="line"></span><br><span class="line">- ```xml</span><br><span class="line">  &lt;project ...&gt;</span><br><span class="line">  	&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line">  	&lt;groupId&gt;com.itranswarp.learnjava&lt;/groupId&gt;</span><br><span class="line">  	&lt;artifactId&gt;hello&lt;/artifactId&gt;</span><br><span class="line">  	&lt;version&gt;1.0&lt;/version&gt;</span><br><span class="line">  	&lt;packaging&gt;jar&lt;/packaging&gt;</span><br><span class="line">  	&lt;properties&gt;</span><br><span class="line">          &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;</span><br><span class="line">  		&lt;maven.compiler.release&gt;17&lt;/maven.compiler.release&gt;</span><br><span class="line">  	&lt;/properties&gt;</span><br><span class="line">  	&lt;dependencies&gt;</span><br><span class="line">          &lt;dependency&gt;</span><br><span class="line">              &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</span><br><span class="line">              &lt;artifactId&gt;slf4j-simple&lt;/artifactId&gt;</span><br><span class="line">              &lt;version&gt;2.0.16&lt;/version&gt;</span><br><span class="line">          &lt;/dependency&gt;</span><br><span class="line">  	&lt;/dependencies&gt;</span><br><span class="line">  &lt;/project&gt;</span><br></pre></td></tr></table></figure>

其中，`groupId`类似于Java的包名，通常是公司或组织名称，`artifactId`类似于Java的类名，通常是项目名称，再加上`version`，一个Maven工程就是由`groupId`，`artifactId`和`version`作为唯一标识。

我们在引用其他第三方库的时候，也是通过这3个变量确定。例如，依赖`org.slfj4:slf4j-simple:2.0.16`：

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-simple<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.16<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

使用`&lt;dependency&gt;`声明一个依赖后，Maven就会自动下载这个依赖包并把它放到classpath中。

另外，注意到`&lt;properties&gt;`定义了一些属性，常用的属性有：

- `project.build.sourceEncoding`：表示项目源码的字符编码，通常应设定为`UTF-8`；
</code></pre>
</li>
<li><p><code>maven.compiler.release</code>：表示使用的JDK版本，例如<code>21</code>；</p>
<ul>
<li><code>maven.compiler.source</code>：表示Java编译器读取的源码版本；</li>
<li><code>maven.compiler.target</code>：表示Java编译器编译的Class版本。</li>
</ul>
<p>从Java 9开始，推荐使用<code>maven.compiler.release</code>属性，保证编译时输入的源码和编译输出版本一致。如果源码和输出版本不同，则应该分别设置<code>maven.compiler.source</code>和<code>maven.compiler.target</code>。</p>
<p>通过<code>&lt;properties&gt;</code>定义的属性，就可以固定JDK版本，防止同一个项目的不同的开发者各自使用不同版本的JDK。</p>
</li>
</ul>
</li>
<li><p>标准跨平台（Linux、Windows、MacOS）的自动化项目构建方式</p>
<ul>
<li>清理clean–&gt;编译compile–&gt;测试test–&gt;打包package–&gt;发布</li>
<li>生成的文件会在target当中</li>
</ul>
<img src="image-20241030162835233.png" class title="image-20241030162835233"></li>
</ul>
<p>​	安装步骤：</p>
<ol>
<li><p>解压apache-maven-3.9.9-bin.zip </p>
</li>
<li><p>配置本地仓库，修改conf&#x2F;setting.xml中的localRepository</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- localRepository</span></span><br><span class="line"><span class="comment"> | The path to the local repository maven will use to store artifacts.</span></span><br><span class="line"><span class="comment"> |</span></span><br><span class="line"><span class="comment"> | Default: $&#123;user.home&#125;/.m2/repository</span></span><br><span class="line"><span class="comment">&lt;localRepository&gt;/path/to/local/repo&lt;/localRepository&gt;</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">localRepository</span>&gt;</span>D:\APP\apache-maven-3.9.9-bin\apache-maven-3.9.9\mvn_repo<span class="tag">&lt;/<span class="name">localRepository</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>配置阿里云的私服，修改con&#x2F;setting.xml中的<mirrors>标签，为其添加如下子标签：</mirrors></p>
</li>
<li><p>配置环境变量：MAVEN_HOME为maven的解压目录，并将其bin目录加入PATH环境变量</p>
</li>
<li><p>命令行中测试 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mvn -v</span><br></pre></td></tr></table></figure></li>
</ol>
<p>IDEA创建Maven项目</p>
<img src="image-20241030184929162.png" class title="image-20241030184929162">

<p>Maven中的坐标是<font color="red">资源的唯一标识，通过该坐标可以唯一定位资源的位置</font></p>
<p>使用坐标来定义项目或引入项目中需要的依赖</p>
<img src="image-20241030185707674.png" class title="image-20241030185707674">

<ul>
<li>groupId：定义当前Maven项目隶属组织名称</li>
<li>artifactId：定义当前Maven项目名称（通常是模块名称）</li>
<li>version：定义当前项目版本号</li>
</ul>
<p>依赖配置：</p>
<img src="image-20241030191533568.png" class title="image-20241030191533568">

<p>没有的话，可以直接去官方Maven去搜复制maven代码即可。</p>
<img src="image-20241030191643080.png" class title="image-20241030191643080">]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaWeb基础</title>
    <url>/JavaWeb%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>JSP页面元素</p>
<ul>
<li><p>a.脚本Scriptlet</p>
<ul>
<li><pre><code class="jsp">&lt;%
        局部变量、java语句
%&gt;

&lt;%!
        全局变量、定义方法
 %&gt;

&lt;%= 输出表达式  %&gt;
这里的局部变量的作用域并不是局限于&lt;%	.....%&gt;，这是因为JSP最终都会转译为servlet，全局变量为该类的成员变量，作用域为整个类；而局部变量被写在了service方法当中，为客户端向服务端的servlet中，service()方法中的本地变量只能每响应一次请求就重建一次。
全局变量在关闭该网页、关闭浏览器、更换浏览器，再重新访问该jsp页面后仍然持续保留之前的值（服务器仍然保留着该servlet）；
但在清除tomcat的work文件夹，或重启tomcat后恢复初始值。
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta charset=&quot;UTF-8&quot;&gt;
&lt;title&gt;Insert title here&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;%
        int x = 1;
    %&gt;
    &lt;%!
        int y = 1;
    %&gt;
    hello Jsp
    &lt;br&gt;
    
    &lt;%
        x++;
        y++;
    %&gt;
    
    &lt;%=&quot;x的值：&quot; + x + &quot;y的值：&quot; + y  %&gt;
&lt;/body&gt;
&lt;/html&gt;
输出为
hello Jsp
x的值：2y的值：2
但是刷新页面，也就是重新提交请求后
y的值会逐渐变大：
hello Jsp
x的值：2y的值：6
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- b.指令</span><br><span class="line"></span><br><span class="line">  - page指令：</span><br><span class="line"></span><br><span class="line">    - ```jsp</span><br><span class="line">      &lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;</span><br><span class="line">          pageEncoding=&quot;UTF-8&quot; import = &quot;java.util.Date&quot;%&gt;</span><br><span class="line">      language：jsp页面使用的脚本语言</span><br><span class="line">      import：导入的类</span><br><span class="line">      pageEncoding：jsp自身编码 JSP最终是要编译成java的</span><br><span class="line">      contentType：浏览器解析Jsp的编码</span><br></pre></td></tr></table></figure>

    
</code></pre>
</li>
<li><p>c. 注释</p>
<ul>
<li><pre><code class="html">&lt;!-- html 注释--&gt;
java注释 // /**/
jsp注释 &lt;%-- --%&gt;
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># JSP9大内置对象（自带的，不需要new 也能使用的对象）</span><br><span class="line"></span><br><span class="line">- out ：输出对象，向客户端输出内容，当浏览器访问时，浏览器就是客户端</span><br><span class="line"></span><br><span class="line">- request：请求对象，存储&quot;客户端向服务端发送的请求内容&quot;</span><br><span class="line"></span><br><span class="line">  - void setCharacterEncoding(String encoding)用来确保发往服务器的参数的编码格式例如&quot;utf-8&quot;</span><br><span class="line">  - String getParameter(String name)根据请求的字段名key（input标签的name属性值），返回字段值（也就是input标签的value属性）</span><br><span class="line">  - String[] getParameterValues(String name);根据请求的字段名key，返回多个字段值values，通常使用checkbox</span><br><span class="line">  - request.getRequestDispatcher(&quot;b.jsp&quot;).forward(request, response);请求转发 跳转页面 A-&gt;B</span><br><span class="line">  - ServletContext getServletContext();获取项目的ServletContext 对象</span><br><span class="line"></span><br><span class="line">  Demo1：注册 register.jsp --&gt; registerResult.jsp</span><br><span class="line"></span><br><span class="line">  ```jsp</span><br><span class="line">  &lt;!-- register.jsp --&gt;</span><br><span class="line">  &lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;</span><br><span class="line">      pageEncoding=&quot;UTF-8&quot;%&gt;</span><br><span class="line">  &lt;!DOCTYPE html&gt;</span><br><span class="line">  &lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">  &lt;title&gt;Insert title here&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">  	&lt;form action=&quot;registerResult.jsp&quot; method=&quot;get&quot;&gt;</span><br><span class="line">  		用户名：&lt;input type=&quot;text&quot; name=&quot;uname&quot;/&gt;&lt;br/&gt;</span><br><span class="line">  		密码：&lt;input type=&quot;password&quot; name=&quot;upwd&quot;/&gt;&lt;br/&gt;</span><br><span class="line">  		年龄：&lt;input type=&quot;text&quot; name=&quot;uage&quot;/&gt;&lt;br/&gt;</span><br><span class="line">  		爱好：&lt;br/&gt;</span><br><span class="line">  		&lt;input type=&quot;checkbox&quot; name=&quot;uhobbies&quot; value=&quot;足球&quot;/&gt;足球、</span><br><span class="line">  		&lt;input type=&quot;checkbox&quot; name=&quot;uhobbies&quot; value=&quot;篮球&quot;/&gt;篮球、</span><br><span class="line">  		&lt;input type=&quot;checkbox&quot; name=&quot;uhobbies&quot; value=&quot;乒乓球&quot;/&gt;乒乓球&lt;br/&gt;</span><br><span class="line">  		&lt;input type=&quot;submit&quot; value=&quot;注册&quot;&gt;</span><br><span class="line">  	&lt;/form&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">  &lt;/html&gt;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;!-- registerResult.jsp --&gt;</span><br><span class="line">&lt;%@ page language=<span class="string">&quot;java&quot;</span> contentType=<span class="string">&quot;text/html; charset=UTF-8&quot;</span></span><br><span class="line">    pageEncoding=<span class="string">&quot;UTF-8&quot;</span>%&gt;</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">&lt;title&gt;Insert title here&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">	&lt;%</span><br><span class="line">		request.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">		<span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;uname&quot;</span>);</span><br><span class="line">		<span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> Integer.parseInt(request.getParameter(<span class="string">&quot;uage&quot;</span>));</span><br><span class="line">		<span class="type">String</span> <span class="variable">pwd</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;upwd&quot;</span>);</span><br><span class="line">		String[] hobbies = request.getParameterValues(<span class="string">&quot;uhobbies&quot;</span>);</span><br><span class="line">	%&gt;</span><br><span class="line">	注册成功,信息如下:&lt;br/&gt;</span><br><span class="line">	&lt;%=<span class="string">&quot;name:&quot;</span> + name %&gt;&lt;br/&gt;</span><br><span class="line">	&lt;%=<span class="string">&quot;age:&quot;</span>  + age%&gt;&lt;br/&gt;</span><br><span class="line">	&lt;%=<span class="string">&quot;pwd:&quot;</span>  + pwd%&gt;&lt;br/&gt;</span><br><span class="line">	&lt;%</span><br><span class="line">		<span class="keyword">if</span> (hobbies != <span class="literal">null</span> )&#123;</span><br><span class="line">			<span class="keyword">for</span> (String hobby : hobbies)&#123;</span><br><span class="line">				out.print(hobby + <span class="string">&quot; &quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	%&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p><a href="http://localhost:8888/myjspproject/registerResult.jsp?uname=sza&upwd=sza415&uage=22&uhobbies=%E8%B6%B3%E7%90%83&uhobbies=%E7%AF%AE%E7%90%83">http://localhost:8888/myjspproject/registerResult.jsp?uname=sza&amp;upwd=sza415&amp;uage=22&amp;uhobbies=%E8%B6%B3%E7%90%83&amp;uhobbies=%E7%AF%AE%E7%90%83</a></p>
<p>get提交方式：method &#x3D; “get” 和地址栏、超链接（<a href="xx">）请求方式默认都属于get提交方式</a></p>
<p>get与post区别：</p>
<ol>
<li>get方式 在地址栏显示请求信息（但是地址栏能够容纳的信息有限，4-5kb，如果请求数据存在大文件，会出现地址栏无法容纳全部的数据而出错），post不会显示</li>
<li>文件上传，必须是post</li>
</ol>
</li>
<li><p>response响应对象</p>
<ul>
<li><strong>void</strong> addCookie(Cookie cookie)：服务端向客户端增加Cookie对象</li>
<li><strong>void</strong> sendRedirect(String location) <strong>throws</strong> IOException; 重定向页面跳转</li>
</ul>
<p><strong>Demo1：登录 login.jsp -&gt; checkLogin.jsp -&gt; loginSuccess.jsp</strong></p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;!-- login.jsp --&gt;</span><br><span class="line">&lt;%@ page language=<span class="string">&quot;java&quot;</span> contentType=<span class="string">&quot;text/html; charset=UTF-8&quot;</span></span><br><span class="line">    pageEncoding=<span class="string">&quot;UTF-8&quot;</span>%&gt;</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">&lt;title&gt;Insert title here&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">	</span><br><span class="line">	&lt;form action=<span class="string">&quot;checkLogin.jsp&quot;</span>&gt;</span><br><span class="line">		用户名：&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;uname&quot;</span>/&gt;&lt;br/&gt;</span><br><span class="line">		密码：&lt;input type=<span class="string">&quot;password&quot;</span> name=<span class="string">&quot;upwd&quot;</span>/&gt;&lt;br/&gt;</span><br><span class="line">		&lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;登录&quot;</span>&gt;</span><br><span class="line">	&lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;!-- checkLogin.jsp --&gt;</span><br><span class="line">&lt;%@ page language=<span class="string">&quot;java&quot;</span> contentType=<span class="string">&quot;text/html; charset=UTF-8&quot;</span></span><br><span class="line">    pageEncoding=<span class="string">&quot;UTF-8&quot;</span>%&gt;</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">&lt;title&gt;Insert title here&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">		&lt;%</span><br><span class="line"></span><br><span class="line">			request.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">			<span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;uname&quot;</span>);</span><br><span class="line">			<span class="type">String</span> <span class="variable">pwd</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;upwd&quot;</span>);</span><br><span class="line">			<span class="keyword">if</span> (<span class="string">&quot;sza&quot;</span>.equals(name) &amp;&amp; <span class="string">&quot;sza0415&quot;</span>.equals(pwd))&#123;</span><br><span class="line">				 response.sendRedirect(<span class="string">&quot;loginSuccess.jsp&quot;</span>);</span><br><span class="line">				<span class="comment">//request.getRequestDispatcher(&quot;loginSuccess.jsp&quot;).forward(request,response);</span></span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				out.print(<span class="string">&quot;ERROR&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		%&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;!-- loginSuccess.jsp --&gt;</span><br><span class="line">&lt;%@ page language=<span class="string">&quot;java&quot;</span> contentType=<span class="string">&quot;text/html; charset=UTF-8&quot;</span></span><br><span class="line">    pageEncoding=<span class="string">&quot;UTF-8&quot;</span>%&gt;</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">&lt;title&gt;Insert title here&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">		登录成功!!!</span><br><span class="line">		欢迎您:&lt;br/&gt;</span><br><span class="line">		&lt;%</span><br><span class="line">			<span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;uname&quot;</span>);</span><br><span class="line">			<span class="type">String</span> <span class="variable">pwd</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;upwd&quot;</span>);</span><br><span class="line">		%&gt;</span><br><span class="line">		&lt;%=name%&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>请求转发和重定向的区别：</p>
<table>
<thead>
<tr>
<th></th>
<th>请求转发</th>
<th>重定向</th>
</tr>
</thead>
<tbody><tr>
<td>地址栏是否改变</td>
<td>不变（checkLogin.jsp）</td>
<td>改变(loginSuccess.jsp)</td>
</tr>
<tr>
<td>是否保留第一次请求的数据</td>
<td>保留</td>
<td>不保留</td>
</tr>
<tr>
<td>请求的次数</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>请求转发是服务端行为,重定向是客户端行为. 客户端向服务端请求资源(发现没有),服务端调用请求转发,调用内部方法获得资源,最后返回客户端.而重定向是客户端向服务端请求资源,服务端不为客户端寻找资源,而是发送资源新的地址给客户端,客户端重新根据该地址再去向服务端请求资源.</p>
<ul>
<li><p>从地址栏显示来说<br>forward是服务器请求资源,服务器直接访问目标地址的URL,把那个URL的响应内容读取过来,然后把这些内容再发给浏览器.浏览器(客户端)根本不知道服务器发送的内容从哪里来的,所以它的地址栏还是原来的地址.</p>
<p>redirect是服务端根据逻辑,发送一个状态码,告诉浏览器重新去请求那个地址.所以地址栏显示的是新的URL.</p>
</li>
<li><p>从数据共享来说<br>forward:转发页面和转发到的页面可以共享request里面的数据.<br>redirect:不能共享数据.</p>
</li>
<li><p>从运用地方来说<br>forward:一般用于用户登陆的时候,根据角色转发到相应的模块.<br>redirect:一般用于用户注销登陆时返回主页面和跳转到其它的网站等</p>
</li>
<li><p>从效率来说<br>forward:高.<br>redirect:低.</p>
</li>
</ul>
</li>
<li><p>session</p>
<ul>
<li>Cookie不是内置对象,因而需要new:Cookie对象是由服务端产生,再发送给客户端保存.相当于本地缓存的作用.</li>
<li><strong>public</strong> Cookie(String name, String value)</li>
</ul>
<p>Demo: response_AddCookies.jsp -&gt; Cookie_GetResult.jsp</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;!-- response_AddCookies.jsp --&gt;</span><br><span class="line">&lt;%@ page language=<span class="string">&quot;java&quot;</span> contentType=<span class="string">&quot;text/html; charset=UTF-8&quot;</span></span><br><span class="line">    pageEncoding=<span class="string">&quot;UTF-8&quot;</span>%&gt;</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">&lt;title&gt;Insert title here&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">		&lt;%</span><br><span class="line">			<span class="type">Cookie</span> <span class="variable">cookie1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cookie</span>(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;sza&quot;</span>);</span><br><span class="line">			<span class="type">Cookie</span> <span class="variable">cookie2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cookie</span>(<span class="string">&quot;age&quot;</span>,<span class="string">&quot;21&quot;</span>);</span><br><span class="line">			</span><br><span class="line">			response.addCookie(cookie1);</span><br><span class="line">			response.addCookie(cookie2);</span><br><span class="line">			response.sendRedirect(<span class="string">&quot;Cookie_GetResult.jsp&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		%&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;!-- Cookie_GetResult.jsp --&gt;</span><br><span class="line">&lt;%@ page language=<span class="string">&quot;java&quot;</span> contentType=<span class="string">&quot;text/html; charset=UTF-8&quot;</span></span><br><span class="line">    pageEncoding=<span class="string">&quot;UTF-8&quot;</span>%&gt;</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">&lt;title&gt;Insert title here&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">		&lt;%</span><br><span class="line">			Cookie[] cookies = request.getCookies();</span><br><span class="line">		</span><br><span class="line">			<span class="keyword">for</span> (Cookie cookie : cookies)&#123;</span><br><span class="line">				out.print(<span class="string">&quot;-----------------------------&lt;br/&gt;&quot;</span>);</span><br><span class="line">				out.print(cookie.getName() + cookie.getValue() + <span class="string">&quot;&lt;br/&gt;&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		</span><br><span class="line">		%&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>


</li>
<li><p>application</p>
</li>
<li><p>config</p>
</li>
<li><p>pageContext</p>
</li>
<li><p>page</p>
</li>
<li><p>exception</p>
</li>
</ul>
<h2 id="JSP运行原理"><a href="#JSP运行原理" class="headerlink" title="JSP运行原理"></a><strong>JSP运行原理</strong></h2><p>当用户访问JSP页面时，JSP页面的处理过程如图所示:</p>
<img src="337375-20190411125716354-1493799102.png" class title="img">

<p><font color="blue"><strong>JSP预处理和编译阶段</strong></font></p>
<p>客户第一次请求jsp页面时，jsp引擎会将jsp文件中的脚本代码(HTML)和代码片段(Java代码)全部转换为java代码，转换过程非常直观：对于HTML文本只需要用简单的out.println方法包裹，对于java脚本只做保留或简单的处理。预处理阶段把jsp文件解析为java代码，编译阶段jsp引擎把java代码编译成servlet类文件，对于Tomcat，生成的class文件默认情况下存放在<code>&lt;Tomcat&gt;/work</code>目录下。可以简单看一下index.jsp生成的index_jsp.java代码:</p>
<img src="image-20241029165856942.png" class title="image-20241029165856942">

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">_jspService</span><span class="params">(<span class="keyword">final</span> javax.servlet.http.HttpServletRequest request, <span class="keyword">final</span> javax.servlet.http.HttpServletResponse response)</span></span><br><span class="line">      <span class="keyword">throws</span> java.io.IOException, javax.servlet.ServletException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!javax.servlet.DispatcherType.ERROR.equals(request.getDispatcherType())) &#123;</span><br><span class="line">      <span class="keyword">final</span> java.lang.<span class="type">String</span> <span class="variable">_jspx_method</span> <span class="operator">=</span> request.getMethod();</span><br><span class="line">      <span class="keyword">if</span> (<span class="string">&quot;OPTIONS&quot;</span>.equals(_jspx_method)) &#123;</span><br><span class="line">        response.setHeader(<span class="string">&quot;Allow&quot;</span>,<span class="string">&quot;GET, HEAD, POST, OPTIONS&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="string">&quot;GET&quot;</span>.equals(_jspx_method) &amp;&amp; !<span class="string">&quot;POST&quot;</span>.equals(_jspx_method) &amp;&amp; !<span class="string">&quot;HEAD&quot;</span>.equals(_jspx_method)) &#123;</span><br><span class="line">        response.setHeader(<span class="string">&quot;Allow&quot;</span>,<span class="string">&quot;GET, HEAD, POST, OPTIONS&quot;</span>);</span><br><span class="line">        response.sendError(HttpServletResponse.SC_METHOD_NOT_ALLOWED, <span class="string">&quot;JSP 只允许 GET、POST 或 HEAD。Jasper 还允许 OPTIONS&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> javax.servlet.jsp.PageContext pageContext;</span><br><span class="line">    javax.servlet.http.<span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">final</span> javax.servlet.ServletContext application;</span><br><span class="line">    <span class="keyword">final</span> javax.servlet.ServletConfig config;</span><br><span class="line">    javax.servlet.jsp.<span class="type">JspWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">final</span> java.lang.<span class="type">Object</span> <span class="variable">page</span> <span class="operator">=</span> <span class="built_in">this</span>;</span><br><span class="line">    javax.servlet.jsp.<span class="type">JspWriter</span> <span class="variable">_jspx_out</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    javax.servlet.jsp.<span class="type">PageContext</span> <span class="variable">_jspx_page_context</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      response.setContentType(<span class="string">&quot;text/html; charset=UTF-8&quot;</span>);</span><br><span class="line">      pageContext = _jspxFactory.getPageContext(<span class="built_in">this</span>, request, response,</span><br><span class="line">      			<span class="literal">null</span>, <span class="literal">true</span>, <span class="number">8192</span>, <span class="literal">true</span>);</span><br><span class="line">      _jspx_page_context = pageContext;</span><br><span class="line">      application = pageContext.getServletContext();</span><br><span class="line">      config = pageContext.getServletConfig();</span><br><span class="line">      session = pageContext.getSession();</span><br><span class="line">      out = pageContext.getOut();</span><br><span class="line">      _jspx_out = out;</span><br><span class="line"></span><br><span class="line">      out.write(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">      out.write(<span class="string">&quot;&lt;!DOCTYPE html&gt;\r\n&quot;</span>);</span><br><span class="line">      out.write(<span class="string">&quot;&lt;html&gt;\r\n&quot;</span>);</span><br><span class="line">      out.write(<span class="string">&quot;&lt;head&gt;\r\n&quot;</span>);</span><br><span class="line">      out.write(<span class="string">&quot;&lt;meta charset=\&quot;UTF-8\&quot;&gt;\r\n&quot;</span>);</span><br><span class="line">      out.write(<span class="string">&quot;&lt;title&gt;Insert title here&lt;/title&gt;\r\n&quot;</span>);</span><br><span class="line">      out.write(<span class="string">&quot;&lt;/head&gt;\r\n&quot;</span>);</span><br><span class="line">      out.write(<span class="string">&quot;&lt;body&gt;\r\n&quot;</span>);</span><br><span class="line">      out.write(<span class="string">&quot;	\r\n&quot;</span>);</span><br><span class="line">      out.write(<span class="string">&quot;		&lt;form action=\&quot;uploadservlet\&quot; method=\&quot;post\&quot; enctype=\&quot;multipart/form-data\&quot;&gt;\r\n&quot;</span>);</span><br><span class="line">      out.write(<span class="string">&quot;			学号：&lt;input name=\&quot;sno\&quot;&gt;&lt;br&gt;\r\n&quot;</span>);</span><br><span class="line">      out.write(<span class="string">&quot;			姓名：&lt;input name=\&quot;sname\&quot;&gt;&lt;br&gt;\r\n&quot;</span>);</span><br><span class="line">      out.write(<span class="string">&quot;			上传照片：&lt;input type=\&quot;file\&quot; name=\&quot;spicture\&quot;&gt;\r\n&quot;</span>);</span><br><span class="line">      out.write(<span class="string">&quot;			&lt;input type=\&quot;submit\&quot; name=\&quot;添加\&quot;&gt;\r\n&quot;</span>);</span><br><span class="line">      out.write(<span class="string">&quot;		\r\n&quot;</span>);</span><br><span class="line">      out.write(<span class="string">&quot;		&lt;/form&gt;\r\n&quot;</span>);</span><br><span class="line">      out.write(<span class="string">&quot;&lt;/body&gt;\r\n&quot;</span>);</span><br><span class="line">      out.write(<span class="string">&quot;&lt;/html&gt;&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (java.lang.Throwable t) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!(t <span class="keyword">instanceof</span> javax.servlet.jsp.SkipPageException))&#123;</span><br><span class="line">        out = _jspx_out;</span><br><span class="line">        <span class="keyword">if</span> (out != <span class="literal">null</span> &amp;&amp; out.getBufferSize() != <span class="number">0</span>)</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (response.isCommitted()) &#123;</span><br><span class="line">              out.flush();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              out.clearBuffer();</span><br><span class="line">            &#125;</span><br><span class="line">          &#125; <span class="keyword">catch</span> (java.io.IOException e) &#123;&#125;</span><br><span class="line">        <span class="keyword">if</span> (_jspx_page_context != <span class="literal">null</span>) _jspx_page_context.handlePageException(t);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ServletException</span>(t);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      _jspxFactory.releasePageContext(_jspx_page_context);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到生成的_jspService(request,response)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">_jspService</span><span class="params">(<span class="keyword">final</span> javax.servlet.http.HttpServletRequest request, <span class="keyword">final</span> javax.servlet.http.HttpServletResponse response)</span></span><br></pre></td></tr></table></figure>

<p>和我们自己编写的Servlet是相同的。</p>
<img src="image-20241029170613569.png" class title="image-20241029170613569">

<p>但是值得注意的是，JSP九个内置对象，request和response是作为_jspService的参数传入，而其余的内置对象，则会在后续的代码中声明并初始化：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="comment">// 声明其余内置对象</span></span><br><span class="line"><span class="keyword">final</span> javax.servlet.jsp.PageContext pageContext;</span><br><span class="line">   javax.servlet.http.<span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">   <span class="keyword">final</span> javax.servlet.ServletContext application;</span><br><span class="line">   <span class="keyword">final</span> javax.servlet.ServletConfig config;</span><br><span class="line">   javax.servlet.jsp.<span class="type">JspWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">   <span class="keyword">final</span> java.lang.<span class="type">Object</span> <span class="variable">page</span> <span class="operator">=</span> <span class="built_in">this</span>;</span><br><span class="line">   javax.servlet.jsp.<span class="type">JspWriter</span> <span class="variable">_jspx_out</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">   javax.servlet.jsp.<span class="type">PageContext</span> <span class="variable">_jspx_page_context</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化其余内置对象</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  response.setContentType(<span class="string">&quot;text/html; charset=UTF-8&quot;</span>);</span><br><span class="line">  pageContext = _jspxFactory.getPageContext(<span class="built_in">this</span>, request, response,</span><br><span class="line">  			<span class="literal">null</span>, <span class="literal">true</span>, <span class="number">8192</span>, <span class="literal">true</span>);</span><br><span class="line">  _jspx_page_context = pageContext;</span><br><span class="line">  application = pageContext.getServletContext();</span><br><span class="line">  config = pageContext.getServletConfig();</span><br><span class="line">  session = pageContext.getSession();</span><br><span class="line">  out = pageContext.getOut();</span><br><span class="line">  _jspx_out = out;</span><br><span class="line">  ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这也就可以解释，在Servlet的监听器当中，为什么第一次访问jsp页面（pageContext.getSession()），会调用pageContext.getSession()监听器的sessionCreated方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sessionCreated</span><span class="params">(HttpSessionEvent se)</span></span><br></pre></td></tr></table></figure>



<p><font color="blue"><strong>JSP响应阶段</strong></font></p>
<p>编译后的class对象被加载到容器中，并根据用户的请求生成HTML格式的响应页面返回给客户端。<br>在执行jsp网页时，通常分为两个时期：转译时期和请求时期。转译时期jsp页面被翻译成Servlet类，然后编译成Class文件;用户请求时期，servlet类被执行，生成HTML响应至客户端。</p>
<p>jsp的转译和请求都在在第一次访问时进行的，所以用户在第一次访问jsp页面时响应时间会比较长。在之后的请求中，这些工作已经完成，时间延长问题不存在了。在处理后续的访问时jsp和servlet的执行速度是一样的。</p>
<h3 id="容器、jsp容器、jsp引擎"><a href="#容器、jsp容器、jsp引擎" class="headerlink" title="容器、jsp容器、jsp引擎"></a>容器、jsp容器、jsp引擎</h3><p>jsp要转译为servlet，但是servlet没有main()方法，servlet对象的创建、方法的调用由web容器来实现。以Tomcat为例，先看一下Tomcat的总体结构： </p>
<img src="337375-20190411125825127-1858874703.png" class title="img">

<p>从图中可以看出，Tomcat的核心组建是connector和Container，container就是容器。容器就是负责管理控制servlet的应用程序。图中的jasper就是解析jsp的jsp引擎。Tomcat既是servlet容器又是web服务器，也是jsp引擎。</p>
<h1 id="JSP-四种作用域"><a href="#JSP-四种作用域" class="headerlink" title="JSP 四种作用域"></a>JSP 四种作用域</h1><p>request（请求对象）：代表客户端的HTTP请求，包含了客户端发送的参数和数据。<br>response（响应对象）：代表服务器对客户端的HTTP响应，用于向客户端发送数据和控制响应的行为。<br>session（会话对象）：代表客户端和服务器之间的会话，用于在多个请求之间共享数据。<br>application（应用程序对象）：代表整个Web应用程序，用于在不同的用户会话之间共享数据。<br>out（输出对象）：用于向客户端发送输出，可以将内容直接写入响应流中。<br>config（配置对象）：代表当前JSP页面的配置信息，例如JSP页面的初始化参数。<br>page（页面对象）：代表当前JSP页面本身，可以用于调用JSP页面中定义的方法。<br>pageContext（页面上下文对象）：提供了对当前JSP页面上下文的访问，包括其他内置对象的访问。<br>exception（异常对象）：代表在JSP页面中发生的异常，可以用于处理异常情况。</p>
<h2 id="JSP中page和pageContext的区别"><a href="#JSP中page和pageContext的区别" class="headerlink" title="JSP中page和pageContext的区别"></a>JSP中page和pageContext的区别</h2><p>page，JSP网页本身，page对象是当前页面转换后的Servlet类的实例，很少使用page对象</p>
<p>pageContext，javax.servlet.jsp.PageContext的实例，该对象代表该JSP页面上下文，使用该对象可以访问页面中的共享数据。</p>
<p>pageContext和page都是JSP中的内置对象，pageContext代表着JSP页面的上下文关系，能够调用、存取其他隐含对象；page代表处理当前请求时候，这个页面的实现类的实例。</p>
<ul>
<li>与Context有关的内置对象，包括pageContext、session、application<ul>
<li>pageContext对象表示当前的JSP页面的上下文环境</li>
<li>session对象表示浏览器（客户端）与服务器对话</li>
<li>application表示应用程序（web应用）的上下文环境</li>
</ul>
</li>
<li>与Servlet有关的内置对象，包括page和config<ul>
<li>page 对象表示JSP 文件转换为 Java文件后的 Servlet 对象；</li>
<li>config 对象表示 JSP 文件转換为 Java 文件后的 Servlet 的 ServletConfig对象。</li>
</ul>
</li>
</ul>
<h2 id="JSP的4种作用域"><a href="#JSP的4种作用域" class="headerlink" title="JSP的4种作用域"></a>JSP的4种作用域</h2><p>对象的作用域就是对象的生命周期和可访问性，在JSP 中有4种作用域，即页面域、请求域、会话域和应用域。</p>
<ol>
<li>页面域<ol>
<li><strong>页面域（page scope）</strong>的生命周期是指页面执行期间，存储在页面域中的对象只能在它所在的页面被访问。</li>
<li>只在一个jsp页面里有效，如果把变量放到pageContext当中，就说明它的作用对象为page，没法从页面index.jsp传递到test.jsp，只要页面跳转了，它们就不见了。</li>
</ol>
</li>
<li>请求域<ol>
<li><strong>请求域（request scope）</strong>的生命周期是指一次请求过程，包括请求被转发（forward）或者被包含（include）的情况，存储在请求域中的对象只有在此次请求过程中才可以被访问。</li>
<li>作用对象为request，它的有效范围是当前请求周期。<br>所谓请求周期，就是指从http请求发起，到服务器处理结束，返回响应的整个过程。在这个过程中可能使用forward的方式跳转了多个jsp页面，在这些页面里你都可以使用这个变量。</li>
<li>request里的变量可以跨越forward前后的两页。但是只要刷新页面，它们就重新计算了。</li>
</ol>
</li>
<li>会话域<ol>
<li><strong>会话域（session scope）</strong>的生命周期是指某个客户端与服务器所连接的时间，客户端在第1次访问服务器时创建会话，在会话过期或用户主动退出后会话结束，存储在会话域中的对象在整个会话期间（可以包含多次请求）都可以被访问。</li>
<li>有效范围当前会话，从浏览器打开到浏览器关闭这个过程</li>
<li>如果把变量放到session里，就说明它的作用域是session，它的有效范围是当前会话。<br>所谓当前会话，就是指从用户打开浏览器开始，到用户关闭浏览器这中间的过程。这个过程可能包含多个请求响应。也就是说，只要用户不关浏览器，服务器就有办法知道这些请求是一个人发起的，整个过程被称为一个会话（session），而放到会话中的变量，就可以在当前会话的所有请求里使用。</li>
</ol>
</li>
<li>应用域<ol>
<li><strong>应用域（application scope）</strong>的生命周期是指从服务器开始执行服务到服务器关闭为止，其生命周期是4个作用域中时间最长的，存储在应用域中的对象在整个应用程序运行期间可以被所有 JSP 和Servlet 共享访问。</li>
<li>如果把变量放到application里，就说明它的作用域是application，它的有效范围是整个应用。<br>整个应用是指从应用启动，到应用结束。我们没有说“从服务器启动，到服务器关闭”，是因为一个服务器可能部署多个应用，当然你关闭了服务器，就会把上面所有的应用都关闭了。</li>
<li>application作用域里的变量，它们的存活时间是最长的，如果不进行手工删除，它们就一直可以使用。<br>与上述三个不同的是，application里的变量可以被所有用户共用。如果用户甲的操作修改了application中的变量，用户乙访问时得到的是修改后的值。这在其他scope中都是不会发生的，page, request, session都是完全隔离的，无论如何修改都不会影响其他人的数据。</li>
</ol>
</li>
</ol>
<p>page里的变量没法从index.jsp传递到test.jsp。只要页面跳转了，它们就不见了。<br>request里的变量可以跨越forward前后的两页。但是只要刷新页面，它们就重新计算了。<br>session和application里的变量一直在累加，开始还看不出区别，只要关闭浏览器，再次重启浏览器访问这页，session里的变量就重新计算了。<br>application里的变量一直在累加，除非你重启tomcat，否则它会一直变大。</p>
<p>JSP 的4种作用域分别对应 pageContext、request、session 和 application 内置对象，这 4 个内置对象都可以通过 setAttribute（String key, Object value）方法存储数据，通过getAttribute(String key) 获取数据。</p>
<img src="c1e324384d6ebcfcc2dca5da71b548c2.png" class title="img">


<h1 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h1><blockquote>
<p>所谓安装Mysql&#x2F;Oracle数据库，就是在主机安装一个数据库管理系统（DBMS），这个管理程序可以管理多个数据库。（Database Managerment System）</p>
<p>一个数据库中可以创建多个表，以存储数据（信息）</p>
<p>oracle数据库启动windows: win + r 输入services.msc 启动OracleOraDb11g_home1TNSListener</p>
</blockquote>
<h3 id="JDBC：Java-DataBase-Connectivity-可以为多种关系型数据库DBMS提供统一的访问方式，目的就是为了用Java来操作数据库。"><a href="#JDBC：Java-DataBase-Connectivity-可以为多种关系型数据库DBMS提供统一的访问方式，目的就是为了用Java来操作数据库。" class="headerlink" title="JDBC：Java DataBase Connectivity 可以为多种关系型数据库DBMS提供统一的访问方式，目的就是为了用Java来操作数据库。"></a>JDBC：Java DataBase Connectivity 可以为多种<strong>关系型数据库</strong>DBMS提供统一的访问方式，目的就是为了用Java来操作数据库。</h3><img src="image-20241012115035322.png" class title="image-20241012115035322">

<p>操作数据库最直接的方式是通过驱动（其实就是一个jar包）来操作，不同的厂商有不同的驱动（oracle数据库就是oracle驱动程序，mysql，sqlserver分别是mysql驱动、sqlserver驱动）。</p>
<p>JDBC是统一的访问方式，可以屏蔽掉数据库的细节，在java程序与各个厂商驱动程序有一个JDBC DriverManager，用来管理驱动程序。</p>
<p>因此java程序只需要使用jdbc去操作JDBC DriverManager就可以操作不同的驱动，从而操作数据库。</p>
<img src="image-20241012115716521.png" class title="image-20241012115716521">

<ol>
<li>jdbc API（<u><strong><font color="red">我们主要学的内容</font></strong></u> ）：提供各种操作访问接口，Connection、Statement、PreparedStatement、ResultSet<ol>
<li><p>DriverManager：管理jdbc驱动</p>
</li>
<li><p>Connection：连接（**<u>通过DriverManager产生</u>** DriverManager.<em>getConnection</em>(<strong>URL</strong>, <strong>USERNAME</strong>, <strong>PWD</strong>)）</p>
<p>Connection 产生操作数据库的对象 Statement&#x2F;preparedStatement&#x2F;CallableStatement</p>
</li>
<li><p>Statement（PreparedStatement）：增删改查（<u><strong>通过Connection产生</strong></u> connection.createStatement()&#x2F;connection.prepareStatement(sql)）</p>
</li>
<li><p>CallableStatement：调用数据库中的存储过程&#x2F;存储函数（<u><strong>通过Connection产生</strong></u>，connection.prepareCall(sql)）</p>
<p>Statemen操作数据库：</p>
<ul>
<li>增删改：statement.executeUpdate(sql)</li>
<li>查询：statement.executeQuery(sql)</li>
</ul>
<p>PreparedStatement ：public <strong>interface</strong> PreparedStatement <strong>extends</strong> Statement 因此</p>
<ul>
<li>增删改：preparedstatement.executeUpdate(sql)</li>
<li>查询：preparedstatement.executeQuery(sql)</li>
</ul>
<p>此外 PreparedStatement 多了赋值操作：</p>
<ul>
<li>setXXX()</li>
</ul>
</li>
<li><p>ResultSet：返回的数据集 （由上面的Statement产生，保存查询的结果集select ENAME,JOB from bonus）</p>
<ul>
<li><p>resultset.next()光标下移，判断是否有下一条数据返回true&#x2F;false</p>
<ul>
<li><pre><code class="java">            while (resultset.next() != false) &#123;
                  // 根据字段名查询
                  //String ENAME = resultset.getString(&quot;ENAME&quot;);
                  //String JOB = resultset.getString(&quot;JOB&quot;);
                  //System.out.println(ENAME + &quot;--&quot; + JOB);
                  
                  // 根据序号查询 从1开始
                  String ENAME = resultset.getString(1);
                  String JOB = resultset.getString(2);
                  System.out.println(ENAME + &quot;--&quot; + JOB);
              &#125;
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   </span><br><span class="line">      - resultset.previous()：光标上移，判断上一条数据，返回true/false</span><br><span class="line">   </span><br><span class="line">      - getXXX()：获得具体的字段值，可以是String字段名查询也可以是序号查询</span><br><span class="line">   </span><br><span class="line">2. JDBC DriverManager：管理不同数据库驱动</span><br><span class="line"></span><br><span class="line">3. 各种数据库驱动，数据库厂商提供，连接和直接操作数据库</span><br><span class="line"></span><br><span class="line">### &lt;u&gt;**&lt;font color=blue&gt;Statement实现增删改查：&lt;/font&gt;**&lt;/u&gt;</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">/*Statement</span><br><span class="line"> * Update()：实现增删改操作</span><br><span class="line"> * Query()：实现查询</span><br><span class="line"> * */</span><br><span class="line">package jdbcdemo;</span><br><span class="line"></span><br><span class="line">import java.sql.Connection;</span><br><span class="line">import java.sql.DriverManager;</span><br><span class="line">import java.sql.ResultSet;</span><br><span class="line">import java.sql.SQLException;</span><br><span class="line">import java.sql.Statement;</span><br><span class="line"></span><br><span class="line">import com.mysql.cj.Query;</span><br><span class="line"></span><br><span class="line">public class JDBCStatement &#123;</span><br><span class="line">	private static final String URL = &quot;jdbc:oracle:thin:@localhost:1521:orcl&quot;;</span><br><span class="line">	private static final String USERNAME = &quot;scott&quot;;</span><br><span class="line">	private static final String PWD = &quot;tiger&quot;;</span><br><span class="line">	public static void Update()  &#123;</span><br><span class="line">		Statement statement = null;</span><br><span class="line">		Connection connection = null;</span><br><span class="line">		try &#123;</span><br><span class="line">			//a.导入驱动，加载具体的驱动类</span><br><span class="line">			Class.forName(&quot;oracle.jdbc.OracleDriver&quot;);</span><br><span class="line">			//b.与数据库建立连接</span><br><span class="line">			connection = DriverManager.getConnection(URL, USERNAME, PWD);</span><br><span class="line">			</span><br><span class="line">			//c.发送SQL，执行（增删改）命令</span><br><span class="line">			statement = connection.createStatement();</span><br><span class="line">			String sql = &quot;insert into bonus values(&#x27;sza1&#x27;,&#x27;student&#x27;,1,1)&quot;;</span><br><span class="line">			String sql1 = &quot;update bonus set JOB = &#x27;mayer&#x27; where ENAME = &#x27;sza1&#x27;&quot;;</span><br><span class="line">			String sql2 = &quot;delete from bonus where ENAME = &#x27;sza1&#x27;&quot;;</span><br><span class="line">			int count = statement.executeUpdate(sql1);//返回值表示增删改几条数据</span><br><span class="line"></span><br><span class="line">            //d.处理结果</span><br><span class="line">			if(count &gt; 0) &#123;</span><br><span class="line">				System.out.print(&quot;操作成功&quot;);</span><br><span class="line">			&#125;else &#123;</span><br><span class="line">				System.out.print(&quot;操作失败&quot;);</span><br><span class="line">			&#125;		</span><br><span class="line">		&#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;catch (SQLException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;catch (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;finally &#123;</span><br><span class="line">				try &#123;</span><br><span class="line">					if (statement != null) &#123;</span><br><span class="line">						statement.close();</span><br><span class="line">					&#125;</span><br><span class="line">					if (connection != null) &#123;</span><br><span class="line">						connection.close();</span><br><span class="line">					&#125;</span><br><span class="line">				&#125; catch (SQLException e) &#123;					</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public static void Query() &#123;</span><br><span class="line">		Connection connection = null;</span><br><span class="line">		Statement statement = null;</span><br><span class="line">		ResultSet resultset = null;</span><br><span class="line">		try &#123;</span><br><span class="line">			//a.导入驱动，加载具体的驱动类</span><br><span class="line">			Class.forName(&quot;oracle.jdbc.OracleDriver&quot;);</span><br><span class="line">			//b.与数据库建立连接</span><br><span class="line">			connection = DriverManager.getConnection(URL, USERNAME, PWD);</span><br><span class="line">			</span><br><span class="line">			//c.发送SQL，执行查询命令</span><br><span class="line">			statement = connection.createStatement();</span><br><span class="line">			String sql = &quot;select ENAME,JOB from bonus&quot;;</span><br><span class="line">			// 增删改都是executeUpdate，查询是</span><br><span class="line">			resultset = statement.executeQuery(sql);//返回值表示增删改几条数据</span><br><span class="line">            </span><br><span class="line">			//d.处理结果</span><br><span class="line">			while (resultset.next() != false) &#123;</span><br><span class="line">				// 根据字段名查询</span><br><span class="line">				//String ENAME = resultset.getString(&quot;ENAME&quot;);</span><br><span class="line">				//String JOB = resultset.getString(&quot;JOB&quot;);</span><br><span class="line">				//System.out.println(ENAME + &quot;--&quot; + JOB);</span><br><span class="line">				</span><br><span class="line">				// 根据序号查询 从1开始</span><br><span class="line">				String ENAME = resultset.getString(1);</span><br><span class="line">				String JOB = resultset.getString(2);</span><br><span class="line">				System.out.println(ENAME + &quot;--&quot; + JOB);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;catch (SQLException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;catch (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;finally &#123;</span><br><span class="line">				try &#123;</span><br><span class="line">					// 先开的后关 后开的先关 类似于栈</span><br><span class="line">					if (resultset !=null) &#123;</span><br><span class="line">						resultset.close();</span><br><span class="line">					&#125;</span><br><span class="line">					if (statement != null) &#123;</span><br><span class="line">						statement.close();</span><br><span class="line">					&#125;</span><br><span class="line">					if (connection != null) &#123;</span><br><span class="line">						connection.close();</span><br><span class="line">					&#125;</span><br><span class="line">				&#125; catch (SQLException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		//	Update();</span><br><span class="line">		Update();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ol>
<p><font color="blue">PreparedStatement实现对数据库的增删改查:</font></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*PreparedStatement实现对数据库增删改查</span></span><br><span class="line"><span class="comment"> * Update()：实现增删改操作</span></span><br><span class="line"><span class="comment"> * Query()：实现查询</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">package</span> jdbcdemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"><span class="keyword">import</span> java.sql.PreparedStatement;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.sql.Statement;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JDBCPreparedStatement</span> &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">URL</span> <span class="operator">=</span> <span class="string">&quot;jdbc:oracle:thin:@localhost:1521:orcl&quot;</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">USERNAME</span> <span class="operator">=</span> <span class="string">&quot;scott&quot;</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PWD</span> <span class="operator">=</span> <span class="string">&quot;tiger&quot;</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">Update</span><span class="params">()</span>  &#123;</span><br><span class="line">		<span class="type">PreparedStatement</span> <span class="variable">preparedstatement</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">		<span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">//a.导入驱动，加载具体的驱动类</span></span><br><span class="line">			Class.forName(<span class="string">&quot;oracle.jdbc.OracleDriver&quot;</span>);</span><br><span class="line">			<span class="comment">//b.与数据库建立连接</span></span><br><span class="line">			connection = DriverManager.getConnection(URL, USERNAME, PWD);</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//c.发送SQL，执行（增删改）命令 </span></span><br><span class="line">			<span class="comment">//c.1 先写SQL（存在占位符）</span></span><br><span class="line">			</span><br><span class="line">			<span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into bonus values(?,?,?,?)&quot;</span>;</span><br><span class="line">			<span class="comment">// String sql = &quot;insert into bonus values(&#x27;sza1&#x27;,&#x27;student&#x27;,1,1)&quot;;</span></span><br><span class="line">			<span class="comment">// String sql1 = &quot;update bonus set JOB = &#x27;mayer&#x27; where ENAME = &#x27;sza1&#x27;&quot;;</span></span><br><span class="line">			<span class="comment">// String sql2 = &quot;delete from bonus where ENAME = &#x27;sza1&#x27;&quot;;</span></span><br><span class="line">			</span><br><span class="line">			<span class="comment">//c.2 创建preparedstatement时，将sql作为参数预编译</span></span><br><span class="line">			preparedstatement = connection.prepareStatement(sql);</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//c.3 向之前sql语句的占位符，依次填充内容</span></span><br><span class="line">			preparedstatement.setString(<span class="number">1</span>, <span class="string">&quot;sza1&quot;</span>);</span><br><span class="line">			preparedstatement.setString(<span class="number">2</span>, <span class="string">&quot;student&quot;</span>);</span><br><span class="line">			preparedstatement.setInt(<span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line">			preparedstatement.setInt(<span class="number">4</span>, <span class="number">1</span>);</span><br><span class="line">			<span class="comment">// executeUpdate() 这里不再需要sql语句了</span></span><br><span class="line">			<span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> preparedstatement.executeUpdate();<span class="comment">//返回值表示增删改几条数据</span></span><br><span class="line"></span><br><span class="line">			<span class="comment">//d.处理结果</span></span><br><span class="line">			<span class="keyword">if</span>(count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">				System.out.print(<span class="string">&quot;操作成功&quot;</span>);</span><br><span class="line">			&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">				System.out.print(<span class="string">&quot;操作失败&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;<span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					<span class="keyword">if</span> (preparedstatement != <span class="literal">null</span>) &#123;</span><br><span class="line">						preparedstatement.close();</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">if</span> (connection != <span class="literal">null</span>) &#123;</span><br><span class="line">						connection.close();</span><br><span class="line">					&#125;</span><br><span class="line">				&#125; <span class="keyword">catch</span> (SQLException e) &#123;	</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">Query</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="type">PreparedStatement</span> <span class="variable">preparedstatement</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="type">ResultSet</span> <span class="variable">resultset</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">//a.导入驱动，加载具体的驱动类</span></span><br><span class="line">			Class.forName(<span class="string">&quot;oracle.jdbc.OracleDriver&quot;</span>);</span><br><span class="line">			<span class="comment">//b.与数据库建立连接</span></span><br><span class="line">			connection = DriverManager.getConnection(URL, USERNAME, PWD);</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//c.发送SQL，执行查询命令</span></span><br><span class="line">			<span class="comment">//c.1 先写SQL（存在占位符）</span></span><br><span class="line">			<span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select ENAME,JOB from bonus&quot;</span>;</span><br><span class="line">			<span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;za1&quot;</span>;</span><br><span class="line">			<span class="type">String</span> <span class="variable">sql1</span> <span class="operator">=</span> <span class="string">&quot;select ENAME,JOB from bonus where ENAME like ?&quot;</span>;</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//c.2 创建preparedstatement时，将sql作为参数预编译</span></span><br><span class="line">			preparedstatement = connection.prepareStatement(sql1);</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//c.3 向之前sql语句的占位符，依次填充内容</span></span><br><span class="line">			preparedstatement.setString(<span class="number">1</span>, <span class="string">&quot;%&quot;</span> + name +<span class="string">&quot;%&quot;</span>);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 增删改都是executeUpdate，查询是</span></span><br><span class="line">			<span class="comment">// executeQuery() 这里不再需要sql语句了</span></span><br><span class="line">			resultset = preparedstatement.executeQuery();<span class="comment">//返回值表示增删改几条数据</span></span><br><span class="line">			</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//d.处理结果</span></span><br><span class="line">			<span class="keyword">while</span> (resultset.next() != <span class="literal">false</span>) &#123;</span><br><span class="line">				<span class="comment">// 根据字段名查询</span></span><br><span class="line">				<span class="comment">//String ENAME = resultset.getString(&quot;ENAME&quot;);</span></span><br><span class="line">				<span class="comment">//String JOB = resultset.getString(&quot;JOB&quot;);</span></span><br><span class="line">				<span class="comment">//System.out.println(ENAME + &quot;--&quot; + JOB);</span></span><br><span class="line">				</span><br><span class="line">				<span class="comment">// 根据序号查询 从1开始</span></span><br><span class="line">				<span class="type">String</span> <span class="variable">ENAME</span> <span class="operator">=</span> resultset.getString(<span class="number">1</span>);</span><br><span class="line">				<span class="type">String</span> <span class="variable">JOB</span> <span class="operator">=</span> resultset.getString(<span class="number">2</span>);</span><br><span class="line">				System.out.println(ENAME + <span class="string">&quot;--&quot;</span> + JOB);</span><br><span class="line">			&#125;	</span><br><span class="line">		&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;<span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					<span class="comment">// 先开的后关 后开的先关 类似于栈</span></span><br><span class="line">					<span class="keyword">if</span> (resultset !=<span class="literal">null</span>) &#123;</span><br><span class="line">						resultset.close();</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">if</span> (preparedstatement != <span class="literal">null</span>) &#123;</span><br><span class="line">						preparedstatement.close();</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">if</span> (connection != <span class="literal">null</span>) &#123;</span><br><span class="line">						connection.close();</span><br><span class="line">					&#125;</span><br><span class="line">				&#125; <span class="keyword">catch</span> (SQLException e) &#123;		</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		</span><br><span class="line">		Query();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><u><font color="blue">PreparedStatement与Statement在使用时的区别：</font></u></strong></p>
<ul>
<li>Statement:<ul>
<li>sql语句</li>
<li>创建Statement对象，connection.createStatement();&#x2F;&#x2F;sql语句可以在创建Statement对象后再写</li>
<li>执行executeUpdate(sql)&#x2F;executeQuery(sql)</li>
</ul>
</li>
<li>PreparedStatement<ul>
<li>写好sql语句（可能存在占位符）</li>
<li>sql语句作为参数创建PreparedStatement对象，connection.prepareStatement(sql);</li>
<li>PreparedStatement对象调用setXXX()函数填充占位符</li>
<li>执行executeUpdate()&#x2F;executeQuery()，没有sql参数</li>
</ul>
</li>
</ul>
<h4 id="推荐使用PreparedStatement：原因如下："><a href="#推荐使用PreparedStatement：原因如下：" class="headerlink" title="推荐使用PreparedStatement：原因如下："></a>推荐使用PreparedStatement：原因如下：</h4><p><strong>1.编码更加简便（避免了字符串的拼接）</strong></p>
<p>String name &#x3D; “zs” ;<br>int age &#x3D; 23 ;</p>
<p><strong>stmt:（Statement）</strong><br>String sql &#x3D;” insert into student(stuno,stuname) values(‘“+name+”‘,  “+age+” )    “ ;<br>stmt.executeUpdate(sql);</p>
<p><strong>pstmt:（PreparedStatement）</strong><br>String sql &#x3D;” insert into student(stuno,stuname) values(?,?) “ ;<br>pstmt &#x3D; connection.prepareStatement(sql);&#x2F;&#x2F;预编译SQL<br>pstmt.setString(1,name);<br>pstmt.setInt(2,age);</p>
<p><strong>2.提高性能(因为 有预编译操作，预编译只需要执行一次)</strong><br><strong>需求</strong>：需要重复增加100条数<br><strong>stmt</strong>:<br>String sql &#x3D;” insert into student(stuno,stuname) values(‘“+name+”‘,  “+age+” )    “ ;<br>for(100)<br>stmt.executeUpdate(sql);</p>
<p><strong>pstmt:</strong><br>String sql &#x3D;” insert into student(stuno,stuname) values(?,?) “ ;<br>pstmt &#x3D; connection.prepareStatement(sql);&#x2F;&#x2F;预编译SQL<br>pstmt.setString(1,name);<br>pstmt.setInt(2,age);<br>for( 100){<br>pstmt.executeUpdate();<br>}</p>
<p><strong>3.安全（可以有效防止sql注入）</strong></p>
<ul>
<li>sql注入： 将客户输入的内容  和 开发人员的SQL语句 混为一体。</li>
<li>stmt:存在被sql注入的风险<br>(例如输入  密码：任意值 ‘ or 1&#x3D;1 –<br>   用户名：任意值)</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.sql.Statement;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JDBCDemo</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">URL</span> <span class="operator">=</span> <span class="string">&quot;jdbc:oracle:thin:@localhost:1521:MLDN&quot;</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">USERNAME</span> <span class="operator">=</span> <span class="string">&quot;c##scott&quot;</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PWD</span> <span class="operator">=</span> <span class="string">&quot;tiger&quot;</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">query</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">		<span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">		<span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="literal">null</span> ; </span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// a.导入驱动，加载具体的驱动类</span></span><br><span class="line">			Class.forName(<span class="string">&quot;oracle.jdbc.OracleDriver&quot;</span>);<span class="comment">// 加载具体的驱动类</span></span><br><span class="line">			<span class="comment">// b.与数据库建立连接</span></span><br><span class="line">			connection = DriverManager.getConnection(URL, USERNAME, PWD);</span><br><span class="line">			<span class="comment">// c.发送sql，执行(增删改、【查】)</span></span><br><span class="line">			stmt = connection.createStatement();</span><br><span class="line"><span class="comment">//			String sql = &quot;select stuno,stuname from student&quot;;</span></span><br><span class="line">			Scanner input= <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">			</span><br><span class="line">			System.out.println(<span class="string">&quot;请输入用户名&quot;</span>);</span><br><span class="line">			<span class="type">String</span> <span class="variable">pwd</span> <span class="operator">=</span> input.nextLine() ;</span><br><span class="line">			System.out.println(<span class="string">&quot;请输入密码：&quot;</span>);</span><br><span class="line">			<span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> input.nextLine() ;</span><br><span class="line">			<span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select count(*) from login where id=&#x27;&quot;</span>+name+<span class="string">&quot;&#x27; and name =&#x27;&quot;</span>+pwd+<span class="string">&quot;&#x27; &quot;</span> ;</span><br><span class="line"><span class="comment">//			String sql = &quot;select * from student where stuname like &#x27;%&quot;+name+&quot;%&#x27;&quot;;</span></span><br><span class="line">			<span class="comment">// 执行SQL(增删改executeUpdate()，查询executeQuery())</span></span><br><span class="line">			rs = stmt.executeQuery(sql); </span><br><span class="line">			<span class="comment">// d.处理结果</span></span><br><span class="line">			<span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(rs.next()) &#123;</span><br><span class="line">				count = rs.getInt(<span class="number">1</span>) ;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(count&gt;<span class="number">0</span>) &#123;</span><br><span class="line">				System.out.println(<span class="string">&quot;登陆成功！&quot;</span>);</span><br><span class="line">			&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">				System.out.println(<span class="string">&quot;登陆失败！&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">finally</span> &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="keyword">if</span>(rs!=<span class="literal">null</span>) rs.close(); </span><br><span class="line">				 <span class="keyword">if</span>(stmt!=<span class="literal">null</span>) stmt.close();<span class="comment">// 对象.方法</span></span><br><span class="line">				 <span class="keyword">if</span>(connection!=<span class="literal">null</span>)connection.close();</span><br><span class="line">			&#125;<span class="keyword">catch</span>(SQLException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		query() ;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在oracle数据库中存在一个login表，表中存在一个id为1，name为”zs”的条目。</p>
<p>上面程序执行时，用户名输入：随便输入。</p>
<p>​				密码：任意值 ‘ or 1&#x3D;1 –</p>
<p>能够成功登陆！</p>
<p>分析：<br>select count(<em>) from login where uname&#x3D;’任意值 ‘ or 1&#x3D;1 –’ and upwd &#x3D;’任意值’  ;由于–是oracle sql中的注释语句，于是等价于下面这句：<br>select count(</em>) from login where uname&#x3D;’任意值 ‘ or 1&#x3D;1 ;于是永远都是true。</p>
<p>pstmt:有效防止sql注入<br>推荐使用pstmt</p>
<h3 id="处理CLOB-BLOB类型"><a href="#处理CLOB-BLOB类型" class="headerlink" title="处理CLOB&#x2F;BLOB类型"></a>处理CLOB&#x2F;BLOB类型</h3><p>处理稍大型数据：</p>
<p>思路简介：</p>
<p>a.存储路径	E:\JDK_API_zh_CN.CHM<br>    通过JDBC存储文件路径，然后 根据IO操作处理<br>    例如：JDBC将 E:\JDK_API_zh_CN.CHM 文件 以字符串形式“E:\JDK_API_zh_CN.CHM”存储到数据中<br>        获取：1.获取该路径“E:\JDK_API_zh_CN.CHM”  2.IO	<br>b.<br>    CLOB：大文本数据 （小说-&gt;数据）<br>    BLOB：二进制</p>
<p>clob:</p>
<p>大文本数据   字符流 Reader Writer<br><strong>存：</strong><br>1.先通过pstmt 的? 代替小说内容 （占位符）<br>2.再通过pstmt.setCharacterStream(2, reader,  (int)file.length());  将上一步的？替换为 小说流， 注意第三个参数需要是 Int类型<br><strong>取：</strong><br>1.通过Reader reader &#x3D; rs.getCharacterStream(“NOVEL”) ; 将cloc类型的数据  保存到Reader对象中</p>
<ol start="2">
<li>将Reader通过Writer输出即可。</li>
</ol>
<p>blob:</p>
<p>二进制  字节流 InputStream OutputStream<br>与CLOB步骤基本一致，区别：setBinaryStream(…)  getBinaryStream(…)   </p>
<p>存取小说</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.Reader;</span><br><span class="line"><span class="keyword">import</span> java.io.Writer;</span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"><span class="keyword">import</span> java.sql.PreparedStatement;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.sql.Statement;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JDBCClob</span> &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">URL</span> <span class="operator">=</span> <span class="string">&quot;jdbc:oracle:thin:@localhost:1521:ORCL&quot;</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">USERNAME</span> <span class="operator">=</span> <span class="string">&quot;scott&quot;</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PWD</span> <span class="operator">=</span> <span class="string">&quot;tiger&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//通过jdbc存储大文本数据（小说）CLOB</span></span><br><span class="line">	<span class="comment">//设置CLOB类型：setCharacterStream</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">clobDemo</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">		<span class="type">PreparedStatement</span> <span class="variable">pstmt</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// a.导入驱动，加载具体的驱动类</span></span><br><span class="line">			Class.forName(<span class="string">&quot;oracle.jdbc.OracleDriver&quot;</span>);<span class="comment">// 加载具体的驱动类</span></span><br><span class="line">			<span class="comment">// b.与数据库建立连接</span></span><br><span class="line">			connection = DriverManager.getConnection(URL, USERNAME, PWD);</span><br><span class="line">			</span><br><span class="line">			<span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into mynovel values(?,?)&quot;</span>;</span><br><span class="line">			<span class="comment">// c.发送sql，执行(增删改、查)</span></span><br><span class="line">			pstmt = connection.prepareStatement(sql);</span><br><span class="line">			pstmt.setInt(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">			<span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;E:\\all.txt&quot;</span>);</span><br><span class="line">			<span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>( file) ;</span><br><span class="line">			<span class="type">Reader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>( in   ,<span class="string">&quot;UTF-8&quot;</span>) ;<span class="comment">//转换流 可以设置编码</span></span><br><span class="line">			pstmt.setCharacterStream(<span class="number">2</span>, reader,  (<span class="type">int</span>)file.length());</span><br><span class="line">			<span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span>pstmt.executeUpdate() ;</span><br><span class="line">			<span class="comment">// d.处理结果</span></span><br><span class="line">			<span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;  </span><br><span class="line">				System.out.println(<span class="string">&quot;操作成功！&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			reader.close();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">finally</span> &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				 <span class="keyword">if</span>(pstmt!=<span class="literal">null</span>) pstmt.close();<span class="comment">// 对象.方法</span></span><br><span class="line">				 <span class="keyword">if</span>(connection!=<span class="literal">null</span>)connection.close();</span><br><span class="line">			&#125;<span class="keyword">catch</span>(SQLException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//读取小说</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">clobReaderDemo</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">		<span class="type">PreparedStatement</span> <span class="variable">pstmt</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">		<span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="literal">null</span> ; </span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// a.导入驱动，加载具体的驱动类</span></span><br><span class="line">			Class.forName(<span class="string">&quot;oracle.jdbc.OracleDriver&quot;</span>);<span class="comment">// 加载具体的驱动类</span></span><br><span class="line">			<span class="comment">// b.与数据库建立连接</span></span><br><span class="line">			connection = DriverManager.getConnection(URL, USERNAME, PWD);</span><br><span class="line">			</span><br><span class="line">			<span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select NOVEL from mynovel where id = ? &quot;</span>;</span><br><span class="line">			<span class="comment">// c.发送sql，执行(查)</span></span><br><span class="line">			pstmt = connection.prepareStatement(sql);</span><br><span class="line">			pstmt.setInt(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">			</span><br><span class="line">			rs = pstmt.executeQuery() ;</span><br><span class="line">			<span class="comment">//setXxxx getXxxx      setInt  getInt</span></span><br><span class="line">			<span class="keyword">if</span>(rs.next())</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="type">Reader</span> <span class="variable">reader</span> <span class="operator">=</span> rs.getCharacterStream(<span class="string">&quot;NOVEL&quot;</span>) ;</span><br><span class="line">				<span class="type">Writer</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;src/小说.txt&quot;</span>);</span><br><span class="line">				</span><br><span class="line">				<span class="type">char</span>[] chs = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">100</span>] ;</span><br><span class="line">				<span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">				<span class="keyword">while</span>(  (len = reader.read(chs)) !=-<span class="number">1</span> ) &#123;</span><br><span class="line">					writer.write( chs,<span class="number">0</span>,len  );</span><br><span class="line">				&#125;</span><br><span class="line">				writer.close();</span><br><span class="line">				reader.close();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">finally</span> &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				 <span class="keyword">if</span>(pstmt!=<span class="literal">null</span>) pstmt.close();<span class="comment">// 对象.方法</span></span><br><span class="line">				 <span class="keyword">if</span>(connection!=<span class="literal">null</span>)connection.close();</span><br><span class="line">			&#125;<span class="keyword">catch</span>(SQLException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//		clobDemo() ;</span></span><br><span class="line">		clobReaderDemo() ;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>存取二进制文件：（如音乐）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.Reader;</span><br><span class="line"><span class="keyword">import</span> java.io.Writer;</span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"><span class="keyword">import</span> java.sql.PreparedStatement;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.sql.Statement;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JDBCBlob</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">URL</span> <span class="operator">=</span> <span class="string">&quot;jdbc:oracle:thin:@localhost:1521:ORCL&quot;</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">USERNAME</span> <span class="operator">=</span> <span class="string">&quot;scott&quot;</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PWD</span> <span class="operator">=</span> <span class="string">&quot;tiger&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//通过jdbc存储二进制类型 （mp3）</span></span><br><span class="line">	<span class="comment">//设置BLOB类型：</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">blobDemo</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">		<span class="type">PreparedStatement</span> <span class="variable">pstmt</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// a.导入驱动，加载具体的驱动类</span></span><br><span class="line">			Class.forName(<span class="string">&quot;oracle.jdbc.OracleDriver&quot;</span>);<span class="comment">// 加载具体的驱动类</span></span><br><span class="line">			<span class="comment">// b.与数据库建立连接</span></span><br><span class="line">			connection = DriverManager.getConnection(URL, USERNAME, PWD);</span><br><span class="line">			</span><br><span class="line">			<span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into mymusic values(?,?)&quot;</span>;</span><br><span class="line">			<span class="comment">// c.发送sql，执行(增删改、查)</span></span><br><span class="line">			pstmt = connection.prepareStatement(sql);</span><br><span class="line">			pstmt.setInt(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">			<span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:\\luna.mp3&quot;</span>);</span><br><span class="line">			</span><br><span class="line">			<span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file );</span><br><span class="line">			pstmt.setBinaryStream(<span class="number">2</span>,in ,(<span class="type">int</span>)file.length()  );</span><br><span class="line">			</span><br><span class="line">			</span><br><span class="line">			<span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span>pstmt.executeUpdate() ;</span><br><span class="line">			<span class="comment">// d.处理结果</span></span><br><span class="line">			<span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;  </span><br><span class="line">				System.out.println(<span class="string">&quot;操作成功！&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			in.close();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">finally</span> &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				 <span class="keyword">if</span>(pstmt!=<span class="literal">null</span>) pstmt.close();<span class="comment">// 对象.方法</span></span><br><span class="line">				 <span class="keyword">if</span>(connection!=<span class="literal">null</span>)connection.close();</span><br><span class="line">			&#125;<span class="keyword">catch</span>(SQLException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//读取二进制文件</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">blobReaderDemo</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">		<span class="type">PreparedStatement</span> <span class="variable">pstmt</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">		<span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="literal">null</span> ; </span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// a.导入驱动，加载具体的驱动类</span></span><br><span class="line">			Class.forName(<span class="string">&quot;oracle.jdbc.OracleDriver&quot;</span>);<span class="comment">// 加载具体的驱动类</span></span><br><span class="line">			<span class="comment">// b.与数据库建立连接</span></span><br><span class="line">			connection = DriverManager.getConnection(URL, USERNAME, PWD);</span><br><span class="line">			</span><br><span class="line">			<span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select music from mymusic where id = ? &quot;</span>;</span><br><span class="line">			</span><br><span class="line">			</span><br><span class="line">			<span class="comment">// c.发送sql，执行(查)</span></span><br><span class="line">			pstmt = connection.prepareStatement(sql);</span><br><span class="line">			pstmt.setInt(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">			</span><br><span class="line">			rs = pstmt.executeQuery() ;</span><br><span class="line">			<span class="keyword">if</span>(rs.next())</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> rs.getBinaryStream(<span class="string">&quot;music&quot;</span>) ;</span><br><span class="line">				<span class="type">OutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;src/music.mp3&quot;</span>) ;</span><br><span class="line">				</span><br><span class="line">				<span class="type">byte</span>[] chs = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">100</span>] ;</span><br><span class="line">				<span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">				<span class="keyword">while</span>(  (len = in.read(chs)) !=-<span class="number">1</span> ) &#123;</span><br><span class="line">					out.write( chs,<span class="number">0</span>,len  );</span><br><span class="line">				&#125;</span><br><span class="line">				out.close();</span><br><span class="line">				in.close();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">finally</span> &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				 <span class="keyword">if</span>(pstmt!=<span class="literal">null</span>) pstmt.close();<span class="comment">// 对象.方法</span></span><br><span class="line">				 <span class="keyword">if</span>(connection!=<span class="literal">null</span>)connection.close();</span><br><span class="line">			&#125;<span class="keyword">catch</span>(SQLException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//		blobDemo() ;</span></span><br><span class="line">		blobReaderDemo();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="JSP访问数据库"><a href="#JSP访问数据库" class="headerlink" title="JSP访问数据库"></a>JSP访问数据库</h3><p>JSP就是在html中嵌套的java代码，因此 java代码可以写在jsp中（&lt;%  … %&gt;）。</p>
<p>因此可以利用jsp把账号密码等信息传入，在check.jsp中嵌入java代码进行验证、读取数据库。</p>
<p><strong>导包操作：</strong></p>
<ul>
<li>java项目 ：1 Jar复制到工程中 2.右键该Jar :build path -&gt;add to build Path</li>
<li>Web项目：jar复制到WEB-INF&#x2F;lib</li>
</ul>
<p>核心：就是将 java中的JDBC代码，复制到 JSP中的&lt;% … %&gt;</p>
<p><strong>注意</strong>：如果jsp出现错误：The import Xxx cannot be resolved<br>尝试解决步骤：</p>
<ul>
<li>(可能是Jdk、tomcat版本问题) 右键项目-&gt;build path，将其中 报错的 libary或Lib 删除后 重新导入</li>
<li>清空各种缓存：右键项目-&gt;Clean tomcat… clean  （Project -clean或者 进tomcat目录 删除里面work的子目录）</li>
<li>删除之前的tomcat，重新解压缩、配置tomcat，重启计算机</li>
<li>如果类之前没有包，则将该类加入包中</li>
</ul>
<p><u>DAO（Data Access Object）</u> 模型就是写一个类，把访问数据库的代码封装起来	</p>
<p><u>Entity层</u>，顾名思义就是实体层，放置一个个实体，及其相应的set、get方法。如果想要对数据库进行一些操作（比如说读取）的话，就要先写entity层。</p>
<h3 id="JavaBean"><a href="#JavaBean" class="headerlink" title="JavaBean"></a>JavaBean</h3><p>刚才我们将 jsp中 登录操作的代码  转移到了LoginDao.java；其中LoginDao类 就称之为JavaBean。</p>
<p><strong>JavaBean的作用</strong>：</p>
<ul>
<li>减轻的jsp复杂度  </li>
<li>提高代码复用（以后任何地方的 登录操作，都可以通过调用LoginDao实现）</li>
</ul>
<p>JavaBean（就是一个Java类）的定义：满足一下2点 ，就可以称为JavaBean</p>
<ul>
<li>public 修饰的类  ,public 无参构造</li>
<li>所有属性(如果有) 都是private，并且提供set&#x2F;get   (如果boolean 则get 可以替换成is)</li>
</ul>
<p>使用层面，Java分为2大类：</p>
<ul>
<li>封装业务逻辑的JavaBean (LoginDao.java封装了登录逻辑)			逻辑<br>可以将jsp中的JDBC代码，封装到Login.java类中 （Login.java）</li>
<li>封装数据的JavaBean   （实体类，Student.java  Person.java  ）		数据<br>对应于数据库中的一张表<br>Login login &#x3D; new Login(uname,upwd) ;&#x2F;&#x2F;即用Login对象 封装了2个数据（用户名 和密码）</li>
</ul>
<p>封装数据的JavaBean 对应于数据库中的一张表   (Login(name,pwd))<br>封装业务逻辑的JavaBean 用于操作 一个封装数据的JavaBean  </p>
<p>可以发现，JavaBean可以简化 代码(jsp-&gt;jsp+java)、提供代码复用(LoginDao.java)</p>
<h1 id="MVC设计模式"><a href="#MVC设计模式" class="headerlink" title="MVC设计模式"></a>MVC设计模式</h1><ul>
<li>M：Model	，模型  ：一个功能。用JavaBean实现。</li>
<li>V:View，视图： 用于展示、以及与用户交互。使用html  js  css jsp jquery等前端技术实现</li>
<li>C:Controller，分发器&#x2F;控制器 ：接受请求，将请求跳转到模型进行处理；模型处理完毕后，再将处理的结果<br>返回给 请求处 。 可以用jsp实现，  但是一般建议使用 Servlet实现控制器。</li>
<li>Jsp-&gt;Java(Servlet)-&gt;JSP</li>
</ul>
<img src="image-20241018105735102.png" class title="image-20241018105735102">

<h3 id="Servlet基础："><a href="#Servlet基础：" class="headerlink" title="Servlet基础："></a>Servlet基础：</h3><p>Java类必须符合一定的 规范：<br>    a.必须继承  javax.servlet.http.HttpServlet<br>    b.重写其中的 doGet()或doPost()方法</p>
<p> doGet()： 接受 并处理 所有get提交方式的请求<br> doPost()：接受 并处理 所有post提交方式的请求</p>
<p>Servlet要想使用，必须配置<br>Serlvet2.5：web.xml<br>Servle3.0： @WebServlet</p>
<p>Serlvet2.5：web.xml:</p>
<h5 id="项目的根目录：WebContent-、src"><a href="#项目的根目录：WebContent-、src" class="headerlink" title="项目的根目录：WebContent 、src"></a>项目的根目录：WebContent 、src</h5><p><a href="WelcomeServlet">所在的jsp是在 WebContent目录中，因此 发出的请求WelcomeServlet  是去请求项目的根目录。</a></p>
<p>Servlet流程：<br>请求 -&gt;<url-pattern> -&gt; 根据<servlet-mapping>中的<servlet-name> 去匹配  <servlet> 中的<servlet-name>，然后寻找到<servlet-class>，求中将请求交由该<servlet-class>执行。</servlet-class></servlet-class></servlet-name></servlet></servlet-name></servlet-mapping></url-pattern></p>
<img src="image-20241018142854470.png" class title="image-20241018142854470">

<h3 id="Servlet生命周期：5个阶段"><a href="#Servlet生命周期：5个阶段" class="headerlink" title="Servlet生命周期：5个阶段"></a>Servlet生命周期：5个阶段</h3><p>加载<br>初始化： init()  ，该方法会在 Servlet被加载并实例化的以后 执行<br>服务  ：service() -&gt;doGet()  doPost<br>销毁  ：destroy()，  Servlet被系统回收时执行<br>卸载</p>
<p>init():<br>    a.默认第一次访问 Servlet时会被执行 （只执行这一次）<br>    b.可以修改为 Tomcat启动时自动执行<br>        i.Servlet2.5：  web.xml<br>              <servlet><br>                …<br>                   <load-on-startup>1</load-on-startup><br>                </servlet><br>            其中的“1”代表第一个。<br>        ii.Servlet3.0<br>            @WebServlet( value&#x3D;”&#x2F;WelcomeServlet” ,loadOnStartup&#x3D;1  )</p>
<p>service() -&gt;doGet()  doPost ：调用几次，则执行几次<br>destroy()：关闭tomcat服务时，执行一次。</p>
<h1 id="MVC案例实践"><a href="#MVC案例实践" class="headerlink" title="MVC案例实践"></a>MVC案例实践</h1><img src="image-20241023114525718.png" class title="image-20241023114525718">

<p>login.jsp:</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;!-- login.jsp --&gt;</span><br><span class="line">&lt;%@ page language=<span class="string">&quot;java&quot;</span> contentType=<span class="string">&quot;text/html; charset=UTF-8&quot;</span></span><br><span class="line">    pageEncoding=<span class="string">&quot;UTF-8&quot;</span>%&gt;</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">&lt;title&gt;Insert title here&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">	</span><br><span class="line">	&lt;form action=<span class="string">&quot;loginservlet&quot;</span> method=<span class="string">&quot;post&quot;</span>&gt;</span><br><span class="line">		用户名：&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;uname&quot;</span>/&gt;&lt;br/&gt;</span><br><span class="line">		密码：&lt;input type=<span class="string">&quot;password&quot;</span> name=<span class="string">&quot;upwd&quot;</span>/&gt;&lt;br/&gt;</span><br><span class="line">		&lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;登录&quot;</span>&gt;</span><br><span class="line">	&lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>loginservlet.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.sza;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.sza.dao.logindao;</span><br><span class="line"><span class="keyword">import</span> org.sza.entity.loginbean;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet(&quot;/loginservlet&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">loginservlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">		request.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">		<span class="type">String</span> <span class="variable">uname</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;uname&quot;</span>);</span><br><span class="line">		<span class="type">String</span> <span class="variable">upwd</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;upwd&quot;</span>);</span><br><span class="line">		<span class="type">loginbean</span> <span class="variable">loginuser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">loginbean</span>(uname,upwd);</span><br><span class="line">		<span class="type">int</span> <span class="variable">flag</span> <span class="operator">=</span> logindao.logincheck(loginuser);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (flag == <span class="number">0</span>) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;登录失败&quot;</span>);</span><br><span class="line">			response.sendRedirect(<span class="string">&quot;login.jsp&quot;</span>);</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(flag &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;登录成功&quot;</span>);</span><br><span class="line">			response.sendRedirect(<span class="string">&quot;welcome.jsp&quot;</span>);</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;系统错误&quot;</span>);</span><br><span class="line">			response.sendRedirect(<span class="string">&quot;login.jsp&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line"></span><br><span class="line">		doGet(request, response);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>logindao.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.sza.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"><span class="keyword">import</span> java.sql.PreparedStatement;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.sza.entity.loginbean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">logindao</span> &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">URL</span> <span class="operator">=</span> <span class="string">&quot;jdbc:oracle:thin:@localhost:1521:orcl&quot;</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">USERNAME</span> <span class="operator">=</span> <span class="string">&quot;sza&quot;</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PWD</span> <span class="operator">=</span> <span class="string">&quot;sza0415&quot;</span>;</span><br><span class="line">	<span class="comment">// 对输入的登录账号进行验证</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">logincheck</span><span class="params">(loginbean loginuser)</span> &#123;</span><br><span class="line">		<span class="type">PreparedStatement</span> <span class="variable">ppsmt</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">		<span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">		<span class="type">ResultSet</span> <span class="variable">resultset</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">		<span class="type">int</span> <span class="variable">flag</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Class.forName(<span class="string">&quot;oracle.jdbc.OracleDriver&quot;</span>);</span><br><span class="line">			conn = DriverManager.getConnection(URL,USERNAME,PWD);</span><br><span class="line">			</span><br><span class="line">			<span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select count(*) from USERS where username = ? and PASSWORD = ?&quot;</span>;</span><br><span class="line">			ppsmt = conn.prepareStatement(sql);</span><br><span class="line">			ppsmt.setString(<span class="number">1</span>, loginuser.getUname());</span><br><span class="line">			ppsmt.setString(<span class="number">2</span>, loginuser.getUpwd());</span><br><span class="line">			</span><br><span class="line">			resultset = ppsmt.executeQuery();</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span> (resultset.next()) &#123;</span><br><span class="line">				flag = resultset.getInt(<span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (flag &gt; <span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			</span><br><span class="line">		&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">			<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">		&#125;<span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">			<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">		&#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">			<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">		&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> (resultset!=<span class="literal">null</span>)resultset.close();</span><br><span class="line">				<span class="keyword">if</span> (ppsmt!=<span class="literal">null</span>)ppsmt.close();</span><br><span class="line">				<span class="keyword">if</span> (conn!=<span class="literal">null</span>)conn.close();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (SQLException e2) &#123;</span><br><span class="line">				e2.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>loginbean.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.sza.entity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">loginbean</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> String uname;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> String upwd;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getUname</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> uname;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">loginbean</span><span class="params">(String uname, String upwd)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.uname = uname;</span><br><span class="line">		<span class="built_in">this</span>.upwd = upwd;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">loginbean</span><span class="params">()</span> &#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUname</span><span class="params">(String uname)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.uname = uname;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getUpwd</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> upwd;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUpwd</span><span class="params">(String upwd)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.upwd = upwd;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="三层架构详解"><a href="#三层架构详解" class="headerlink" title="三层架构详解"></a>三层架构详解</h1><img src="image-20241023154525327.png" class title="image-20241023154525327">

<img src="image-20241023155308068.png" class title="image-20241023155308068">

<p>三层组成:</p>
<ul>
<li>表示层（USL，User Show Layer 视图层）<ul>
<li>前台:对应着MVC中的View，用于和用户交互、界面的显示<ul>
<li>前台技术：jsp html css js jquery等web前端技术</li>
<li>代码位置：webcontent</li>
</ul>
</li>
<li>后台：对应于MVC中的Controller，用于跳转 调用业务逻辑层<ul>
<li>后台技术：servlet（springMVC），一般位于xxx.servlet包中</li>
</ul>
</li>
</ul>
</li>
<li>业务逻辑层（BLL，Business Logic Layer；Service层 ）<ul>
<li>接受表示层的请求 调用</li>
<li>组装数据访问层，逻辑性的操作，可能是数据访问层的操作的组合<ul>
<li>一般位于xxx.service包中 也可以称为xxx.manager &#x2F;xxx.bll</li>
</ul>
</li>
</ul>
</li>
<li>数据访问层（DAL，Data Access Layer；Dao层）<ul>
<li>直接访问数据库的操作，原子性的操作（增删改查） 不可拆解<ul>
<li>一般位于xxx.dao包</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>三层案例: TODO</p>
<p>优化三层：</p>
<ol>
<li>加入接口<ol>
<li>建议面向接口开发：先接口-再实现类</li>
<li>service、dao加入接口</li>
<li>接口与实现类的命名规范<ol>
<li>接口：interface  起名 IXxxService、IXxxDao<ol>
<li>接口所在的包 xxx.service xx.dao</li>
</ol>
</li>
<li>实现类：implements 起名 XxxServiceImpl <ol>
<li>实现类所在的包：xxx.dao.impl  xxx.service.impl</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>DBUtil 通用的数据库帮助类，可以简化Dao类的代码量</li>
</ol>
<h1 id="Servlet中的监听器"><a href="#Servlet中的监听器" class="headerlink" title="Servlet中的监听器"></a>Servlet中的监听器</h1><p>监听原理：</p>
<ul>
<li>存在事件源：被监听的对象</li>
<li>提供监听器：监听的对象</li>
<li>为事件源注册监听器，事件源与监听器的绑定</li>
<li>操作事件源，产生事件对象，将事件对象传递给监听器，并且执行监听器相应的监听方法。事件：事件源对象的改变–&gt;通过事件获得事件源对象</li>
</ul>
<p>Servlet中主要用于监听的事件源分别是ServletContext、HttpSession、ServletRequest三个域对象–&gt; application、session、request。</p>
<img src="c1e324384d6ebcfcc2dca5da71b548c2.png" class title="img">

<p>Servlet监听器分为三大类：</p>
<ol>
<li>监听数据<font color="blue"><strong>域对象创建与销毁的</strong></font>监听器</li>
<li>监听数据<font color="blue"><strong>域对象的属性变更</strong></font>（属性添加、移除、替换）的监听器</li>
<li>监听<font color="blue"><strong>绑定到 HttpSession 域中的某个对象的状态</strong></font>的事件监听器</li>
</ol>
<h2 id="1-监听数据域对象创建与销毁的监听器"><a href="#1-监听数据域对象创建与销毁的监听器" class="headerlink" title="1. 监听数据域对象创建与销毁的监听器"></a>1. 监听数据<font color="blue"><strong>域对象创建与销毁的</strong></font>监听器</h2><p><strong>ServletContextListener : 用来监听ServletContext对象的创建和销毁</strong></p>
<ol>
<li>监听创建 监听销毁<br>ServletContext对象代表全局唯一对象，每个web工程会产生一个ServletContext,服务器启动创建，服务器关闭销毁</li>
</ol>
<p>编写监听器<br>步骤一：编写类实现特定监听器接口<br>步骤二：注册监听器，不是通过事件源，而是在web.xml 进行配置<br>（<strong>监听器和Servlet、Filter不同，不需要url配置，监听器执行不是由用户访问的，监听器 是由事件源自动调用的</strong>）</p>
<p><strong>servletContext域对象何时创建和销毁</strong>：</p>
<ul>
<li>创建：服务器启动针对每一个web应用创建servletcontext</li>
<li>销毁：服务器关闭前先关闭代表每一个web应用的servletContext</li>
</ul>
<p><strong>ServletContextListener主流应用：</strong><br><strong>第一个</strong>：在服务器启动时，对一些对象进行初始化，并且将对象保存ServletContext数据范围内(因为在监听器内可以获得事件源对象) — 全局数据</p>
<ul>
<li>例如：创建数据库连接池</li>
</ul>
<p><strong>第二个</strong>：对框架进行初始化 例如：Spring框架初始化通过ServletContextListener (因为监听器代码在服务器启动时执行)</p>
<ul>
<li>Spring框架(配置文件随服务器启动加载) org.springframework.web.context.ContextLoaderListener</li>
</ul>
<p><strong>第三个</strong>：实现任务调度，启动定时程序 （Timer、TimerTask） 使一个程序，定时执行</p>
<p><strong>比如说每天晚上十二点给过生日的人进行生日祝福，中国移动对账户进行同步，会在服务器使用较少的时间，例如凌晨之类，启动一段程序，进行同步</strong></p>
<p>java.util.Timer 一种线程设施，用于安排以后在后台线程中执行的任务。可安排任务执行一次，或者定期重复执行。<br>Timer提供了启动定时任务方法 schedule<br>* schedule(TimerTask task, Date firstTime, long period) 用来在指定一个时间启动定时器，定期循环执行<br>* schedule(TimerTask task, long delay, long period) 用来在当前时间delay多少毫秒后启动定时器<br>停止定时器，timer.cancel取消任务</p>
<p><strong>HttpSession 数据对象创建和销毁监听器 —– HttpSessionListener</strong></p>
<ol start="2">
<li>监听Session对象创建 监听Session对象销毁</li>
</ol>
<p>​		<strong>Session何时创建</strong>：request.getSession()<br>​		<strong>Session何时销毁</strong>：关闭服务器，Session过期，session.invalidate<br>​		Session过期时间通过web.xml配置（tomcat配置文件中），默认时间30分钟</p>
<p><strong>HttpServletRequest对象的创建和销毁监听器 —- ServletRequestListener</strong></p>
<ol start="3">
<li>监听request对象创建 监听request对象销毁</li>
</ol>
<p>​		<strong>Request何时创建</strong>：请求发起时创建<br>​		<strong>Request何时销毁</strong>：响应结束时销毁</p>
<p>​		例如：每次刷新界面都会创建销毁一次</p>
<p>​	<strong>注意（创建销毁次数由请求次数决定）：</strong><br>​	<strong>使用forward</strong> —- request创建销毁几次 —– 一次<br>​	<strong>使用sendRedirect</strong> —- request创建销毁两次 （两次请求）</p>
<p>Demo：写一个三合一的Listener</p>
<img src="image-20241029154819503.png" class title="image-20241029154819503">

<p>步骤一：编写类实现特定监听器接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*Context_Session_RequestListener.java</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> org.sza.listener;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletContextEvent;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletContextListener;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletRequestEvent;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletRequestListener;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpSessionEvent;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpSessionListener;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Context_Session_RequestListener</span> <span class="keyword">implements</span> <span class="title class_">ServletContextListener</span>, HttpSessionListener, ServletRequestListener&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">requestDestroyed</span><span class="params">(ServletRequestEvent sre)</span> &#123;</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">&quot;requestDestroyed&quot;</span> + sre.getServletRequest());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">requestInitialized</span><span class="params">(ServletRequestEvent sre)</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;requestInitialized&quot;</span> + sre.getServletRequest());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sessionCreated</span><span class="params">(HttpSessionEvent se)</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;sessionCreated&quot;</span> + se.getSession());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sessionDestroyed</span><span class="params">(HttpSessionEvent se)</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;sessionDestroyed&quot;</span> + se.getSession());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contextDestroyed</span><span class="params">(ServletContextEvent sce)</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;contextDestroyed&quot;</span> + sce.getServletContext());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contextInitialized</span><span class="params">(ServletContextEvent sce)</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;contextInitialized&quot;</span> + sce.getServletContext());</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>步骤二：注册监听器，不是通过事件源，而是在web.xml 进行配置 （<strong>监听器和Servlet、Filter不同，不需要url配置，监听器执行不是由用户访问的，监听器 是由事件源变化自动调用的</strong>）</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.sza.listener.Context_Session_RequestListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>开启服务器：</p>
<img src="image-20241029173439983.png" class title="image-20241029173439983">

<p>第一次访问一个JSP页面（http://localhost:8888/UPload_Download&#x2F;index.jsp）：</p>
<img src="image-20241029173742007.png" class title="image-20241029173742007">

<p>第二次访问同一个JSP页面（http://localhost:8888/UPload_Download&#x2F;index.jsp）：</p>
<img src="image-20241029173946905.png" class title="image-20241029173946905">

<p>访问一个servlet（http://localhost:8888/UPload_Download&#x2F;uploadservlet）：</p>
<img src="image-20241029173702033.png" class title="image-20241029173702033">

<p>具体原因可以看<a href="##JSP%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86">JSP运行原理</a></p>
<p><strong>Session何时销毁</strong>：关闭服务器，Session过期，session.invalidate 不做演示</p>
<p>关闭服务器：</p>
<h2 id="监听数据域对象的属性变更（属性添加、移除、替换）的监听器"><a href="#监听数据域对象的属性变更（属性添加、移除、替换）的监听器" class="headerlink" title="监听数据域对象的属性变更（属性添加、移除、替换）的监听器"></a>监听数据<font color="blue"><strong>域对象的属性变更</strong></font>（属性添加、移除、替换）的监听器</h2><p>Servlet 规范定义了监听 ServletContext、HttpSession、HttpServletRequest 这三个对象中的属性变更事件的监听器，这三个监听器接口分别是 ServletContextAttributeListener、HttpSessionAttributeListener 和 ServletRequestAttributeListener。这三个接口中都定义了三个方法，用来处理被监听对象中属性的增加，删除和替换事件。同一种事件在这三个接口中对应的方法名称完全相同，只是参数类型不同</p>
<img src="z6nil6zbsjc2u_b2df6856c3ab46c483fe3786d37f95bf.png" class title="img">





<h3 id="监听绑定到-HttpSession-域中的某个对象的状态的事件监听器"><a href="#监听绑定到-HttpSession-域中的某个对象的状态的事件监听器" class="headerlink" title="监听绑定到 HttpSession 域中的某个对象的状态的事件监听器"></a>监听<font color="blue"><strong>绑定到 HttpSession 域中的某个对象的状态</strong></font>的事件监听器</h3><p>Session 中的对象可以有多种状态：<strong>绑定到 Session 中、从 Session 中解除绑定、随 Session 对象持久化到存储设备中(钝化)、随 Session 对象从存储设备中恢复（活化）</strong>。Servlet 规范中定义了两个特殊的监听器接口，用来帮助对象了解自己在 Session 中的状态：HttpSessionBindingListener 接口和 HttpSessionActivationListener 接口 ，<font color="red"><strong>实现这两个接口的类不需要进行注册</strong></font>。</p>
<p>HttpSessionBindingListener Demo:</p>
<p>在该监听器中实现HttpSessionBindingListener接口的两个抽象方法：</p>
<p>1、valueBound()：向HttpSession对象中添加该类对象数据时自动执行该方法<br>2、valueUnbound()：从HttpSession对象中删除该类对象数据时会自动执行该方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.sza.entity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpSessionBindingEvent;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpSessionBindingListener;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">HttpSessionBindingListener</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">    	</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">valueBound</span><span class="params">(HttpSessionBindingEvent arg0)</span>  &#123; </span><br><span class="line">         System.out.println(<span class="string">&quot;Student类对象&quot;</span> + <span class="string">&quot;被添加到了session&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">valueUnbound</span><span class="params">(HttpSessionBindingEvent arg0)</span>  &#123; </span><br><span class="line">    	System.out.println(<span class="string">&quot;Student类对象&quot;</span> + <span class="string">&quot;被从session中删除了&quot;</span>);</span><br><span class="line">    &#125;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>写一个servlet执行一下session.setAttribute和session.removeAttribute</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.sza.servlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.sza.entity.Student;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet(&quot;/httpsessionbindingdemo&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HttpSessionBindingDemo</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line">       </span><br><span class="line">  </span><br><span class="line">	<span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">		<span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">		request.getSession().setAttribute(<span class="string">&quot;student1&quot;</span>, student);</span><br><span class="line">		request.getSession().removeAttribute(<span class="string">&quot;student1&quot;</span>);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line"></span><br><span class="line">		doGet(request, response);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>执行<a href="http://localhost:8888/UPload_Download/httpsessionbindingdemo">http://localhost:8888/UPload_Download/httpsessionbindingdemo</a></p>
<img src="image-20241029180049625.png" class title="image-20241029180049625">



<p>HttpSessionActivationListener：<br>保存在Session域中的对象有两种存储状态：文件“SESSION.ser”中或内存中<br>HttpSessionActivationListener接口用于监听实现该接口和Serializable接口的Java类的对象随session钝化和活化事件，可以通过实现HttpSessionActivationListener接口的两个抽象方法来感知存储在HttpSession对象中的该类对象数据从内存保存到“SESSION.ser”文件中和从“SESSION.ser”文件中读取到内存中的时机<br>创建HttpSessionActivationListener监听器：</p>
<p>1、创建一个普通Java类，实现HttpSessionActivationListener接口<br>2、(eclipse)直接创建一个Listener，选择实现HttpSessionActivationListener接口<br>在该监听器中实现HttpSessionActivationListener接口的两个抽象方法：</p>
<p>1、sessionDidActivate()：当绑定到HttpSession对象中的对象将要随HttpSession对象被活化（从硬盘中“SESSION.ser”文件内读到内存中）之后，自动执行该方法<br>2、sessionWillPassivate()：当绑定到HttpSession对象中的对象将要随HttpSession对象被钝化（向硬盘中“SESSION.ser”文件内写入HttpSession对象）之前，自动执行该方法</p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>后端开发</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring</title>
    <url>/Spring/</url>
    <content><![CDATA[<blockquote>
<p>参考 黑马程序员的SSM课程<a href="https://www.bilibili.com/video/BV1Fi4y1S7ix/?vd_source=65c9204c97b8b1867c1d577ee29c3fc1">https://www.bilibili.com/video/BV1Fi4y1S7ix/?vd_source=65c9204c97b8b1867c1d577ee29c3fc1</a> 此课程偏实践 基本不涉及原理 仅适合快速入门上手</p>
<p>博客笔记：<a href="https://cyborg2077.github.io/2022/08/29/Spring/">https://cyborg2077.github.io/2022/08/29/Spring/</a></p>
<p>廖雪峰 spring开发教程 <a href="https://liaoxuefeng.com/books/java/spring/index.html">https://liaoxuefeng.com/books/java/spring/index.html</a></p>
</blockquote>
<h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><h2 id="Spring-Framework系统框架"><a href="#Spring-Framework系统框架" class="headerlink" title="Spring Framework系统框架"></a>Spring Framework系统框架</h2><img src="image-20241105170720691.png" class title="image-20241105170720691">

<h2 id="IoC（Inversion-of-Control）控制反转"><a href="#IoC（Inversion-of-Control）控制反转" class="headerlink" title="IoC（Inversion of Control）控制反转"></a>IoC（Inversion of Control）控制反转</h2><blockquote>
<p>IoC（控制反转） 定义： IoC是一种设计原则，其核心思想是将对象的创建和管理的控制权从程序代码转移到外部容器，这个外部容器通常是一个框架。这样做的目的是为了降低程序代码之间的耦合度，提高代码的模块化和可维护性。</p>
<p>工作原理： 在传统的程序设计中，我们创建和管理对象的生命周期通常是通过直接在代码中进行new操作和调用方法来实现的。而在IoC模式下，对象的创建和管理工作由IoC容器负责，程序员只需要通过配置来告诉容器需要哪些对象，以及它们之间的依赖关系是什么。</p>
<p>优点： 降低耦合度：因为对象的创建和生命周期管理都是由容器负责，所以组件之间不需要相互了解，减少了耦合。 增强模块化：IoC允许将应用程序划分为独立的组件，这些组件可以在不同的环境中重用。 易于测试：由于组件的依赖关系可以通过配置来定义，所以在单元测试时可以更容易地替换这些依赖。 AOP（面向切面编程） 定义： AOP是一种编程范式，它允许开发者通过分离横切关注点来增加模块化。横切关注点是指那些跨越多个模块的方法或功能，如日志、事务管理和安全性等。</p>
</blockquote>
<p>背景引入：</p>
<img src="image-20241105165152863.png" class title="image-20241105165152863">

<p><font color="green">代码耦合度偏高：</font>原先在业务逻辑层的实现类（BookServiceImpl）中会new一个数据访问层的实现类（BookDaoImpl），当出现一个数据访问层迎来了一个全新的实现（BookDaoImpl2），业务逻辑层的相关代码就需要改变。</p>
<p>解决方案：使用对象时，在程序中不要主动使用new产生对象，转换为<font color="green">外部提供对象</font>，这就是IoC（Inversion of Control）控制反转 &#x3D;&gt; <u>对象的创建控制权由程序转移到<font color="green">外部</font></u></p>
<p>Spring技术对IoC思想进行了实现：</p>
<ul>
<li>Spring提供了一个容器，称为<font color="green">IoC容器<br></font>，用来充当IoC思想中的<font color="green">“外部”</font></li>
<li>IoC容器负责对象的创建、初始化等一系列的工作，被创建或管理的对象在IoC容器中统称为<font color="green">Bean</font></li>
</ul>
<p>业务逻辑层（service）的对象与数据访问层（dao）的对象都可以放入IoC容器当中</p>
<p>service层的对象的运行依赖于dao层对象</p>
<img src="image-20241105171824851.png" class title="image-20241105171824851">

<p>使用<font color="green">DI（Dependency Injection）依赖注入</font>进行解决：</p>
<ul>
<li>依赖注入，在容器中建立bean于bean之间的依赖关系的整个过程。</li>
</ul>
<p>步骤：</p>
<ol>
<li>使用IoC容器管理bean</li>
<li>在IoC容器中将有依赖关系的bean进行关系绑定（DI）</li>
</ol>
<p>最终效果：</p>
<p>使用对象时不仅可以直接从IoC容器中获取，并且获取到的bean已经绑定了所有的依赖关系</p>
<h2 id="IoC入门案例"><a href="#IoC入门案例" class="headerlink" title="IoC入门案例"></a>IoC入门案例</h2><h4 id="入门案例思路分析"><a href="#入门案例思路分析" class="headerlink" title="入门案例思路分析"></a>入门案例思路分析</h4><ol>
<li>Spring是使用容器来管理bean对象的，那么管什么?<ul>
<li>主要管理项目中所使用到的类对象，比如(Service和Dao)</li>
</ul>
</li>
<li>如何将被管理的对象告知IOC容器?<ul>
<li>使用配置文件</li>
</ul>
</li>
<li>被管理的对象交给IOC容器，要想从容器中获取对象，就先得思考如何获取到IOC容器?<ul>
<li>Spring框架提供相应的接口</li>
</ul>
</li>
<li>IOC容器得到后，如何从容器中获取bean?<ul>
<li>调用Spring框架提供对应接口中的方法</li>
</ul>
</li>
<li>使用Spring导入哪些坐标?<ul>
<li>用别人的东西，就需要在pom.xml添加对应的依赖</li>
</ul>
</li>
</ol>
<h4 id="入门案例代码实现"><a href="#入门案例代码实现" class="headerlink" title="入门案例代码实现"></a>入门案例代码实现</h4><p>整个工程文件的结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">├── pom.xml</span><br><span class="line">└── src</span><br><span class="line">    └── main</span><br><span class="line">        ├── java</span><br><span class="line">        │   └── com</span><br><span class="line">        │       └── itheima</span><br><span class="line">        │           ├── App.java</span><br><span class="line">        │           ├── App2.java</span><br><span class="line">        │           ├── dao</span><br><span class="line">        │           │   ├── BookDao.java</span><br><span class="line">        │           │   └── impl</span><br><span class="line">        │           │       └── BookDaoImpl.java</span><br><span class="line">        │           └── service</span><br><span class="line">        │               ├── BookService.java</span><br><span class="line">        │               └── impl</span><br><span class="line">        │                   └── BookServiceImpl.java</span><br><span class="line">        └── resources</span><br><span class="line">            └── applicationContext.xml</span><br></pre></td></tr></table></figure>

<p>需求分析:将BookServiceImpl和BookDaoImpl交给Spring管理，并从容器中获取对应的bean对象进行方法调用。</p>
<ol>
<li><p>创建Maven的java项目</p>
</li>
<li><p>pom.xml添加Spring的依赖jar包</p>
</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.1.14<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>创建BookDao，BookDaoImpl，BookService和BookServiceImpl四个类</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">BookDao</span> <span class="variable">bookDao</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BookDaoImpl</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book service save ...&quot;</span>);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>resources下添加spring配置文件，<code>application.xml</code>配置文件，告诉Spring的IoC容器应该如何创建并组装Bean：</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- applicationContext.xml spring配置文件 =&gt; 将所要管理的类添加至配置文件当中   --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- bean标签配置bean   --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- id属性在同一个上下文中(配置文件)不能重复 标识bean    --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- class属性给bean定义类型 得是具体的实现类 IoC通过调用该类创造对象 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.example.dao.impl.BookDaoImpl&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.example.service.impl.BookServiceImpl&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="5">
<li>获取IOC容器，从容器中获取对象进行方法调用</li>
</ol>
<p>我们需要创建一个Spring的IoC容器实例，然后加载配置文件，让Spring容器为我们创建并装配好配置文件中指定的所有Bean，这只需要一行代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>接下来，我们就可以从Spring容器中“取出”装配好的Bean然后使用它：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//        使用getBean(String name)方法，其name参数就是我们在bean配置的id，通过这个id来创造对象</span></span><br><span class="line">        <span class="type">bookService</span> <span class="variable">bookService</span> <span class="operator">=</span> (bookService)context.getBean(<span class="string">&quot;bookService&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>完整代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.java 调用service方法</span></span><br><span class="line"><span class="keyword">package</span> org.sza;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.sza.dao.bookDao;</span><br><span class="line"><span class="keyword">import</span> org.sza.service.bookService;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//        使用Spring ClassPathXmlApplicationContext 完成IOC容器的创建</span></span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line"><span class="comment">//        使用getBean(String name)方法，其name参数就是我们在bean配置的id，通过这个id来创造对象</span></span><br><span class="line">        <span class="type">bookService</span> <span class="variable">bookService</span> <span class="operator">=</span> (bookService)context.getBean(<span class="string">&quot;bookService&quot;</span>);</span><br><span class="line">        bookService.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bookServiceImpl.java 调用 Dao层方法</span></span><br><span class="line"><span class="keyword">package</span> org.sza.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.sza.dao.bookDao;</span><br><span class="line"><span class="keyword">import</span> org.sza.service.bookService;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">bookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">bookService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> bookDao bookDao;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;save book service&quot;</span>);</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        bookDao = (bookDao) context.getBean(<span class="string">&quot;bookDao&quot;</span>);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，Spring的IOC入门案例已经完成，但是在<code>BookServiceImpl</code>的类中依然存在<code>BookDaoImpl</code>对象的new操作（如如果你不使用IoC容器调用的话），它们之间的耦合度还是比较高，这块该如何解决，就需要用到下面的<code>DI(依赖注入)</code>来解决bean与bean之间的依赖关系。</p>
<h2 id="DI入门案例"><a href="#DI入门案例" class="headerlink" title="DI入门案例"></a>DI入门案例</h2><h4 id="入门案例思路分析-1"><a href="#入门案例思路分析-1" class="headerlink" title="入门案例思路分析"></a>入门案例思路分析</h4><ol>
<li>要想实现依赖注入，必须要基于IOC管理Bean<ul>
<li>DI的入门案例要依赖于前面的IOC入门案例</li>
</ul>
</li>
<li>Service中使用new形式创建的Dao对象是否保留？<ul>
<li>不保留，这样才能解耦合，最终要使用IOC容器中的bean对象</li>
</ul>
</li>
<li>Service中需要的Dao对象如何进入到Service中？<ul>
<li>在Service中提供一个方法（例如提供一个set方法），让Spring的IOC容器可以通过该方法传入bean对象，也就达到了不是自己new，而是外部提供</li>
</ul>
</li>
<li>Service与Dao之间的关系如何描述？<ul>
<li>使用配置文件</li>
</ul>
</li>
</ol>
<h4 id="入门案例代码实现-1"><a href="#入门案例代码实现-1" class="headerlink" title="入门案例代码实现"></a>入门案例代码实现</h4><p>需求：基于IOC入门案例，在BookServiceImpl类中删除new对象的方式，使用Spring的DI完成Dao层的注入</p>
<ol>
<li>删除业务层中使用new的方式创建的dao对象，在业务层提供BookDao的setter方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.sza.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.sza.dao.BookDao;</span><br><span class="line"><span class="keyword">import</span> org.sza.service.BookService;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;save book service&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBookDao</span><span class="params">(BookDao bookDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bookDao = bookDao;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在配置文件中添加依赖注入的配置</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.sza.dao.impl.BookDaoImpl&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.sza.service.impl.BookServiceImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 配置Service与Dao之间的关系 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bookDao&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>把上述XML配置文件用Java代码写出来，就像这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">BookServiceImpl</span> <span class="variable">bookServiceImpl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BookServiceImpl</span>();</span><br><span class="line"><span class="type">BookDaoImpl</span> <span class="variable">bookDaoImpl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BookDaoImpl</span>();</span><br><span class="line">bookServiceImpl.setBookDao(bookDaoImpl);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>只不过Spring容器是通过读取XML文件后使用反射完成的</p>
</blockquote>
<p>如果注入的不是Bean，而是<code>boolean</code>、<code>int</code>、<code>String</code>这样的数据类型，则通过<code>value</code>注入，例如，创建一个<code>HikariDataSource</code>：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.zaxxer.hikari.HikariDataSource&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbcUrl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;password&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maximumPoolSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;autoCommit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<img src="image-20241106113808631.png" class title="image-20241106113808631">

<img src="image-20241111094123811.png" class title="image-20241111094123811">

<ul>
<li>注意:配置中的两个bookDao的含义是不一样的，一个提供方法 一个提供对象<ul>
<li>name&#x3D;”bookDao”中<code>bookDao</code>的作用是让Spring的IOC容器在获取到名称后，将首字母大写，前面加set找对应的<code>setBookDao()</code>方法进行对象注入</li>
<li>ref&#x3D;”bookDao”中<code>bookDao</code>的作用是让Spring能在IOC容器中找到id为<code>bookDao</code>的Bean对象给<code>bookService</code>进行注入</li>
</ul>
</li>
</ul>
<img src="image-20241116154455412.png" class title="image-20241116154455412">



<h2 id="IOC相关内容"><a href="#IOC相关内容" class="headerlink" title="IOC相关内容"></a>IOC相关内容</h2><h3 id="bean基础配置"><a href="#bean基础配置" class="headerlink" title="bean基础配置"></a>bean基础配置</h3><ul>
<li>bean的基础配置 id class</li>
</ul>
<img src="image-20241116153023859.png" class title="image-20241116153023859">

<p>也可以在bean标签中配置name属性，来充当别名：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.blog.dao.impl.BookDaoImpl&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--name:为bean指定别名，别名可以有多个，使用逗号，分号，空格进行分隔--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookService&quot;</span> <span class="attr">name</span>=<span class="string">&quot;service1 service2 service3&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.blog.service.impl.BookServiceImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bookDao&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意事项：bean依赖注入的ref属性指定bean，必须在容器中存在，而ref的值也可以是name里的别名，不过还是建议用id值来注入。</p>
<h3 id="bean作用范围scope配置"><a href="#bean作用范围scope配置" class="headerlink" title="bean作用范围scope配置"></a>bean作用范围scope配置</h3><p>bean的scope有两个取值：</p>
<ul>
<li>singleton：单例（默认）</li>
<li>prototype：非单例</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="comment">//我这里使用了别名，其实还是同一个bean</span></span><br><span class="line">        <span class="type">BookService</span> <span class="variable">bookService2</span> <span class="operator">=</span> (BookService) context.getBean(<span class="string">&quot;service2&quot;</span>);</span><br><span class="line">        <span class="type">BookService</span> <span class="variable">bookService3</span> <span class="operator">=</span> (BookService) context.getBean(<span class="string">&quot;service3&quot;</span>);</span><br><span class="line">        System.out.println(bookService2);</span><br><span class="line">        System.out.println(bookService3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果如下，地址值一致，确实是单例的</p>
<blockquote>
<p>com.blog.service.impl.BookServiceImpl@25bbe1b6<br>com.blog.service.impl.BookServiceImpl@25bbe1b6</p>
</blockquote>
<p>在Spring配置文件中，配置scope属性来实现bean的非单例创建</p>
<ul>
<li><p>在Spring的配置文件中，修改<bean>的scope属性</bean></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;bean id=&quot;bookService&quot; name=&quot;service1 service2 service3&quot; class=&quot;com.blog.service.impl.BookServiceImpl&quot; scope=&quot;prototype&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;bookDao&quot; ref=&quot;bookDao&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>为什么bean默认为单例?</p>
<ul>
<li>bean为单例的意思是在Spring的IOC容器中只会有该类的一个对象</li>
<li>bean对象只有一个就避免了对象的频繁创建与销毁，达到了bean对象的复用，性能高</li>
</ul>
</li>
<li><p>bean在容器中是单例的，会不会产生线程安全问题?</p>
<ul>
<li>如果对象是有状态对象，即该对象有成员变量可以用来存储数据的，</li>
<li>因为所有请求线程共用一个bean对象，所以会存在线程安全问题。</li>
<li>如果对象是无状态对象，即该对象没有成员变量没有进行数据存储的，</li>
<li>因方法中的局部变量在方法调用完成后会被销毁，所以不会存在线程安全问题。</li>
</ul>
</li>
<li><p>哪些bean对象适合交给容器进行管理?</p>
<ul>
<li>表现层对象（controller）</li>
<li>业务层对象（service）</li>
<li>数据层对象（dao）</li>
<li>工具对象（util）</li>
</ul>
</li>
<li><p>哪些bean对象不适合交给容器进行管理?</p>
<ul>
<li>封装实例的域对象（domain，pojo），因为会引发线程安全问题，所以不适合。</li>
</ul>
</li>
</ul>
<h3 id="bean实例化"><a href="#bean实例化" class="headerlink" title="bean实例化"></a>bean实例化</h3><p>实例化bean的三种方式，<code>构造方法（常用）</code>,<code>静态工厂</code>和<code>实例工厂</code>（用到工厂实例再去了解）</p>
<h3 id="bean生命周期设置"><a href="#bean生命周期设置" class="headerlink" title="bean生命周期设置"></a>bean生命周期设置</h3><p>具体的控制有两个阶段:</p>
<ul>
<li>bean创建之后，想要添加内容，比如用来初始化需要用到资源</li>
<li>bean销毁之前，想要添加内容，比如用来释放用到的资源</li>
</ul>
<ol>
<li><p>添加初始化和销毁方法</p>
<p>针对这两个阶段，我们在BookDaoImpl类中分别添加两个方法，方法名随便取</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;init ... &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;destroy ... &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置生命周期，修改bookDao的配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.blog.dao.impl.BookDaoImpl&quot;</span> <span class="attr">init-method</span>=<span class="string">&quot;init&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;destroy&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>运行程序，输出结果如下：</p>
<blockquote>
<p>init …<br>book dao save …</p>
</blockquote>
</li>
</ol>
<p>从结果中可以看出，init方法执行了，但是destroy方法却未执行，这是为什么呢?</p>
<ul>
<li>Spring的IOC容器是运行在JVM中</li>
<li>运行main方法后,JVM启动,Spring加载配置文件生成IOC容器,从容器获取bean对象，然后调方法执行</li>
<li>main方法执行完后，JVM退出，这个时候IOC容器中的bean还没有来得及销毁就已经结束了</li>
<li>所以没有调用对应的destroy方法</li>
</ul>
<h4 id="close关闭容器"><a href="#close关闭容器" class="headerlink" title="close关闭容器"></a>close关闭容器</h4><ul>
<li><p>ApplicationContext中没有close方法，它的子类中有close方法</p>
</li>
<li><p>所以需要将ApplicationContext更换成ClassPathXmlApplicationContext，然后调用close方法就好啦</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);</span></span><br><span class="line">        <span class="type">ClassPathXmlApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="type">BookDao</span> <span class="variable">bookDao</span> <span class="operator">=</span> (BookDao) context.getBean(<span class="string">&quot;bookDao&quot;</span>);</span><br><span class="line">        bookDao.save();</span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行程序，输出如下，可以看到destroy正常输出</p>
<blockquote>
<p>init …<br>book dao save …<br>destroy …</p>
</blockquote>
</li>
</ul>
<h4 id="注册钩子关闭容器"><a href="#注册钩子关闭容器" class="headerlink" title="注册钩子关闭容器"></a>注册钩子关闭容器</h4><ul>
<li><p>在容器未关闭之前，提前设置好回调函数，让JVM在退出之前回调此函数来关闭容器</p>
</li>
<li><p>调用context的registerShutdownHook()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ClassPathXmlApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="type">BookDao</span> <span class="variable">bookDao</span> <span class="operator">=</span> (BookDao) context.getBean(<span class="string">&quot;bookDao&quot;</span>);</span><br><span class="line">        bookDao.save();</span><br><span class="line">        context.registerShutdownHook();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：registerShutdownHook在ApplicationContext中也没有</p>
</li>
<li><p>运行后，查询打印结果</p>
<blockquote>
<p>init …<br>book dao save …<br>destroy … </p>
</blockquote>
</li>
<li><p>那两种方式介绍完后，close和registerShutdownHook选哪个?</p>
<ul>
<li><p>相同点:这两种都能用来关闭容器</p>
</li>
<li><p>不同点:close()是在调用的时候关闭，registerShutdownHook()是在JVM退出前调用关闭。</p>
<ul>
<li><p>那么registerShutdownHook()方法可以在任意位置调用，下面的代码中将其放在了第二行，仍能正常输出，但要是将其换成close()方法，则会报错，BeanFactory not initialized or already closed，这里就是already closed</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ClassPathXmlApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        context.registerShutdownHook();</span><br><span class="line">        <span class="type">BookDao</span> <span class="variable">bookDao</span> <span class="operator">=</span> (BookDao) context.getBean(<span class="string">&quot;bookDao&quot;</span>);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>开发中到底用哪个呢？</p>
<ul>
<li>答案是两个都不用</li>
<li>分析上面的实现过程，会发现添加初始化和销毁方法，即需要编码也需要配置，实现起来步骤比较多也比较乱。</li>
</ul>
</li>
</ul>
<h4 id="bean生命周期控制接口"><a href="#bean生命周期控制接口" class="headerlink" title="bean生命周期控制接口"></a>bean生命周期控制接口</h4><p>Spring给我们提供了两个接口来完成生命周期的控制，好处是可以不用再进行配置<code>init-method</code>和<code>destroy-method</code></p>
<ul>
<li><p>接下来在BookServiceImpl和BookDaoImpl完成这两个接口的使用</p>
<ul>
<li><p>修改BookServiceImpl和BookDaoImpl类，添加两个接口</p>
<p><code>InitializingBean</code> <code>DisposableBean</code></p>
<p>并实现接口中的两个方法<code>afterPropertiesSet</code>和<code>destroy</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.sza.dao.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.DisposableBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.InitializingBean;</span><br><span class="line"><span class="keyword">import</span> org.sza.dao.BookDao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> , InitializingBean , DisposableBean &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BookDaoImpl</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;BookDaoImpl&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;destroy book dao&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;afterPropertiesSet book dao&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;save book dao&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.sza.service.impl;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.DisposableBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.InitializingBean;</span><br><span class="line"><span class="keyword">import</span> org.sza.dao.BookDao;</span><br><span class="line"><span class="keyword">import</span> org.sza.service.BookService;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span>, InitializingBean , DisposableBean &#123;</span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BookServiceImpl</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;BookServiceImpl&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;save book service&quot;</span>);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBookDao</span><span class="params">(BookDao bookDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bookDao = bookDao;</span><br><span class="line">        System.out.println(<span class="string">&quot;BookServiceImpl setBookDao&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;destroy book service&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;after properties set book service&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>applicationContext.xml中BookServiceImpl的bean配置如下</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.sza.dao.impl.BookDaoImpl&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.sza.service.impl.BookServiceImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 配置Service与Dao之间的关系 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bookDao&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>重新运行Main类，输出结果如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//        使用Spring ClassPathXmlApplicationContext 完成IOC容器的创建</span></span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line"><span class="comment">//        使用getBean(String name)方法，其name参数就是我们在bean配置的id，通过这个id来创造对象</span></span><br><span class="line">        <span class="type">BookService</span> <span class="variable">bookService</span> <span class="operator">=</span> (BookService) context.getBean(<span class="string">&quot;bookService&quot;</span>);</span><br><span class="line">        bookService.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>BookDaoImpl<br>afterPropertiesSet book dao<br>BookServiceImpl<br>BookServiceImpl setBookDao<br>after properties set book service<br>save book service<br>save book dao</p>
</blockquote>
</li>
</ul>
<p>值的注意的是，BookDaoImpl的构造函数和BookServiceImpl的构造函数并没有实质上的前后关系，<font color="green">因为BookDaoImpl使用的是依赖注入中的通过setter方法进行注入</font>：如果某个依赖是通过 <strong>setter 方法</strong> 注入的，Spring 不需要立即初始化这个依赖，而是在注入时才会实例化。</p>
<p>依赖注入的bean与bean之间是通过setter进行注入，那么bean的构造函数取决于applicationContext.xml中bean的声明顺序。从上面的bean的声明顺序为bookDao在前，因此其构造函数会在bookService的前面。</p>
<p>我们把 顺序调换：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.sza.service.impl.BookServiceImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置Service与Dao之间的关系 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bookDao&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.sza.dao.impl.BookDaoImpl&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>再次运行：</p>
<blockquote>
<p>BookServiceImpl<br>BookDaoImpl<br>afterPropertiesSet book dao<br>BookServiceImpl setBookDao</p>
<p>after properties set book service<br>save book service<br>save book dao</p>
</blockquote>
<p>分析：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">BookService</span> <span class="variable">bookService</span> <span class="operator">=</span> (BookService) context.getBean(<span class="string">&quot;bookService&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>在获取IoC容器bo</p>
<p>因此也会获取IoC容器中bookDao bean的实例。bookDao bean实例化采用构造方法的方式，因此第一个调用的是bookDaoImpl的构造函数。</p>
<blockquote>
<p>BookDaoImpl &#x2F;&#x2F; 执行bookDaoImpl的构造函数</p>
</blockquote>
<p>BookDaoImpl 先调用构造函数，初始化类的属性，后调用bookDao bean生命周期的初始化init方法，<font color="green">你从afterPropertiesSet名字也可以看出来其含义</font></p>
<blockquote>
<p>afterPropertiesSet book dao &#x2F;&#x2F; bookDao bean生命周期的初始化init方法</p>
</blockquote>
<p>执行bookService bean的实例化（如果是setter注入他们之间与依赖注入的类并没有先后关系，因为注入是调用setter方法进行注入的），调用bookService的构造函数：</p>
<blockquote>
<p>BookServiceImpl &#x2F;&#x2F; 执行bookServiceImpl的构造函数</p>
</blockquote>
<p>bookService bean有属性bookdao对象，执行bookServices属性依赖注入方法</p>
<blockquote>
<p>BookServiceImpl setBookDao &#x2F;&#x2F;执行setBookDao依赖注入方法</p>
</blockquote>
<p>属性初始化完毕后，调用bookService bean的生命周期的初始化init方法</p>
<blockquote>
<p>after properties set book service &#x2F;&#x2F;  bookService bean生命周期的初始化init方法</p>
</blockquote>
<p>然后bookService bean算是初始化完毕，回到main方法，调用save方法：</p>
<blockquote>
<p>save book service<br>save book dao</p>
</blockquote>
<p>执行完后会执行bookService bean的生命周期方法 销毁，然后是bookDao Bean的销毁。</p>
<h2 id="DI相关内容"><a href="#DI相关内容" class="headerlink" title="DI相关内容"></a>DI相关内容</h2><p>依赖注入描述了在容器中建立bean与bean之间的依赖关系的过程。</p>
<p>Spring为我们提供了两种注入方式，分别是</p>
<ul>
<li><code>setter注入（简单类型/引用类型）</code></li>
<li><code>构造器注入（简单类型/引用类型）</code></li>
</ul>
<h3 id="setter注入"><a href="#setter注入" class="headerlink" title="setter注入"></a>setter注入</h3><p>setter注入方式的基本使用</p>
<ul>
<li>对于引用数据类型使用的是<code>&lt;property name=&quot;&quot; ref=&quot;&quot;/&gt;</code></li>
<li>对于简单数据类型使用的是<code>&lt;property name=&quot;&quot; value=&quot;&quot;/&gt;</code></li>
</ul>
<h4 id="setter注入引用数据类型-实例"><a href="#setter注入引用数据类型-实例" class="headerlink" title="setter注入引用数据类型 实例"></a>setter注入引用数据类型 实例</h4><ul>
<li><p>对于setter方式注入引用类型的方式之前已经学习过，快速回顾下:</p>
</li>
<li><p>在bean中定义引用类型属性，并提供可访问的set方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBookDao</span><span class="params">(BookDao bookDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bookDao = bookDao;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置中使用property标签ref属性注入引用类型对象</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.blog.service.impl.BookServiceImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bookDao&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>我们再来回顾一下配置中的两个bookDao的含义</p>
<blockquote>
<p>配置中的两个bookDao的含义是不一样的</p>
<ul>
<li>name&#x3D;”bookDao”中bookDao的作用是让Spring的IOC容器在获取到名称后，将首字母大写，前面加set找对应的setBookDao()方法进行对象注入</li>
<li>ref&#x3D;”bookDao”中bookDao的作用是让Spring能在IOC容器中找到id为bookDao的Bean对象给bookService进行注入</li>
</ul>
</blockquote>
</li>
</ul>
<p>总结：</p>
<blockquote>
<p>需求:在bookServiceImpl对象中注入bookDao</p>
<ol>
<li>在BookServiceImpl中声明bookDao属性</li>
<li>为bookDao属性提供setter方法</li>
<li>在配置文件中使用property标签注入</li>
</ol>
</blockquote>
<p>注入多个引用类型数据：</p>
<ol>
<li>在BookServiceImpl中声明bookDao属性和userDao属性并提供对应的setter方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.sza.service.impl;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.DisposableBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.InitializingBean;</span><br><span class="line"><span class="keyword">import</span> org.sza.dao.BookDao;</span><br><span class="line"><span class="keyword">import</span> org.sza.dao.UserDao;</span><br><span class="line"><span class="keyword">import</span> org.sza.service.BookService;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span>, InitializingBean , DisposableBean &#123;</span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BookServiceImpl</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;BookServiceImpl&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBookDao</span><span class="params">(BookDao bookDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bookDao = bookDao;</span><br><span class="line">        System.out.println(<span class="string">&quot;BookServiceImpl setBookDao&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserDao</span><span class="params">(UserDao userDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userDao = userDao;</span><br><span class="line">        System.out.println(<span class="string">&quot;BookServiceImpl setUserDao&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在配置文件中使用property标签注入</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.sza.dao.impl.BookDaoImpl&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.sza.dao.impl.UserDaoImpl&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.sza.service.impl.BookServiceImpl&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bookDao&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="setter注入简单数据类型-实例"><a href="#setter注入简单数据类型-实例" class="headerlink" title="setter注入简单数据类型 实例"></a>setter注入简单数据类型 实例</h4><ul>
<li>引用类型使用的是<code>&lt;property name=&quot;&quot; ref=&quot;&quot;/&gt;</code>,简单数据类型还是使用ref吗?</li>
<li>ref是指向Spring的IOC容器中的另一个bean对象的，对于简单数据类型，使用value来配置<code>&lt;property name=&quot;&quot; value=&quot;&quot;/&gt;</code></li>
</ul>
<ol>
<li>步骤一：BookServiceImpl声明属性并提供setter方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> connectionCount;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setConnectionCount</span><span class="params">(<span class="type">int</span> connectionCount)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.connectionCount = connectionCount;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>步骤二：在配置文件中进行注入配置，在applicationContext.xml配置文件中使用property标签注入</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.sza.dao.impl.BookDaoImpl&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.sza.dao.impl.UserDaoImpl&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.sza.service.impl.BookServiceImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bookDao&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;connectionCount&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>value:后面跟的是简单数据类型，对于参数类型，Spring在注入的时候会自动转换，但是不能写一个错误的类型，例如<code>connectionCount</code>是<code>int</code>类型，你却给他传一个<code>abc</code>，这样的话，spring在将<code>abc</code>转换成int类型的时候就会报错。</p>
</blockquote>
<h3 id="构造器注入"><a href="#构造器注入" class="headerlink" title="构造器注入"></a>构造器注入</h3><ol>
<li>步骤一：删除setter方法并提供构造方法，在BookServiceImpl类中将bookDao的setter方法删除掉,并添加带有bookDao参数的构造方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BookServiceImpl</span><span class="params">(BookDao bookDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bookDao = bookDao;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>步骤二：配置文件中进行配置构造方式注入，在applicationContext.xml中配置</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.blog.dao.impl.BookDaoImpl&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.blog.service.impl.BookServiceImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bookDao&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>说明：在标签<code>&lt;constructor-arg&gt;</code>中</p>
<ul>
<li>name属性对应的值为构造函数中方法<code>形参的参数名</code>，必须要保持一致。</li>
<li>ref属性指向的是spring的IOC容器中其他bean对象。</li>
</ul>
</blockquote>
<h4 id="构造器注入多个引用数据类型"><a href="#构造器注入多个引用数据类型" class="headerlink" title="构造器注入多个引用数据类型"></a>构造器注入多个引用数据类型</h4><p>需求：在BookServiceImpl使用构造函数注入多个引用数据类型，比如userDao</p>
<blockquote>
<ol>
<li>声明userDao属性</li>
<li>生成一个带有bookDao和userDao参数的构造函数</li>
<li>在applicationContext.xml中配置注入</li>
</ol>
</blockquote>
<ol>
<li>步骤一：提供多个属性的构造函数</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BookServiceImpl</span><span class="params">(BookDao bookDao, UserDao userDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bookDao = bookDao;</span><br><span class="line">        <span class="built_in">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>步骤二：在配置文件中配置多参数注入</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.blog.dao.impl.UserDaoImpl&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.blog.dao.impl.BookDaoImpl&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.blog.service.impl.BookServiceImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bookDao&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="构造器注入多个简单数据类型"><a href="#构造器注入多个简单数据类型" class="headerlink" title="构造器注入多个简单数据类型"></a>构造器注入多个简单数据类型</h4><blockquote>
<p>需求:在BookDaoImpl中，使用构造函数注入databaseName和connectionNum两个参数。<br>参考引用数据类型的注入，我们可以推出具体的步骤为:</p>
<ol>
<li>提供一个包含这两个参数的构造方法</li>
<li>在applicationContext.xml中进行注入配置</li>
</ol>
</blockquote>
<ol>
<li>步骤一：添加多个简单属性并提供构造方法：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String databaseName;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> connectionNum;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BookDaoImpl</span><span class="params">(String databaseName, <span class="type">int</span> connectionNum)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.databaseName = databaseName;</span><br><span class="line">        <span class="built_in">this</span>.connectionNum = connectionNum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>步骤二：配置完成多个属性构造器注入</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.blog.dao.impl.BookDaoImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;databaseName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;mysql&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;connectionNum&quot;</span> <span class="attr">value</span>=<span class="string">&quot;100&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>还可以按照按照类型注入和按照索引下标注入：</p>
<ul>
<li><p>方式一：删除name属性，添加type属性，按照类型注入</p>
<ul>
<li><p>这种方式可以解决构造函数形参名发生变化带来的耦合问题</p>
</li>
<li><p>但是如果构造方法参数中有类型相同的参数，这种方式就不太好实现了</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.blog.dao.impl.BookDaoImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">&quot;java.lang.String&quot;</span> <span class="attr">value</span>=<span class="string">&quot;mysql&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">&quot;int&quot;</span> <span class="attr">value</span>=<span class="string">&quot;9421&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>方式二：删除type属性，添加index属性，按照索引下标注入，下标从0开始</p>
<ul>
<li><p>这种方式可以解决参数类型重复问题</p>
</li>
<li><p>但是如果构造方法参数顺序发生变化后，这种方式又带来了耦合问题</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.blog.dao.impl.BookDaoImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span> <span class="attr">value</span>=<span class="string">&quot;mysql&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;9421&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<blockquote>
<p>介绍完两种参数的注入方式，具体我们该如何选择呢?</p>
<ol>
<li>强制依赖使用构造器进行，使用setter注入有概率不进行注入导致null对象出现<ul>
<li>强制依赖指对象在创建的过程中必须要注入指定的参数</li>
</ul>
</li>
<li>可选依赖使用setter注入进行，灵活性强<ul>
<li>可选依赖指对象在创建过程中注入的参数可有可无</li>
</ul>
</li>
<li>Spring框架倡导使用构造器，第三方框架内部大多数采用构造器注入的形式进行数据初始化，相对严谨</li>
<li>如果有必要可以两者同时使用，使用构造器注入完成强制依赖的注入，使用setter注入完成可选依赖的注入</li>
<li>实际开发过程中还要根据实际情况分析，如果受控对象没有提供setter方法就必须使用构造器注入</li>
<li>自己开发的模块推荐使用setter注入</li>
</ol>
</blockquote>
<h3 id="自动装配"><a href="#自动装配" class="headerlink" title="自动装配"></a>自动装配</h3><p>IOC容器根据bean所依赖的资源在容器中<font color="green">自动查找并注入</font>到bean中的过程称为自动装配</p>
<blockquote>
<p>自动装配方式有哪些:</p>
<ul>
<li>按类型（常用）</li>
<li>按名称</li>
<li>按构造方法</li>
<li>不启用自动装配</li>
</ul>
</blockquote>
<p>自动装配只需要修改applicationContext.xml配置文件即可:</p>
<ol>
<li>将<code>&lt;property&gt;</code>标签删除</li>
<li>在<code>&lt;bean&gt;</code>标签中添加autowire属性</li>
</ol>
<ul>
<li><p>首先来实现按照类型注入的配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.sza.dao.impl.BookDaoImpl&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.sza.dao.impl.UserDaoImpl&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.sza.service.impl.BookServiceImpl&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byType&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;/&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;property name=&quot;bookDao&quot; ref=&quot;bookDao&quot;/&gt;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>注意事项：</p>
<ul>
<li>需要注入属性的类中对应属性的<code>setter</code>方法不能省略</li>
<li>被注入的对象必须要被Spring的IOC容器管理</li>
<li>按照类型在Spring的IOC容器中如果找到多个对象，会报<code>NoUniqueBeanDefinitionException</code></li>
</ul>
</blockquote>
<p>当一个类型在IOC中有多个对象，还想要注入成功，这个时候就需要按照名称注入，配置方式如下:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.sza.dao.impl.BookDaoImpl&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.sza.dao.impl.UserDaoImpl&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.sza.service.impl.BookServiceImpl&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byName&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;/&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;property name=&quot;bookDao&quot; ref=&quot;bookDao&quot;/&gt;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="集合注入"><a href="#集合注入" class="headerlink" title="集合注入"></a>集合注入</h3><p>还有一种数据类型<code>集合</code>，集合中既可以装简单数据类型也可以装引用数据类型，对于集合，在Spring中该如何注入呢?</p>
<p>先来回顾下，常见的集合类型有哪些?</p>
<ul>
<li>数组</li>
<li>List</li>
<li>Set</li>
<li>Map</li>
<li>Properties</li>
</ul>
<h4 id="注入数组类型"><a href="#注入数组类型" class="headerlink" title="注入数组类型"></a>注入数组类型</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;array&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>100<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>200<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>300<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="注入List类型"><a href="#注入List类型" class="headerlink" title="注入List类型"></a>注入List类型</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;list&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>张三<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>ABC<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>123<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="注入Set类型"><a href="#注入Set类型" class="headerlink" title="注入Set类型"></a>注入Set类型</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;set&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>100<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>200<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>ABC<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>ABC<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="注入Map类型"><a href="#注入Map类型" class="headerlink" title="注入Map类型"></a>注入Map类型</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;map&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;探路者&quot;</span> <span class="attr">value</span>=<span class="string">&quot;马文&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;次元游记兵&quot;</span> <span class="attr">value</span>=<span class="string">&quot;恶灵&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;易位窃贼&quot;</span> <span class="attr">value</span>=<span class="string">&quot;罗芭&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="注入Properties类型"><a href="#注入Properties类型" class="headerlink" title="注入Properties类型"></a>注入Properties类型</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;properties&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;暴雷&quot;</span>&gt;</span>沃尔特·菲茨罗伊<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;寻血猎犬&quot;</span>&gt;</span>布洛特·亨德尔<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;命脉&quot;</span>&gt;</span>阿杰·切<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>说明：</p>
<ul>
<li>property标签表示setter方式注入，构造方式注入constructor-arg标签内部也可以写<code>&lt;array&gt;</code>、<code>&lt;list&gt;</code>、<code>&lt;set&gt;</code>、<code>&lt;map&gt;</code>、<code>&lt;props&gt;</code>标签</li>
<li>List的底层也是通过数组实现的，所以<code>&lt;list&gt;</code>和<code>&lt;array&gt;</code>标签是可以混用</li>
<li>集合中要添加引用类型，只需要把<code>&lt;value&gt;</code>标签改成<code>&lt;ref&gt;</code>标签，这种方式用的比较少</li>
</ul>
</blockquote>
<h2 id="IOC-DI配置管理第三方bean"><a href="#IOC-DI配置管理第三方bean" class="headerlink" title="IOC&#x2F;DI配置管理第三方bean"></a>IOC&#x2F;DI配置管理第三方bean</h2><blockquote>
<p>需求：使用Spring的IOC容器来管理Druid连接池对象</p>
<ol>
<li>使用第三方的技术，需要在pom.xml添加依赖</li>
<li>在配置文件中将<code>第三方的类</code>制作成一个bean，让IOC容器进行管理</li>
<li>数据库连接需要基础的四要素<code>驱动</code>、<code>连接</code>、<code>用户名</code>和<code>密码</code>，<code>如何注入</code>到对应的bean中</li>
<li>从IOC容器中获取对应的bean对象，将其打印到控制台查看结果</li>
</ol>
</blockquote>
<ol>
<li>步骤一：导入druid依赖</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.16<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>步骤二：配置第三方bean</li>
</ol>
<p>那么到底是使用setter注入还是构造器注入呢？这个就需要我们来看看第三方类给我们提供了什么<br>通过查看源码，我们发现<code>DruidDataSource</code>只给我们提供了两个构造器如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">DruidDataSource</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">DruidDataSource</span><span class="params">(<span class="type">boolean</span> fairLock)</span> </span><br></pre></td></tr></table></figure>

<p>显然这两个构造器不能满足我们的需求，因为我们需要注入数据库连接的四要素，构造器的参数中没有提供<br>那么我们继续来看看给我们提供了什么setter方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUsername</span><span class="params">(String username)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!StringUtils.equals(<span class="built_in">this</span>.username, username)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.inited) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.username = username;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPassword</span><span class="params">(String password)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!StringUtils.equals(<span class="built_in">this</span>.password, password)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.inited) &#123;</span><br><span class="line">            LOG.info(<span class="string">&quot;password changed&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">···</span><br></pre></td></tr></table></figure>

<p>通过查看源码，我们发现已经给我们提供了许多的setter方法，其中包括了连接四要素，所以这里我们需要使用setter注入（使用property），在applicationContext.xml配置文件中添加<code>DruidDataSource</code>的配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/mybatisDb&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;xxxxxx&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span>  </span><br></pre></td></tr></table></figure>

<ol start="3">
<li>步骤三：从IOC容器中获取对应的bean对象</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//        使用Spring ClassPathXmlApplicationContext 完成IOC容器的创建</span></span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="type">DruidDataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> context.getBean(DruidDataSource.class);</span><br><span class="line">        System.out.println(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="加载properties文件"><a href="#加载properties文件" class="headerlink" title="加载properties文件"></a>加载properties文件</h3><blockquote>
<p>刚刚我们完成了druid数据源的配置，但其中包含了一些问题，我们来分析一下：</p>
<ul>
<li>这两个数据源中都用到了一些固定的常量（如数据库连接四要素），把这些值加载到Spring的配置文件中，不利于后期的维护</li>
<li>那我们现在就需要将这些值提取到一个外部的properties配置文件中，在之前我们也是这样做的</li>
<li>那么如何在Spring框架中读取配置文件来进行配置，就是我们接下来要解决的问题</li>
</ul>
</blockquote>
<h4 id="第三方bean属性优化"><a href="#第三方bean属性优化" class="headerlink" title="第三方bean属性优化"></a>第三方bean属性优化</h4><blockquote>
<p>需求:将数据库连接四要素提取到properties配置文件，spring来加载配置信息并使用这些信息来完成属性注入。</p>
<ol>
<li>在resources下创建一个jdbc.properties(文件的名称可以任意)</li>
<li>将数据库连接四要素配置到配置文件中</li>
<li>在Spring的配置文件中加载properties文件</li>
<li>使用加载到的值实现属性注入</li>
</ol>
</blockquote>
<ol>
<li>步骤一：准备properties配置文件，resources下创建一个jdbc.properties文件,并添加对应的属性键值对</li>
</ol>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">jdbc.driverClass</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">jdbc.url</span>=<span class="string">jdbc:mysql://localhost:3306/mybatisDb</span></span><br><span class="line"><span class="attr">jdbc.username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">jdbc.password</span>=<span class="string">xxxxx</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>步骤二：开启<code>context</code>命名空间，在applicationContext.xml中开<code>context</code>命名空间。</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/beans/spring-context.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">       &quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>步骤三：加载properties配置文件，在配置文件中使用<code>context</code>命名空间下的标签来加载properties配置文件</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;jdbc.properties&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>步骤四：完成属性注入，使用<code>$&#123;key&#125;</code>来读取properties配置文件中的内容并完成属性注入</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;jdbc.properties&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driverClass&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>&lt;context:property-placeholder/&gt;</code>标签会加载系统的环境变量，而且环境变量的值会被优先加载，可能会与系统的环境变量产生冲突：</p>
<p>解决方案，将system-properties-mode设置为NEVER，表示不加载系统环境变量，这样就可以解决上面的问题了，当然还有一个解决方案就是避免使用<code>username</code>作为属性的<code>key</code>。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;jdbc.properties&quot;</span> <span class="attr">system-properties-mode</span>=<span class="string">&quot;NEVER&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>当有多个properties配置文件需要被加载：</p>
<ul>
<li><p>修改applicationContext.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--方式一 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;jdbc.properties,jdbc2.properties&quot;</span> <span class="attr">system-properties-mode</span>=<span class="string">&quot;NEVER&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--方式二--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;*.properties&quot;</span> <span class="attr">system-properties-mode</span>=<span class="string">&quot;NEVER&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--方式三 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:*.properties&quot;</span> <span class="attr">system-properties-mode</span>=<span class="string">&quot;NEVER&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--方式四--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath*:*.properties&quot;</span> <span class="attr">system-properties-mode</span>=<span class="string">&quot;NEVER&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>说明：</p>
<ul>
<li>方式一：可以实现，如果配置文件多的话，每个都需要配置</li>
<li>方式二：<code>*.properties</code>代表所有以properties结尾的文件都会被加载，可以解决方式一的问题，但是不标准</li>
<li>方式三：标准的写法，<code>classpath:</code>代表的是从根路径下开始查找，但是只能查询当前项目的根路径</li>
<li>方式四：不仅可以加载当前项目还可以加载当前项目所依赖的所有项目的根路径下的properties配置文件</li>
</ul>
</li>
</ul>
<h2 id="核心容器"><a href="#核心容器" class="headerlink" title="核心容器"></a>核心容器</h2><p>这里所说的核心容器，我们可以把它简单的理解为<code>ApplicationContex</code></p>
<h4 id="容器的创建方式"><a href="#容器的创建方式" class="headerlink" title="容器的创建方式"></a>容器的创建方式</h4><ul>
<li><p>案例中创建<code>ApplicationContext</code>的方式如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>可以看到，Spring容器就是<code>ApplicationContext</code>，它是一个接口，有很多实现类，这里我们选择<code>ClassPathXmlApplicationContext</code>，表示它会自动从classpath中查找指定的XML配置文件。</p>
</li>
<li><p>除了上面这种方式，Spring还提供了另外一种创建方式</p>
</li>
<li><p>这种方式翻译为：文件系统下的XML配置文件，路径需要写绝对路径</p>
</li>
<li><p>这种方式虽能实现，但是当项目的位置发生变化后，代码也需要跟着改，耦合度高，不推荐使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileSystemXmlApplicationContext</span>(<span class="string">&quot;D:\xxx/xxx\applicationContext.xml&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="获取bean的三种方式"><a href="#获取bean的三种方式" class="headerlink" title="获取bean的三种方式"></a>获取bean的三种方式</h4><ul>
<li><p>方式一，就是我们之前用的方式</p>
<p>这种方式存在的问题是每次获取的时候都需要进行类型转换，有没有更简单的方式呢?</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">BookDao</span> <span class="variable">bookDao</span> <span class="operator">=</span> (BookDao) ctx.getBean(<span class="string">&quot;bookDao&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>方式二<br>这种方式可以解决类型强转问题，但是参数又多加了一个，相对来说没有简化多少。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">BookDao</span> <span class="variable">bookDao</span> <span class="operator">=</span> ctx.getBean(<span class="string">&quot;bookDao&quot;</span>，BookDao.class);</span><br></pre></td></tr></table></figure>
</li>
<li><p>方式三</p>
<p>这种方式就类似我们之前所学习依赖注入中的按类型注入。必须要确保IOC容器中该类型对应的bean对象只能有一个。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">BookDao</span> <span class="variable">bookDao</span> <span class="operator">=</span> ctx.getBean(BookDao.class);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="BeanFactory的使用"><a href="#BeanFactory的使用" class="headerlink" title="BeanFactory的使用"></a>BeanFactory的使用</h4><p>Spring还提供另一种IoC容器叫<code>BeanFactory</code>，使用方式和<code>ApplicationContext</code>类似：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">BeanFactory</span> <span class="variable">bf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XmlBeanFactory</span>(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;applicationContext.xml&quot;</span>));</span><br><span class="line"><span class="type">BookDao</span> <span class="variable">bookDao</span> <span class="operator">=</span> bf.getBean(BookDao.class);</span><br></pre></td></tr></table></figure>

<p>容器的最上级的父接口为<code>BeanFactory</code>，使用<code>BeanFactory</code>也可以创建IOC容器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppForBeanFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Resource</span> <span class="variable">resources</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="type">BeanFactory</span> <span class="variable">bf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XmlBeanFactory</span>(resources);</span><br><span class="line">        <span class="type">BookDao</span> <span class="variable">bookDao</span> <span class="operator">=</span> bf.getBean(BookDao.class);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>BeanFactory</code>和<code>ApplicationContext</code>的区别在于，<code>BeanFactory</code>的实现是按需创建，即第一次获取Bean时才创建这个Bean，而<code>ApplicationContext</code>会一次性创建所有的Bean。实际上，<code>ApplicationContext</code>接口是从<code>BeanFactory</code>接口继承而来的，并且，<code>ApplicationContext</code>提供了一些额外的功能，包括国际化支持、事件和通知机制等。通常情况下，我们总是使用<code>ApplicationContext</code>，很少会考虑使用<code>BeanFactory</code>。</p>
</blockquote>
<p>为了更好的看出<code>BeanFactory</code>和<code>ApplicationContext</code>之间的区别，在BookDaoImpl添加如下构造函数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BookDaoImpl</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;constructor&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果不去获取bean对象，打印会发现：</p>
<ul>
<li><p>BeanFactory是延迟加载，只有在获取bean对象的时候才会去创建</p>
</li>
<li><p>ApplicationContext是立即加载，容器加载的时候就会创建bean对象</p>
</li>
<li><p>ApplicationContext要想成为延迟加载，只需要将lazy-init设为true</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">            http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.blog.dao.impl.BookDaoImpl&quot;</span>  <span class="attr">lazy-init</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>总结</p>
<blockquote>
<ul>
<li>BeanFactory是IoC容器的顶层接口，初始化BeanFactory对象时，加载的bean延迟加载</li>
<li>ApplicationContext接口是Spring容器的核心接口，初始化时bean立即加载</li>
<li>ApplicationContext接口提供基础的bean操作相关方法，通过其他接口扩展其功能</li>
<li>ApplicationContext接口常用初始化类<ul>
<li>ClassPathXmlApplicationContext(常用)</li>
<li>FileSystemXmlApplicationContext</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="bean相关"><a href="#bean相关" class="headerlink" title="bean相关"></a>bean相关</h4><img src="image-20241116221633932.png" class title="image-20241116221633932">

<h4 id="依赖注入相关"><a href="#依赖注入相关" class="headerlink" title="依赖注入相关"></a>依赖注入相关</h4><img src="image-20241116221701034.png" class title="image-20241116221701034">

<h2 id="IOC-DI注解开发"><a href="#IOC-DI注解开发" class="headerlink" title="IOC&#x2F;DI注解开发"></a>IOC&#x2F;DI注解开发</h2><blockquote>
<p>使用Spring的IoC容器，实际上就是通过类似XML这样的配置文件，把我们自己的Bean的依赖关系描述出来，然后让容器来创建并装配Bean。一旦容器初始化完毕，我们就直接从容器中获取Bean使用它们。</p>
<p>使用XML配置的优点是所有的Bean都能一目了然地列出来，并通过配置注入能直观地看到每个Bean的依赖。它的缺点是写起来非常繁琐，每增加一个组件，就必须把新的Bean配置到XML中。</p>
<p>有没有其他更简单的配置方式呢？</p>
<p>有！我们可以使用Annotation配置，可以完全不需要XML，让Spring自动扫描Bean并组装它们。</p>
</blockquote>
<p>两块内容<code>注解开发定义bean</code>和<code>纯注解开发</code>。</p>
<h3 id="注解开发定义bean"><a href="#注解开发定义bean" class="headerlink" title="注解开发定义bean"></a>注解开发定义bean</h3><ul>
<li><code>步骤一：</code>删除原有的XML配置，将配置文件中的bean标签删除掉</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.blog.dao.impl.BookDaoImpl&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>步骤二：</code>在Dao上添加注解，在BookDaoImpl类上添加<code>@Component</code>注解</li>
</ul>
<blockquote>
<p>这个<code>@Component</code>注解就相当于定义了一个Bean，它有一个可选的名称，默认是<code>BookDaoImpl</code>，即小写开头的类名。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;bookDao&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：@Component注解不可以添加在接口上，因为接口是无法创建对象的</p>
</blockquote>
<ul>
<li><code>步骤三：</code>配置Spring的注解包扫描，为了让Spring框架能够扫描到写在类上的注解，需要在配置文件上进行包扫描</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">            http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">            http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">            http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">            http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        &quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;org.sza.dao.impl&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><blockquote>
<p>说明：component-scan</p>
<ul>
<li>component:组件,Spring将管理的bean视作自己的一个组件</li>
<li>scan:扫描 base-package指定Spring框架扫描的包路径，它会扫描指定包及其子包中的所有类上的注解。</li>
<li>包路径越多<code>如:org.sza.dao.impl</code>，扫描的范围越小速度越快</li>
<li>包路径越少<code>如:org.sza</code>,扫描的范围越大速度越慢</li>
<li>一般扫描到项目的组织名称即Maven的groupId下<code>如:ora.sza</code>即可。</li>
</ul>
</blockquote>
</li>
<li><p><code>步骤四：</code>Service上添加注解</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book service save ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>BookServiceImpl类没有起名称，所以在App中是按照类型来获取bean对象。<code>@Component</code>注解如果不起名称，会有一个默认值就是<code>当前类名首字母小写</code>，所以也可以按照名称获取，如</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">BookService</span> <span class="variable">bookService</span> <span class="operator">=</span> (BookService) context.getBean(<span class="string">&quot;bookServiceImpl&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>对于@Component注解，还衍生出了其他三个注解<code>@Controller</code>、<code>@Service</code>、<code>@Repository</code><br>通过查看源码会发现：这三个注解和@Component注解的作用是一样的，为什么要衍生出这三个呢?<br>这是方便我们后期在编写类的时候能很好的区分出这个类是属于<code>表现层</code>、<code>业务层</code>还是<code>数据层</code>的类。</p>
<h3 id="纯注解开发模式"><a href="#纯注解开发模式" class="headerlink" title="纯注解开发模式"></a>纯注解开发模式</h3><p>上面已经可以使用注解来配置bean,但是依然有用到配置文件，在配置文件中对包进行了扫描，Spring在3.0版已经支持纯注解开发，使用Java类替代配置文件</p>
<p>使用注解完成Spring的bean管理，但是并没有实现依赖注入。</p>
<p>BookDao、BookDaoImpl、BookService、BookServiceImpl类 设置为最原始的状态 没有bean与bean之间的依赖。</p>
<ul>
<li>BookDao</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>BookDaoImpl</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>BookService</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>BookServiceImpl</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book service save ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>实现思路为：</p>
<ul>
<li>将配置文件applicationContext.xml删掉，用类来替换</li>
</ul>
</blockquote>
<ul>
<li>步骤一：创建配置类，创建一个配置类SpringConfig</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>步骤二：标识该类为配置类，在配置类上面加一个@Configuration注解，将其标识为一个配置类，用于替换掉applicationContext.XML</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>步骤三：用注解替换包扫描配置，在配置类上添加包扫描注解@ComponentScan替换&lt;context:component-scan base-package&#x3D;””&#x2F;&gt;</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.blog&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以扫描多个包</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&#123;&quot;org.sza.dao&quot;,&quot;org.sza.service&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>知识点：<code>@Configuration</code></li>
</ul>
<table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">@Configuration</th>
</tr>
</thead>
<tbody><tr>
<td align="center">类型</td>
<td align="center">类注解</td>
</tr>
<tr>
<td align="center">位置</td>
<td align="center">类定义上方</td>
</tr>
<tr>
<td align="center">作用</td>
<td align="center">设置该类为spring配置类</td>
</tr>
<tr>
<td align="center">属性</td>
<td align="center">value（默认）：定义bean的id</td>
</tr>
</tbody></table>
<ul>
<li>知识点：<code>@ComponentScan</code></li>
</ul>
<table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">@ComponentScan</th>
</tr>
</thead>
<tbody><tr>
<td align="center">类型</td>
<td align="center">类注解</td>
</tr>
<tr>
<td align="center">位置</td>
<td align="center">类定义上方</td>
</tr>
<tr>
<td align="center">作用</td>
<td align="center">设置spring配置类扫描路径，用于加载使用注解格式定义的bean</td>
</tr>
<tr>
<td align="center">属性</td>
<td align="center">value（默认）：扫描路径，此路径可以逐层向下扫描</td>
</tr>
</tbody></table>
<p>这时候并没有依赖注入。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>这部分要重点掌握的是使用注解完成Spring的bean管理，需要掌握的内容为:</p>
<ul>
<li>记住<code>@Component</code>、<code>@Controller</code>、<code>@Service</code>、<code>@Repository</code>这四个注解</li>
<li>applicationContext.xml中<code>&lt;context:component-san/&gt;</code>的作用是指定扫描包路径，注解为<code>@ComponentScan</code></li>
<li><code>@Configuration</code>标识该类为配置类，使用类替换<code>applicationContext.xml</code>文件</li>
<li><code>ClassPathXmlApplicationContext</code>是加载XML配置文件</li>
<li><code>AnnotationConfigApplicationContext</code>是加载配置类</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">├── pom.xml</span><br><span class="line">└── src</span><br><span class="line">    └── main</span><br><span class="line">        ├── java</span><br><span class="line">        │   └── com</span><br><span class="line">        │       └── itheima</span><br><span class="line">        │           ├── App.java</span><br><span class="line">        │           ├── config</span><br><span class="line">        │           │   └── SpringConfig.java</span><br><span class="line">        │           ├── dao</span><br><span class="line">        │           │   ├── BookDao.java</span><br><span class="line">        │           │   └── impl</span><br><span class="line">        │           │       ├── BookDaoImpl.java</span><br><span class="line">        │           │       └── BookDaoImpl2.java</span><br><span class="line">        │           └── service</span><br><span class="line">        │               ├── BookService.java</span><br><span class="line">        │               └── impl</span><br><span class="line">        │                   └── BookServiceImpl.java</span><br><span class="line">        └── resources</span><br><span class="line">            └── jdbc.properties</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SpringConfig.class);</span><br><span class="line">        <span class="type">BookService</span> <span class="variable">bookService</span> <span class="operator">=</span> ctx.getBean(BookService.class);</span><br><span class="line">        bookService.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>AppConfig</code>标注了<code>@Configuration</code>，表示它是一个配置类，因为我们创建<code>ApplicationContext</code>时使用<code>AnnotationConfigApplicationContext</code>进行创建：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">AnnotationConfigApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SpringConfig.class);</span><br></pre></td></tr></table></figure>

<h3 id="注解开发bean的作用范围和生命周期"><a href="#注解开发bean的作用范围和生命周期" class="headerlink" title="注解开发bean的作用范围和生命周期"></a>注解开发bean的作用范围和生命周期</h3><p>使用注解已经完成了bean的管理，接下来按照前面所学习的内容，将通过配置实现的内容都换成对应的注解实现，包含两部分内容:<code>bean作用范围(scope)</code>和<code>bean生命周期(init和destroy)</code></p>
<p>要想将BookDaoImpl变成非单例，只需要在其类上添加<code>@scope</code>注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;bookDao&quot;)</span></span><br><span class="line"><span class="meta">@Scope(&quot;prototype&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@scope：</p>
<table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">@Scope</th>
</tr>
</thead>
<tbody><tr>
<td align="center">类型</td>
<td align="center">类注解</td>
</tr>
<tr>
<td align="center">位置</td>
<td align="center">类定义上方</td>
</tr>
<tr>
<td align="center">作用</td>
<td align="center">设置该类创建对象的作用范围，可用于设置创建出的bean是否为单例对象</td>
</tr>
<tr>
<td align="center">属性</td>
<td align="center">value（默认）：定义bean作用范围，默认值singleton（单例），可选值prototype（非单例）</td>
</tr>
</tbody></table>
<h4 id="bean的生命周期"><a href="#bean的生命周期" class="headerlink" title="bean的生命周期"></a>bean的生命周期</h4><ul>
<li>在BookDaoImpl中添加两个方法，<code>init</code>和<code>destroy</code>，方法名可以任意，再添加一个构造方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;bookDao&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BookDaoImpl</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;construct ... &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;init ... &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;destroy ... &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如何对方法进行标识，哪个是初始化方法，哪个是销毁方法?<br>只需要在对应的方法上添加<code>@PostConstruct</code>和<code>@PreDestroy</code>注解即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;bookDao&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BookDaoImpl</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;construct ... &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span>  <span class="comment">// 在构造方法之后执行，替换 init-method</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;init ... &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PreDestroy</span> <span class="comment">// 在销毁方法之前执行,替换 destroy-method</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;destroy ... &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>知识点<code>@PostConstruct</code></p>
<table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">@PostConstruct</th>
</tr>
</thead>
<tbody><tr>
<td align="center">类型</td>
<td align="center">方法注解</td>
</tr>
<tr>
<td align="center">位置</td>
<td align="center">方法上</td>
</tr>
<tr>
<td align="center">作用</td>
<td align="center">设置该方法为初始化方法</td>
</tr>
<tr>
<td align="center">属性</td>
<td align="center">无</td>
</tr>
</tbody></table>
<p>知识点<code>@PreDestroy</code></p>
<table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">@PreDestroy</th>
</tr>
</thead>
<tbody><tr>
<td align="center">类型</td>
<td align="center">方法注解</td>
</tr>
<tr>
<td align="center">位置</td>
<td align="center">方法上</td>
</tr>
<tr>
<td align="center">作用</td>
<td align="center">设置该方法为销毁方法</td>
</tr>
<tr>
<td align="center">属性</td>
<td align="center">无</td>
</tr>
</tbody></table>
<blockquote>
<p>配置文件中的bean标签中的<br><code>id</code>对应<code>@Component(&quot;&quot;)</code>，<code>@Controller(&quot;&quot;)</code>，<code>@Service(&quot;&quot;)</code>，<code>@Repository(&quot;&quot;)</code><br><code>scope</code>对应<code>@scope()</code><br><code>init-method</code>对应<code>@PostConstruct</code><br><code>destroy-method</code>对应<code>@PreDestroy</code></p>
</blockquote>
<h3 id="注解开发依赖注入"><a href="#注解开发依赖注入" class="headerlink" title="注解开发依赖注入"></a>注解开发依赖注入</h3><p>Spring为了使用注解简化开发，并没有提供<code>构造函数注入</code>、<code>setter注入</code>对应的注解，只提供了自动装配的注解实现。</p>
<h4 id="注解实现按照类型注入"><a href="#注解实现按照类型注入" class="headerlink" title="注解实现按照类型注入"></a>注解实现按照类型注入</h4><p>在BookServiceImpl类的bookDao属性上添加<code>@Autowired</code>注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    public void setBookDao(BookDao bookDao) &#123;</span></span><br><span class="line"><span class="comment">//        this.bookDao = bookDao;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book service save ...&quot;</span>);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意:</strong></p>
<ul>
<li><code>@Autowired</code>可以写在属性上，也可也写在setter方法上，最简单的处理方式是<code>写在属性上并将setter方法删除掉</code></li>
<li>为什么setter方法可以删除呢?<ul>
<li>自动装配基于反射设计创建对象并通过<code>暴力反射</code>为私有属性进行设值</li>
<li>普通反射只能获取public修饰的内容</li>
<li>暴力反射除了获取public修饰的内容还可以获取private修改的内容</li>
<li>所以此处无需提供setter方法</li>
</ul>
</li>
</ul>
</blockquote>
<p><code>@Autowired</code>是按照类型注入，那么对应BookDao接口如果有多个实现类，比如添加BookDaoImpl2</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl2</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="注解实现按照名称注入"><a href="#注解实现按照名称注入" class="headerlink" title="注解实现按照名称注入"></a>注解实现按照名称注入</h4><p>先给两个Dao类分别起个名称</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository(&quot;bookDao&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Repository(&quot;bookDao2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl2</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...2&quot;</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>此时就可以注入成功，但是得思考个问题: </li>
<li>@Autowired是按照类型注入的，给BookDao的两个实现起了名称，它还是有两个bean对象，为什么不报错?</li>
<li>@Autowired默认按照类型自动装配，如果IOC容器中同类的Bean找到多个，就按照变量名和Bean的名称匹配。因为变量名叫<code>bookDao</code>而容器中也有一个<code>bookDao</code>，所以可以成功注入。</li>
</ul>
<p>那下面这种情况可以成功注入吗</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository(&quot;bookDao1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Repository(&quot;bookDao2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl2</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...2&quot;</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还是不行的，因为按照类型会找到多个bean对象，此时会按照<code>bookDao</code>名称去找，因为IOC容器只有名称叫<code>bookDao1</code>和<code>bookDao2</code>，所以找不到，会报<code>NoUniqueBeanDefinitionException</code></p>
<p>当根据类型在容器中找到多个bean,注入参数的属性名又和容器中bean的名称不一致，这个时候该如何解决，就需要使用到<code>@Qualifier</code>来指定注入哪个名称的bean对象。<code>@Qualifier</code>注解后的值就是需要注入的bean的名称。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;bookDao1&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book service save ...&quot;</span>);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意:@Qualifier不能独立使用，必须和@Autowired一起使用</p>
<h4 id="注解简单数据类型注入"><a href="#注解简单数据类型注入" class="headerlink" title="注解简单数据类型注入"></a>注解简单数据类型注入</h4><p>引用类型看完，简单类型注入就比较容易懂了。简单类型注入的是基本数据类型或者字符串类型，下面在<code>BookDaoImpl</code>类中添加一个<code>name</code>属性，用其进行简单类型注入</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>数据类型换了，对应的注解也要跟着换，这次使用<code>@Value</code>注解，将值写入注解的参数中就行了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;Stephen&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意数据格式要匹配，如将”abc”注入给int值，这样程序就会报错。<br>介绍完后，会有一种感觉就是这个注解好像没什么用，跟直接赋值是一个效果，还没有直接赋值简单。</p>
<h4 id="注解读取properties配置文件"><a href="#注解读取properties配置文件" class="headerlink" title="注解读取properties配置文件"></a>注解读取properties配置文件</h4><p><code>@Value</code>一般会被用在从properties配置文件中读取内容进行使用，具体如何实现?</p>
<ul>
<li><p><code>步骤一：</code>在resource下准备一个properties文件</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">name</span>=<span class="string">Stephen</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>步骤二：</code>使用注解加载properties配置文件，在配置类上添加<code>@PropertySource</code>注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.blog&quot;)</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;jdbc.properties&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>步骤三：</code>使用@Value读取配置文件中的内容</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;name&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p><strong>注意:</strong></p>
<ul>
<li><p>如果读取的properties配置文件有多个，可以使用<code>@PropertySource</code>的属性来指定多个</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PropertySource(&#123;&quot;jdbc.properties&quot;,&quot;xxx.properties&quot;&#125;)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>@PropertySource</code>注解属性中不支持使用通配符*,运行会报错</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PropertySource(&#123;&quot;*.properties&quot;&#125;)</span> <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>@PropertySource</code>注解属性中可以把<code>classpath:</code>加上,代表从当前项目的根路径找文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PropertySource(&#123;&quot;classpath:jdbc.properties&quot;&#125;)</span></span><br></pre></td></tr></table></figure></li>
</ul>
</blockquote>
<p>知识点1：<code>@Autowired</code></p>
<table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">@Autowired</th>
</tr>
</thead>
<tbody><tr>
<td align="center">类型</td>
<td align="center">属性注解 或 方法注解（了解） 或 方法形参注解（了解）</td>
</tr>
<tr>
<td align="center">位置</td>
<td align="center">属性定义上方 或 标准set方法上方 或 类set方法上方 或 方法形参前面</td>
</tr>
<tr>
<td align="center">作用</td>
<td align="center">为引用类型属性设置值</td>
</tr>
<tr>
<td align="center">属性</td>
<td align="center">required：true&#x2F;false，定义该属性是否允许为null</td>
</tr>
</tbody></table>
<p>知识点2：<code>@Qualifier</code></p>
<table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">@Qualifier</th>
</tr>
</thead>
<tbody><tr>
<td align="center">类型</td>
<td align="center">属性注解 或 方法注解（了解）</td>
</tr>
<tr>
<td align="center">位置</td>
<td align="center">属性定义上方 或 标准set方法上方 或 类set方法上方</td>
</tr>
<tr>
<td align="center">作用</td>
<td align="center">为引用类型属性指定注入的beanId</td>
</tr>
<tr>
<td align="center">属性</td>
<td align="center">value（默认）：设置注入的beanId</td>
</tr>
</tbody></table>
<p>知识点3：<code>@Value</code></p>
<table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">@Value</th>
</tr>
</thead>
<tbody><tr>
<td align="center">类型</td>
<td align="center">属性注解 或 方法注解（了解）</td>
</tr>
<tr>
<td align="center">位置</td>
<td align="center">属性定义上方 或 标准set方法上方 或 类set方法上方</td>
</tr>
<tr>
<td align="center">作用</td>
<td align="center">为 基本数据类型 或 字符串类型 属性设置值</td>
</tr>
<tr>
<td align="center">属性</td>
<td align="center">value（默认）：要注入的属性值</td>
</tr>
</tbody></table>
<p>知识点4：<code>@PropertySource</code></p>
<table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">@PropertySource</th>
</tr>
</thead>
<tbody><tr>
<td align="center">类型</td>
<td align="center">类注解</td>
</tr>
<tr>
<td align="center">位置</td>
<td align="center">类定义上方</td>
</tr>
<tr>
<td align="center">作用</td>
<td align="center">加载properties文件中的属性值</td>
</tr>
<tr>
<td align="center">属性</td>
<td align="center">value（默认）：设置加载的properties文件对应的文件名或文件名组成的数组</td>
</tr>
</tbody></table>
<h2 id="IOC-DI注解开发管理第三方bean"><a href="#IOC-DI注解开发管理第三方bean" class="headerlink" title="IOC&#x2F;DI注解开发管理第三方bean"></a>IOC&#x2F;DI注解开发管理第三方bean</h2><p>前面定义bean的时候都是在自己开发的类上面写个注解就完成了，但如果是第三方的类，这些类都是在jar包中，我们没有办法在类上面添加注解：</p>
<p>遇到上述问题，我们就需要有一种更加灵活的方式来定义bean,这种方式不能在原始代码上面书写注解，一样能定义bean,这就用到了一个全新的注解<code>@Bean</code>。</p>
<blockquote>
<p>如何创建第三方的Bean</p>
<p>答案是我们自己在<code>@Configuration</code>类中编写一个Java方法创建并返回它，注意给方法标记一个<code>@Bean</code>注解</p>
</blockquote>
<h3 id="注解开发管理第三方bean"><a href="#注解开发管理第三方bean" class="headerlink" title="注解开发管理第三方bean"></a>注解开发管理第三方bean</h3><p>在上述环境中完成对<code>Druid</code>数据源的管理，具体的实现步骤为</p>
<ul>
<li><p>步骤一：导入对应的jar包</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.16<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>步骤二：在配置类中添加一个方法，注意该方法的返回值就是要创建的Bean对象类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">DruidDataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        dataSource.setDriverClassName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        dataSource.setUrl(<span class="string">&quot;jdbc:mysql://localhost:13306/spring_db&quot;</span>);</span><br><span class="line">        dataSource.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        dataSource.setPassword(<span class="string">&quot;PASSWORD&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> dataSource;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>步骤三：在方法上添加<code>@Bean</code>注解，注解的作用是将方法的返回值作为一个Spring管理的bean对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">DruidDataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        dataSource.setDriverClassName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        dataSource.setUrl(<span class="string">&quot;jdbc:mysql://localhost:13306/spring_db&quot;</span>);</span><br><span class="line">        dataSource.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        dataSource.setPassword(<span class="string">&quot;PASSWORD&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> dataSource;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>步骤四：从IOC容器中获取对象并打印</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SpringConfig.class);</span><br><span class="line">        <span class="type">DataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> ctx.getBean(DataSource.class);</span><br><span class="line">        System.out.println(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>至此使用<code>@Bean</code>来管理第三方bean的案例就已经完成。</p>
</li>
<li><p>如果有多个bean要被Spring管理，直接在配置类中多写几个方法，方法上添加@Bean注解即可。</p>
</li>
</ul>
<h3 id="引入外部配置类"><a href="#引入外部配置类" class="headerlink" title="引入外部配置类"></a>引入外部配置类</h3><p>如果把所有的第三方bean都配置到Spring的配置类<code>SpringConfig</code>中，虽然可以，但是不利于代码阅读和分类管理，所有我们就想能不能按照类别将这些bean配置到不同的配置类中?</p>
<p>那么对于数据源的bean，我们可以把它的配置单独放倒一个<code>JdbcConfig</code>类中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">DruidDataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        dataSource.setDriverClassName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        dataSource.setUrl(<span class="string">&quot;jdbc:mysql://localhost:13306/spring_db&quot;</span>);</span><br><span class="line">        dataSource.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        dataSource.setPassword(<span class="string">&quot;PASSWORD&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> dataSource;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那现在又有了一个新问题，这个配置类如何能被Spring配置类加载到，并创建DataSource对象在IOC容器中?针对这个问题，有两个解决方案，接着往下看</p>
<h4 id="使用包扫描引入"><a href="#使用包扫描引入" class="headerlink" title="使用包扫描引入"></a>使用包扫描引入</h4><ul>
<li><p><code>步骤一：</code>在Spring的配置类上添加包扫描，注意要将JdbcConfig类放在包扫描的地址下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.blog.config&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>步骤二：</code>在JdbcConfig上添加<code>@Configuration</code>注解<br>JdbcConfig类要放入到<code>com.blog.config</code>包下，需要被Spring的配置类扫描到即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">DruidDataSource</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        ds.setDriverClassName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        ds.setUrl(<span class="string">&quot;jdbc:mysql://localhost:3306/spring_db&quot;</span>);</span><br><span class="line">        ds.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        ds.setPassword(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ds;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="使用-Import引入"><a href="#使用-Import引入" class="headerlink" title="使用@Import引入"></a>使用@Import引入</h4><p>方案一实现起来有点小复杂，Spring早就想到了这一点，于是又给我们提供了第二种方案。<br>这种方案可以不用加<code>@Configuration</code>注解，但是必须在Spring配置类上使用<code>@Import</code>注解手动引入需要加载的配置类</p>
<ul>
<li><p><code>步骤一：</code>去除JdbcConfig类上的注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">DruidDataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        dataSource.setDriverClassName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        dataSource.setUrl(<span class="string">&quot;jdbc:mysql://localhost:13306/spring_db&quot;</span>);</span><br><span class="line">        dataSource.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        dataSource.setPassword(<span class="string">&quot;PASSWORD&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> dataSource;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>步骤二：</code>在Spring配置类中引入</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import(JdbcConfig.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p><strong>注意:</strong></p>
<ul>
<li>扫描注解可以移除</li>
<li>@Import参数需要的是一个数组，可以引入多个配置类。</li>
<li>@Import注解在配置类中只能写一次</li>
</ul>
</blockquote>
<p>知识点1：<code>@Bean</code></p>
<table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">@Bean</th>
</tr>
</thead>
<tbody><tr>
<td align="center">类型</td>
<td align="center">方法注解</td>
</tr>
<tr>
<td align="center">位置</td>
<td align="center">方法定义上方</td>
</tr>
<tr>
<td align="center">作用</td>
<td align="center">设置该方法的返回值作为spring管理的bean</td>
</tr>
<tr>
<td align="center">属性</td>
<td align="center">value（默认）：定义bean的id</td>
</tr>
</tbody></table>
<p>知识点2：<code>@Import</code></p>
<table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">@Import</th>
</tr>
</thead>
<tbody><tr>
<td align="center">类型</td>
<td align="center">类注解</td>
</tr>
<tr>
<td align="center">位置</td>
<td align="center">类定义上方</td>
</tr>
<tr>
<td align="center">作用</td>
<td align="center">导入配置类</td>
</tr>
<tr>
<td align="center">属性</td>
<td align="center">value（默认）：定义导入的配置类类名， 当配置类有多个时使用数组格式一次性导入多个配置类</td>
</tr>
</tbody></table>
<h3 id="注解开发实现为第三方bean注入资源"><a href="#注解开发实现为第三方bean注入资源" class="headerlink" title="注解开发实现为第三方bean注入资源"></a>注解开发实现为第三方bean注入资源</h3><p>在使用@Bean创建bean对象的时候，如果方法在创建的过程中需要其他资源该怎么办?</p>
<p>这些资源会有两大类，分别是<code>简单数据类型</code> 和<code>引用数据类型</code>。</p>
<h4 id="简单数据类型"><a href="#简单数据类型" class="headerlink" title="简单数据类型"></a>简单数据类型</h4><p>对于下面代码关于数据库的四要素不应该写死在代码中，应该是从properties配置文件中读取。如何来优化下面的代码?</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">DruidDataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        dataSource.setDriverClassName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        dataSource.setUrl(<span class="string">&quot;jdbc:mysql://localhost:13306/spring_db&quot;</span>);</span><br><span class="line">        dataSource.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        dataSource.setPassword(<span class="string">&quot;PASSWORD&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> dataSource;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>步骤一：</code>提供对应的四个属性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String driver;</span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">DruidDataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        dataSource.setDriverClassName(driver);</span><br><span class="line">        dataSource.setUrl(url);</span><br><span class="line">        dataSource.setUsername(username);</span><br><span class="line">        dataSource.setPassword(password);</span><br><span class="line">        <span class="keyword">return</span> dataSource;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>步骤二：</code>使用<code>@Value</code>注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;com.mysql.jdbc.Driver&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String driver;</span><br><span class="line">    <span class="meta">@Value(&quot;jdbc:mysql://localhost:13306/spring_db&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="meta">@Value(&quot;root&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="meta">@Value(&quot;PASSWORD&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">DruidDataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        dataSource.setDriverClassName(driver);</span><br><span class="line">        dataSource.setUrl(url);</span><br><span class="line">        dataSource.setUsername(username);</span><br><span class="line">        dataSource.setPassword(password);</span><br><span class="line">        <span class="keyword">return</span> dataSource;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>扩展<br>现在的数据库连接四要素还是写在代码中，需要做的是将这些内容提取到jdbc.properties配置文件，在上面我们已经实现过了，这里再来复习一遍</p>
</li>
</ul>
<ol>
<li><p>resources目录下添加jdbc.properties</p>
</li>
<li><p>配置文件中提供四个键值对分别是数据库的四要素</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">jdbc.driver</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">jdbc.url</span>=<span class="string">jdbc:mysql://localhost:13306/spring_db</span></span><br><span class="line"><span class="attr">jdbc.username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">jdbc.password</span>=<span class="string">PASSWORD.</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用@PropertySource加载jdbc.properties配置文件</p>
</li>
<li><p>修改@Value注解属性的值，将其修改为<code>$&#123;key&#125;</code>，key就是键值对中的键的值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PropertySource(&quot;jdbc.properties&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.driver&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String driver;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.url&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.username&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.password&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">DruidDataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        dataSource.setDriverClassName(driver);</span><br><span class="line">        dataSource.setUrl(url);</span><br><span class="line">        dataSource.setUsername(username);</span><br><span class="line">        dataSource.setPassword(password);</span><br><span class="line">        <span class="keyword">return</span> dataSource;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h4><p>假设在构建DataSource对象的时候，需要用到BookDao对象，该如何把BookDao对象注入进方法内让其使用呢?</p>
<ul>
<li><p><code>步骤一：</code>在SpringConfig中扫描BookDao<br>扫描的目的是让Spring能管理到BookDao，也就是要让IOC容器中有一个BookDao对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.blog.dao&quot;)</span></span><br><span class="line"><span class="meta">@Import(JdbcConfig.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>步骤二：</code>在JdbcConfig类  的方法上添加参数<br>引用类型注入只需要为bean定义方法设置形参即可，容器会<code>根据类型</code>自动装配对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">(BookDao bookDao)</span> &#123;</span><br><span class="line">    bookDao.save();</span><br><span class="line">    <span class="type">DruidDataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">    dataSource.setDriverClassName(driver);</span><br><span class="line">    dataSource.setUrl(url);</span><br><span class="line">    dataSource.setUsername(username);</span><br><span class="line">    dataSource.setPassword(password);</span><br><span class="line">    <span class="keyword">return</span> dataSource;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="注解开发总结"><a href="#注解开发总结" class="headerlink" title="注解开发总结"></a>注解开发总结</h2><img src="image-20241117143708520.png" class title="image-20241117143708520">

<h2 id="Spring整合"><a href="#Spring整合" class="headerlink" title="Spring整合"></a>Spring整合</h2><p>最终整合过后整个项目结构：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">├── pom.xml</span><br><span class="line">└── src</span><br><span class="line">    └── main</span><br><span class="line">        ├── java</span><br><span class="line">        │   ├── App.java</span><br><span class="line">        │   ├── App2.java</span><br><span class="line">        │   └── com</span><br><span class="line">        │       └── itheima</span><br><span class="line">        │           ├── config</span><br><span class="line">        │           │   ├── JdbcConfig.java</span><br><span class="line">        │           │   ├── MybatisConfig.java</span><br><span class="line">        │           │   └── SpringConfig.java</span><br><span class="line">        │           ├── domain</span><br><span class="line">        │           │   └── Account.java</span><br><span class="line">        │           ├── mapper</span><br><span class="line">        │           │   └── AccountMapper.java</span><br><span class="line">        │           └── service</span><br><span class="line">        │               ├── AccountService.java</span><br><span class="line">        │               └── impl</span><br><span class="line">        │                   └── AccountServiceImpl.java</span><br><span class="line">        └── resources</span><br><span class="line">            ├── SqlMapConfig.xml.bak</span><br><span class="line">            └── jdbc.properties</span><br></pre></td></tr></table></figure>

<h3 id="MyBatis背景"><a href="#MyBatis背景" class="headerlink" title="MyBatis背景"></a>MyBatis背景</h3><ul>
<li><p>步骤一：准备数据库表，MyBatis是用来操作数据库表的，所以我们先来创建库和表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> database spring_db <span class="type">character</span> <span class="keyword">set</span> utf8;</span><br><span class="line">use spring_db;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tbl_account(</span><br><span class="line">    id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">    name <span class="type">varchar</span>(<span class="number">35</span>),</span><br><span class="line">    money <span class="keyword">double</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tbl_account(`name`,money) <span class="keyword">VALUES</span></span><br><span class="line">(<span class="string">&#x27;Tom&#x27;</span>,<span class="number">2800</span>),</span><br><span class="line">(<span class="string">&#x27;Jerry&#x27;</span>,<span class="number">3000</span>),</span><br><span class="line">(<span class="string">&#x27;Jhon&#x27;</span>,<span class="number">3100</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>导入依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.1.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.16<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.28<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>步骤三：根据表创建模型类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Account</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Double money;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Double <span class="title function_">getMoney</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMoney</span><span class="params">(Double money)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.money = money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Account&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, money=&quot;</span> + money +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>步骤四：创建Mapper接口，一般是要配置一个对应的xml文件，不过这里没涉及到复杂的sql语句，所以没配置xml文件，采用注解开发）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.mapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.itheima.domain.Account;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AccountMapper</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Insert(&quot;insert into tbl_account(name,money)values(#&#123;name&#125;,#&#123;money&#125;)&quot;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(Account account)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Delete(&quot;delete from tbl_account where id = #&#123;id&#125; &quot;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(Integer id)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Update(&quot;update tbl_account set name = #&#123;name&#125; , money = #&#123;money&#125; where id = #&#123;id&#125; &quot;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Account account)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Select(&quot;select * from tbl_account&quot;)</span></span><br><span class="line">    List&lt;Account&gt; <span class="title function_">findAll</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Select(&quot;select * from tbl_account where id = #&#123;id&#125; &quot;)</span></span><br><span class="line">    Account <span class="title function_">findById</span><span class="params">(Integer id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>步骤五：创建Service接口和实现类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AccountService</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(Account account)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(Integer id)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Account account)</span>;</span><br><span class="line"></span><br><span class="line">    List&lt;Account&gt; <span class="title function_">findAll</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    Account <span class="title function_">findById</span><span class="params">(Integer id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.itheima.mapper.AccountMapper;</span><br><span class="line"><span class="keyword">import</span> com.itheima.domain.Account;</span><br><span class="line"><span class="keyword">import</span> com.itheima.service.AccountService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">AccountService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountMapper accountMapper;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(Account account)</span> &#123;</span><br><span class="line">        accountMapper.save(account);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Account account)</span>&#123;</span><br><span class="line">        accountMapper.update(account);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        accountMapper.delete(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Account <span class="title function_">findById</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> accountMapper.findById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;Account&gt; <span class="title function_">findAll</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> accountMapper.findAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>步骤六：添加jdbc.properties文件</li>
</ul>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">jdbc.driver</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">jdbc.url</span>=<span class="string">jdbc:mysql://localhost:13306/spring_db</span></span><br><span class="line"><span class="attr">jdbc.username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">jdbc.password</span>=<span class="string">PASSWORD.</span></span><br></pre></td></tr></table></figure>

<ul>
<li>步骤七：添加Mybatis核心配置文件</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--读取外部properties配置文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">&quot;jdbc.properties&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--别名扫描的包路径--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.blog.domain&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--数据源--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;mysql&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;mysql&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">transactionManager</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--映射文件扫描包路径--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.blog.mapper&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">package</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>步骤八：编写应用程序</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.itheima.mapper.AccountMapper;</span><br><span class="line"><span class="keyword">import</span> com.itheima.domain.Account;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.io.Resources;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSession;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactoryBuilder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 1. 创建SqlSessionFactoryBuilder对象</span></span><br><span class="line">        <span class="type">SqlSessionFactoryBuilder</span> <span class="variable">sqlSessionFactoryBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>();</span><br><span class="line">        <span class="comment">// 2. 加载SqlMapConfig.xml配置文件</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getResourceAsStream(<span class="string">&quot;SqlMapConfig.xml.bak&quot;</span>);</span><br><span class="line">        <span class="comment">// 3. 创建SqlSessionFactory对象</span></span><br><span class="line">        <span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> sqlSessionFactoryBuilder.build(inputStream);</span><br><span class="line">        <span class="comment">// 4. 获取SqlSession</span></span><br><span class="line">        <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br><span class="line">        <span class="comment">// 5. 执行SqlSession对象执行查询，获取结果User</span></span><br><span class="line">        <span class="type">AccountMapper</span> <span class="variable">accountMapper</span> <span class="operator">=</span> sqlSession.getMapper(AccountMapper.class);</span><br><span class="line"></span><br><span class="line">        <span class="type">Account</span> <span class="variable">ac</span> <span class="operator">=</span> accountMapper.findById(<span class="number">2</span>);</span><br><span class="line">        System.out.println(ac);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6. 释放资源</span></span><br><span class="line">        sqlSession.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Spring整合MyBatis"><a href="#Spring整合MyBatis" class="headerlink" title="Spring整合MyBatis"></a>Spring整合MyBatis</h3><p>Mybatis的基础环境我们已经准备好了，接下来就得分析下在上述的内容中，哪些对象可以交给Spring来管理?</p>
<ul>
<li>Mybatis程序核心对象分析<br>从图中可以获取到，真正需要交给Spring管理的是SqlSessionFactory</li>
</ul>
<img src="8918862fj00rji77m0039d0014r00htp.jpg" class title="img">

<ul>
<li>整合Mybatis，就是将Mybatis用到的内容交给Spring管理，分析下配置文件</li>
</ul>
<img src="1b6084dfj00rji77m003id0017p00lfp-20241204145743151.jpg" class title="img">

<blockquote>
<p>说明:</p>
<ul>
<li>第一部分读取外部properties配置文件，Spring有提供具体的解决方案<code>@PropertySource</code>,需要交给Spring</li>
<li>第二部分起别名包扫描，为SqlSessionFactory服务的，需要交给Spring</li>
<li>第三部分主要用于做连接池，Spring之前我们已经整合了Druid连接池，这块也需要交给Spring</li>
<li>前面三部分一起都是为了创建SqlSession对象用的，那么用Spring管理SqlSession对象吗?回忆下SqlSession是由SqlSessionFactory创建出来的，所以只需要将SqlSessionFactory交给Spring管理即可。</li>
<li>第四部分是Mapper接口和映射文件[如果使用注解就没有该映射文件]，这个是在获取到SqlSession以后执行具体操作的时候用，所以它和SqlSessionFactory创建的时机都不在同一个时间，可能需要单独管理。</li>
</ul>
</blockquote>
<h3 id="整合步骤"><a href="#整合步骤" class="headerlink" title="整合步骤"></a>整合步骤</h3><p>前面我们已经分析了Spring与Mybatis的整合，大体需要做两件事，</p>
<ul>
<li>第一件事是：Spring要管理MyBatis中的SqlSessionFactory</li>
<li>第二件事是：Spring要管理Mapper接口的扫描</li>
</ul>
<h4 id="Spring管理MyBatis中的SqlSessionFactory"><a href="#Spring管理MyBatis中的SqlSessionFactory" class="headerlink" title="Spring管理MyBatis中的SqlSessionFactory"></a>Spring管理MyBatis中的SqlSessionFactory</h4><ul>
<li>步骤一：项目中导入整合需要的jar包</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>步骤二：创建Spring的主配置类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//配置类注解</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">//包扫描，主要扫描的是项目中的AccountServiceImpl类</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.blog&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>步骤三：创建数据源的配置类，在配置类中完成数据源的创建</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.druid.pool.DruidDataSource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.driver&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String driver;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.url&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.username&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.password&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">DruidDataSource</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        ds.setDriverClassName(driver);</span><br><span class="line">        ds.setUrl(url);</span><br><span class="line">        ds.setUsername(userName);</span><br><span class="line">        ds.setPassword(password);</span><br><span class="line">        <span class="keyword">return</span> ds;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>步骤五：创建Mybatis配置类并配置SqlSessionFactory</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.mybatis.spring.SqlSessionFactoryBean;</span><br><span class="line"><span class="keyword">import</span> org.mybatis.spring.mapper.MapperScannerConfigurer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisConfig</span> &#123;</span><br><span class="line">    <span class="comment">//定义bean，SqlSessionFactoryBean，用于产生SqlSessionFactory对象</span></span><br><span class="line">		<span class="comment">//扫描类型别名</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SqlSessionFactoryBean <span class="title function_">sqlSessionFactory</span><span class="params">(DataSource dataSource)</span>&#123;</span><br><span class="line">        <span class="type">SqlSessionFactoryBean</span> <span class="variable">ssfb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBean</span>();</span><br><span class="line">        ssfb.setTypeAliasesPackage(<span class="string">&quot;com.itheima.domain&quot;</span>);<span class="comment">// 纯注解开发可以注释掉</span></span><br><span class="line">        ssfb.setDataSource(dataSource);</span><br><span class="line">        <span class="keyword">return</span> ssfb;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//定义bean，返回MapperScannerConfigurer对象</span></span><br><span class="line">		<span class="comment">//扫描映射</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MapperScannerConfigurer <span class="title function_">mapperScannerConfigurer</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">MapperScannerConfigurer</span> <span class="variable">msc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MapperScannerConfigurer</span>();</span><br><span class="line">        msc.setBasePackage(<span class="string">&quot;com.itheima.mapper&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> msc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DataSource dataSource可以写成</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> SqlSessionFactoryBean <span class="title function_">sqlSessionFactory</span><span class="params">(<span class="meta">@Autowired</span> DataSource dataSource)</span></span><br></pre></td></tr></table></figure>

<p>在 Spring 中，参数注入的推荐方式是<strong>通过方法参数直接注入</strong>，Spring 会根据类型自动匹配，因此你可以简化为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> SqlSessionFactoryBean <span class="title function_">sqlSessionFactory</span><span class="params">(DataSource dataSource)</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>说明：</p>
<ul>
<li><p>使用SqlSessionFactoryBean封装SqlSessionFactory需要的环境信息</p>
<img src="3f688a04j00rji77m0033d0014c00jap.jpg" class title="img">
</li>
<li><p>SqlSessionFactoryBean是前面我们讲解FactoryBean的一个子类，在该类中将SqlSessionFactory的创建进行了封装，简化对象的创建，我们只需要将其需要的内容设置即可。</p>
</li>
<li><p>方法中有一个参数为dataSource,当前Spring容器中已经创建了Druid数据源，类型刚好是DataSource类型，此时在初始化SqlSessionFactoryBean这个对象的时候，发现需要使用DataSource对象，而容器中刚好有这么一个对象，就自动加载了DruidDataSource对象。</p>
</li>
<li><p><code>sqlSessionFactory.setTypeAliasesPackage(&quot;com.blog.domain&quot;);</code>，替换掉配置文件中的</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.blog.domain&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>sqlSessionFactory.setDataSource(dataSource);</code>，替换掉配置文件中的</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;mysql&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;mysql&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">transactionManager</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用MapperScannerConfigurer加载Mapper接口，创建代理对象保存到IOC容器中:</p>
<img src="3d8e9153j00rji77m002td0014l00g0p.jpg" class title="img">

<ul>
<li>这个MapperScannerConfigurer对象也是MyBatis提供的专用于整合的jar包中的类，用来处理原始配置文件中的mappers相关配置，加载数据层的Mapper接口类</li>
<li>MapperScannerConfigurer有一个核心属性basePackage，就是用来设置所扫描的包路径</li>
</ul>
</li>
</ul>
</blockquote>
<ul>
<li>步骤六：主配置类中引入Mybatis配置类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.blog&quot;)</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;jdbc.properties&quot;)</span></span><br><span class="line"><span class="meta">@Import(&#123;JdbcConfig.class, MyBatisConfig.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>步骤七：编写运行类<br>在运行类中，从IOC容器中获取Service对象，调用方法获取结果</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SpringConfig.class);</span><br><span class="line">        <span class="type">AccountService</span> <span class="variable">accountService</span> <span class="operator">=</span> context.getBean(AccountService.class);</span><br><span class="line">        <span class="type">Account</span> <span class="variable">account</span> <span class="operator">=</span> accountService.findById(<span class="number">1</span>);</span><br><span class="line">        System.out.println(account);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>后端开发</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac相关问题</title>
    <url>/macEnvironment/</url>
    <content><![CDATA[<h1 id="mac上安装多版本JDK，并解决-zshrc-export不生效的问题"><a href="#mac上安装多版本JDK，并解决-zshrc-export不生效的问题" class="headerlink" title="mac上安装多版本JDK，并解决.zshrc export不生效的问题"></a>mac上安装多版本JDK，并解决.zshrc export不生效的问题</h1><p><a href="https://blog.csdn.net/yb2020/article/details/128343187">https://blog.csdn.net/yb2020/article/details/128343187</a></p>
<h1 id="markdown转word"><a href="#markdown转word" class="headerlink" title="markdown转word"></a>markdown转word</h1><p>使用Pandac将markdown转换为word<br>对于其中的公式：在word使用 control +&#x3D; 划取对应的latex公式</p>
<img src="image-20241203203339053.png" class title="image-20241203203339053">

<p>选中latex格式进行转换，可以先划取所有的latex公式，全部转换。</p>
]]></content>
  </entry>
  <entry>
    <title>React入门</title>
    <url>/react-guide/</url>
    <content><![CDATA[<h1 id="JSX"><a href="#JSX" class="headerlink" title="JSX"></a>JSX</h1><p>JSX是JavaScript和XML（HTML）的缩写，表示在<font color="red">JS代码中编写HTML模版结构</font>，它是React编写UI的方式。</p>


<p>JSX并不是标准的JS语法，它是JS的语法扩展，浏览器本身不能识别，需要通过解析工具做解析之后才能在浏览器中运行。</p>
<p>在JSX中可以通过<font color="red">大括号语法{}</font>识别JavaScript中的表达式，比如常见的变量，方法的调用等。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  项目的根组件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> num = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">func1</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;func1&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>  =<span class="string">&quot;App&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      this is react App</span></span><br><span class="line"><span class="language-xml">      &#123;/* 1.使用引号传递字符串 */&#125;</span></span><br><span class="line"><span class="language-xml">      &#123;&#x27;this is message&#x27;&#125;</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">      &#123;/* 2.识别JavaScript变量 */&#125;</span></span><br><span class="line"><span class="language-xml">      &#123;num&#125;</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">      &#123;/* 3.函数调用/方法调用 */&#125;</span></span><br><span class="line"><span class="language-xml">      &#123;func1()&#125;</span></span><br><span class="line"><span class="language-xml">      &#123;new Date().getDate()&#125;</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">      &#123;/* 4.使用js对象 */&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;&#123;color:</span>&#x27;<span class="attr">red</span>&#x27;&#125;&#125;&gt;</span> this is div <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span>;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>注意：if语句、switch语句、变量声明属于语句，不是表达式，不能出现在{}中。</p>
<h2 id="JSX实现列表渲染"><a href="#JSX实现列表渲染" class="headerlink" title="JSX实现列表渲染"></a>JSX实现列表渲染</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  项目的根组件</span></span><br><span class="line"><span class="keyword">const</span> list1 = [</span><br><span class="line">  &#123;<span class="attr">id</span>:<span class="number">1001</span>,<span class="attr">name</span>:<span class="string">&#x27;sza&#x27;</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">id</span>:<span class="number">1002</span>,<span class="attr">name</span>:<span class="string">&#x27;myx&#x27;</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">id</span>:<span class="number">1003</span>,<span class="attr">name</span>:<span class="string">&#x27;mjm&#x27;</span>&#125;</span><br><span class="line">];</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>  =<span class="string">&quot;App&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      this is react App</span></span><br><span class="line"><span class="language-xml">      &#123;/* 渲染列表 */&#125;</span></span><br><span class="line"><span class="language-xml">      &#123;/* 数组映射（.map()方法）：list1.map(item =&gt;...) 对数组 list1 中的每个元素执行一个回调函数 */&#125;</span></span><br><span class="line"><span class="language-xml">      &#123;/* 对于 list1 中的每个 item（对象），回调函数会返回一个 JSX 元素 */&#125;</span></span><br><span class="line"><span class="language-xml">      &#123;/* 注意：在 React 中，当渲染列表时，</span></span><br><span class="line"><span class="language-xml">      为每个列表项设置一个唯一的 key 属性是很重要的，它有助于 React 更高效地更新和渲染列表。 */&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;list1.map(item =&gt; <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;item.id&#125;</span>&gt;</span> &#123;item.name&#125; <span class="tag">&lt;/<span class="name">li</span>&gt;</span>)&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span>;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<h2 id="JSX实现条件渲染"><a href="#JSX实现条件渲染" class="headerlink" title="JSX实现条件渲染"></a>JSX实现条件渲染</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  项目的根组件</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> isLogin = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>  =<span class="string">&quot;App&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;/* 逻辑与 &amp;&amp;  */&#125;</span></span><br><span class="line"><span class="language-xml">      &#123;isLogin &amp;&amp; <span class="tag">&lt;<span class="name">span</span>&gt;</span>Welcome xxx!<span class="tag">&lt;/<span class="name">span</span>&gt;</span>&#125;</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">      &#123;/* 三元运算 */&#125;</span></span><br><span class="line"><span class="language-xml">      &#123;isLogin ? <span class="tag">&lt;<span class="name">span</span>&gt;</span>Welcome xxx!<span class="tag">&lt;/<span class="name">span</span>&gt;</span> : <span class="tag">&lt;<span class="name">span</span>&gt;</span>Error!<span class="tag">&lt;/<span class="name">span</span>&gt;</span>&#125;</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span>;</span><br></pre></td></tr></table></figure>

<p>复杂条件渲染，自定义函数+条件语句：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  项目的根组件</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 文章列表 分为 无图、单图以及多图 =&gt; 0 1 2</span></span><br><span class="line"><span class="keyword">const</span> articleType = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">func</span>(<span class="params">articleType</span>)&#123;</span><br><span class="line">  <span class="keyword">if</span> (articleType === <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>无图文章<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span>;</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span> (articleType === <span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>单图文章<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span>;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>多图文章<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>  =<span class="string">&quot;App&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;func(articleType)&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span>;</span><br></pre></td></tr></table></figure>

<h3 id="React事件绑定"><a href="#React事件绑定" class="headerlink" title="React事件绑定"></a>React事件绑定</h3><p>基础事件绑定，语法：on + 事件名称 &#x3D; {事件处理程序}</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  项目的根组件</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">handleClick</span> = (<span class="params"></span>)=&gt;&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;被点击了&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>  =<span class="string">&quot;App&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;handleClick&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span>;</span><br></pre></td></tr></table></figure>

<p>使用事件对象参数，将事件对象作为实参传入</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  项目的根组件</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">handleClick</span> = (<span class="params">e</span>)=&gt;&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;被点击了&quot;</span>,e);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>  =<span class="string">&quot;App&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;handleClick&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span>;</span><br></pre></td></tr></table></figure>



<p>传递自定义参数，语法：事件绑定的位置改造成<font color="red">箭头函数的写法</font>，在执行handleClick实际业务函数的时候传递实参。注意：不能直接写成函数调用，因为这里的事件绑定需要的是一个<font color="red">函数引用!</font>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  项目的根组件</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">handleClick</span> = (<span class="params">name</span>)=&gt;&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;被点击了&quot;</span>,name);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>  =<span class="string">&quot;App&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> handleClick(&quot;jack&quot;)&#125; &gt;<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span>;</span><br></pre></td></tr></table></figure>

<p>如果写成：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;button onClick=&#123;<span class="title function_">handleClick</span>(<span class="string">&quot;jack&quot;</span>)&#125; &gt;&lt;/button&gt;</span><br></pre></td></tr></table></figure>

<p>在这种方式下，<code>handleClick(&quot;jack&quot;)</code>会在组件渲染时立即被调用，而不是在按钮被点击时调用。</p>
<p>传递事件对象参数以及自定义参数：</p>
<p>语法，在事件绑定的位置传递事件实参e和自定义参数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  项目的根组件</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">handleClick</span> = (<span class="params">name,e</span>)=&gt;&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;被点击了&quot;</span>,name,e);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> name1 = <span class="string">&#x27;sza&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>  =<span class="string">&quot;App&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;(e)</span> =&gt;</span> handleClick(name1,e)&#125; &gt;<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span>;</span><br></pre></td></tr></table></figure>

<h2 id="React组件"><a href="#React组件" class="headerlink" title="React组件"></a>React组件</h2><p>一个组件就是用户界面的一部分，它可以有自己的逻辑和外观，组件之间可以互相嵌套，也可以复用多次。</p>
<p>组件化开发可以让开发者像搭积木一样构建一个完整的庞大的应用。</p>
<p>在React中，一个组件就是<font color="red">首字母大写的函数</font>，内部存放了组件的逻辑和视图UI，渲染组件只需要把组件当成标签书写即可。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  项目的根组件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义组件</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Button</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="comment">//组件内部逻辑</span></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">button</span>&gt;</span> click me!<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>  =<span class="string">&quot;App&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;/* 自闭合使用自定义组件 */&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Button</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">      &#123;/* 成对标签 使用自定义组件 */&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Button</span>&gt;</span><span class="tag">&lt;/<span class="name">Button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      </span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span>;</span><br></pre></td></tr></table></figure>

<h2 id="useState基础使用"><a href="#useState基础使用" class="headerlink" title="useState基础使用"></a>useState基础使用</h2><p>useState是一个React Hook函数，它允许我们向组件添加一个<font color="red">状态变量</font>，从而控制影响组件的渲染结果</p>
<p>本质：和普通JS变量不同的是，状态变量一旦发生变化，组件的视图UI也会跟着变化（<font color="red">数据驱动视图</font>）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  项目的根组件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123;useState&#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 1. useState是一个函数，返回值是一个数组</span></span><br><span class="line">  <span class="comment">// 2. 数组中的第一个参数是状态变量，第二个参数是set函数用来修改状态变量</span></span><br><span class="line">  <span class="comment">// 3. useState的参数将作为count的初始值</span></span><br><span class="line">  <span class="keyword">const</span> [count , setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 点击事件回调</span></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">handleClick</span> = (<span class="params"></span>) =&gt;&#123;</span><br><span class="line">    <span class="comment">// 作用：1. 用新传入的数值修改count</span></span><br><span class="line">    <span class="comment">//  2。重新使用新的count渲染UI</span></span><br><span class="line">    <span class="title function_">setCount</span>(count + <span class="number">1</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>  =<span class="string">&quot;App&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;handleClick&#125;</span>&gt;</span>&#123;count&#125;<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      </span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span>;</span><br></pre></td></tr></table></figure>

<p>useState的状态变量不可变：</p>
<p>在React中，状态被认为是只读的，我们应该始终替换它而不是修改它，直接修改状态变量，不能够引发试图更新</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">handleClick</span> = (<span class="params"></span>) =&gt;&#123;</span><br><span class="line">  <span class="comment">// 作用：1. 用新传入的数值修改count</span></span><br><span class="line">  <span class="comment">//  2。重新使用新的count渲染UI</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这里直接对count进行修改 无法引发视图更新</span></span><br><span class="line">  count++;</span><br><span class="line">  <span class="comment">// setCount(count + 1);</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>修改复杂对象状态：</p>
<p>对于对象类型的状态变量，应该始终传给set方法一个<font color="red">全新的对象</font>来进行修改。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  项目的根组件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123;useState&#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> [form,setForm] = <span class="title function_">useState</span>(&#123;<span class="attr">name</span>:<span class="string">&#x27;jack&#x27;</span>&#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// &#123;...form, name: &#x27;sza&#x27; &#125;使用了扩展运算符（...）来复制现有的form对象，</span></span><br><span class="line">  <span class="comment">// 并在新对象中更新name属性为sza</span></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">handleClick</span> = (<span class="params"></span>) =&gt;&#123;</span><br><span class="line">    <span class="title function_">setForm</span>(&#123;</span><br><span class="line">      ...form,</span><br><span class="line">      <span class="attr">name</span>:<span class="string">&#x27;sza&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>  =<span class="string">&quot;App&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;handleClick&#125;</span>&gt;</span>&#123;form.name&#125;<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      </span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span>;</span><br></pre></td></tr></table></figure>

<h2 id="基础样式控制"><a href="#基础样式控制" class="headerlink" title="基础样式控制"></a>基础样式控制</h2><p>行内样式（不推荐）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  项目的根组件</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>  =<span class="string">&quot;App&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&#123;&#123;color:</span>&#x27;<span class="attr">red</span>&#x27;,<span class="attr">fontSize:</span>&#x27;<span class="attr">50px</span>&#x27;&#125;&#125;&gt;</span>行内样式1<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      </span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  项目的根组件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> style1 = &#123;</span><br><span class="line">  <span class="attr">color</span>:<span class="string">&#x27;red&#x27;</span>,</span><br><span class="line">  <span class="attr">fontSize</span>:<span class="string">&#x27;30px&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>  =<span class="string">&quot;App&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&#123;style1&#125;</span>&gt;</span>行内样式2<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    </span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span>;</span><br></pre></td></tr></table></figure>

<p>class类名控制</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* index.css */</span></span><br><span class="line">.<span class="property">foo</span>&#123;</span><br><span class="line">    <span class="attr">color</span>:red;</span><br><span class="line">    font-<span class="attr">size</span>:16px</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  项目的根组件</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./index.css&#x27;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>  =<span class="string">&quot;App&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">className</span>=<span class="string">&#x27;foo&#x27;</span>&gt;</span>行内样式2<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    </span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span>;</span><br></pre></td></tr></table></figure>

<h1 id="Day1-评论案例"><a href="#Day1-评论案例" class="headerlink" title="Day1 评论案例"></a>Day1 评论案例</h1><p>评论列表数据和当前登录用户数据</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 评论列表数据</span></span><br><span class="line"><span class="keyword">const</span> defaultList = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">rpid</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="attr">user</span>: &#123;</span><br><span class="line">      <span class="attr">uid</span>: <span class="string">&#x27;13258165&#x27;</span>,</span><br><span class="line">      <span class="attr">avatar</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">      <span class="attr">uname</span>: <span class="string">&#x27;周杰伦&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">content</span>: <span class="string">&#x27;哎哟，不错哦&#x27;</span>,</span><br><span class="line">    <span class="attr">ctime</span>: <span class="string">&#x27;10-18 08:15&#x27;</span>,</span><br><span class="line">    <span class="attr">like</span>: <span class="number">89</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">rpid</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">user</span>: &#123;</span><br><span class="line">      <span class="attr">uid</span>: <span class="string">&#x27;36080105&#x27;</span>,</span><br><span class="line">      <span class="attr">avatar</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">      <span class="attr">uname</span>: <span class="string">&#x27;许嵩&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">content</span>: <span class="string">&#x27;我寻你千百度 日出到迟暮&#x27;</span>,</span><br><span class="line">    <span class="attr">ctime</span>: <span class="string">&#x27;11-13 11:29&#x27;</span>,</span><br><span class="line">    <span class="attr">like</span>: <span class="number">88</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">rpid</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">user</span>: &#123;</span><br><span class="line">      <span class="attr">uid</span>: <span class="string">&#x27;30009257&#x27;</span>,</span><br><span class="line">      avatar,</span><br><span class="line">      <span class="attr">uname</span>: <span class="string">&#x27;前端&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">content</span>: <span class="string">&#x27;学前端就&#x27;</span>,</span><br><span class="line">    <span class="attr">ctime</span>: <span class="string">&#x27;10-19 09:00&#x27;</span>,</span><br><span class="line">    <span class="attr">like</span>: <span class="number">66</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br><span class="line"><span class="comment">// 当前登录用户信息</span></span><br><span class="line"><span class="keyword">const</span> loginUser = &#123;</span><br><span class="line">  <span class="comment">// 用户id</span></span><br><span class="line">  <span class="attr">uid</span>: <span class="string">&#x27;30009257&#x27;</span>,</span><br><span class="line">  <span class="comment">// 用户头像</span></span><br><span class="line">  avatar,</span><br><span class="line">  <span class="comment">// 用户昵称</span></span><br><span class="line">  <span class="attr">uname</span>: <span class="string">&#x27;黑马前端&#x27;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="渲染评论列表"><a href="#渲染评论列表" class="headerlink" title="渲染评论列表"></a>渲染评论列表</h2><p>核心思路：</p>
<ul>
<li>使用useState维护评论列表</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 使用useState维护屏幕列表</span></span><br><span class="line"><span class="keyword">const</span> [commentList , setContentList] = <span class="title function_">useState</span>(defaultList)</span><br></pre></td></tr></table></figure>

<ul>
<li>使用<font color="yellow">map方法</font>对列表数据进行遍历渲染（别忘了加key）</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&#123;<span class="comment">/* 评论项 */</span>&#125;  </span><br><span class="line">&#123;<span class="comment">/* 2. 使用map方法对数据列表进行遍历渲染 */</span>&#125;</span><br><span class="line">&#123;commentList.<span class="title function_">map</span>(<span class="function"><span class="params">item</span> =&gt;</span> (</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;reply-item&quot;</span> <span class="attr">key</span>=<span class="string">&#123;item.rpid&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">    &#123;/* 头像 */&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;root-reply-avatar&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;bili-avatar&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">className</span>=<span class="string">&quot;bili-avatar-img&quot;</span> <span class="attr">src</span>=<span class="string">&#123;item.user.avatar&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;content-wrap&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;user-info&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;user-name&quot;</span>&gt;</span>&#123;item.user.uname&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;root-reply&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">className</span>=<span class="string">&quot;reply-content&quot;</span>&gt;</span>&#123;item.content&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;reply-info&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">span</span> <span class="attr">className</span>=<span class="string">&quot;reply-time&quot;</span>&gt;</span>&#123;item.ctime&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">span</span> <span class="attr">className</span>=<span class="string">&quot;reply-time&quot;</span>&gt;</span>点赞数:&#123;item.like&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  </span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  </span><br><span class="line">))&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实现评论删除"><a href="#实现评论删除" class="headerlink" title="实现评论删除"></a>实现评论删除</h2><p>需求：</p>
<ol>
<li>只有自己的评论才可以显示删除按钮</li>
<li>点击删除按钮，删除当前评论，列表中不再显示</li>
</ol>
<p>核心思路</p>
<ul>
<li>删除显示 &#x3D;&gt; 条件渲染</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;item.<span class="property">user</span>.<span class="property">uid</span> === loginUser.<span class="property">uid</span> &amp;&amp; (</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">className</span>=<span class="string">&#x27;delete-btn&#x27;</span>&gt;</span>删除<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line">)&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>删除功能 &#x3D;&gt; 拿到当前项id，以id为条件对评论列表做filter过滤</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;item.<span class="property">user</span>.<span class="property">uid</span> === loginUser.<span class="property">uid</span> &amp;&amp; (</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">className</span>=<span class="string">&#x27;delete-btn&#x27;</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span>handleDel(item.user.uid)&#125;&gt;删除<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line">)&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [commentList , setContentList] = <span class="title function_">useState</span>(defaultList)  </span><br><span class="line"><span class="keyword">const</span> <span class="title function_">handleDel</span> = (<span class="params">user_id</span>) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 对commentList做过滤处理</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    filter()方法的作用：</span></span><br><span class="line"><span class="comment">    在 JavaScript 中，数组的filter()方法用于创建一个新数组，</span></span><br><span class="line"><span class="comment">    这个新数组包含通过给定函数测试的原始数组中的所有元素。</span></span><br><span class="line"><span class="comment">    它会遍历原始数组中的每一个元素，并将每个元素传入提供的函数进行判断。</span></span><br><span class="line"><span class="comment">    如果函数返回true，则该元素会被包含在新数组中；如果返回false，则该元素会被排除。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="title function_">setContentList</span>(commentList.<span class="title function_">filter</span>(<span class="function"><span class="params">item</span> =&gt;</span> item.<span class="property">user</span>.<span class="property">uid</span>!==user_id))</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="渲染Tab-点击高亮实现"><a href="#渲染Tab-点击高亮实现" class="headerlink" title="渲染Tab + 点击高亮实现"></a>渲染Tab + 点击高亮实现</h2><p>需求：点击哪个tab项，哪个做高亮处理</p>
<p>核心思路：</p>
<p>点击谁，就把谁的type(你也可以取名其他的，独一无二的标识)记录下来，然后和遍历时的每一项type做匹配，谁匹配到就设置负责高亮的类名</p>
<ul>
<li>准备一个Tab数组</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 导航 Tab 数组</span></span><br><span class="line"><span class="keyword">const</span> tabs = [</span><br><span class="line">  &#123; <span class="attr">type</span>: <span class="string">&#x27;hot&#x27;</span>, <span class="attr">text</span>: <span class="string">&#x27;最热&#x27;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">type</span>: <span class="string">&#x27;time&#x27;</span>, <span class="attr">text</span>: <span class="string">&#x27;最新&#x27;</span> &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<ul>
<li>使用map方法对tab数组进行遍历渲染</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&#123;<span class="comment">/* 导航 Tab */</span>&#125;</span><br><span class="line">&lt;div className=<span class="string">&quot;reply-navigation&quot;</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">className</span>=<span class="string">&quot;nav-bar&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">className</span>=<span class="string">&quot;nav-title&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">className</span>=<span class="string">&quot;nav-title-text&quot;</span>&gt;</span>评论<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;/* 评论数量 */&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">className</span>=<span class="string">&quot;total-reply&quot;</span>&gt;</span>&#123;10&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">    &#123;/* 使用map进行列表数据遍历渲染 需要加上key */&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">className</span>=<span class="string">&quot;nav-sort&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;tabs.map(item =&gt;(</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">className</span>=<span class="string">&#x27;nav-item&#x27;</span> <span class="attr">key</span>=<span class="string">&#123;item.type&#125;</span>&gt;</span>&#123;item.text&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      ))&#125;</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>tab切换功能，点击谁就把谁的type记录下来，然后在map遍历渲染时增加条件匹配</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [<span class="title class_">TabType</span>, setTabType] = <span class="title function_">useState</span>(<span class="string">&#x27;hot&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">handleTypeChange</span> = (<span class="params">type</span>)=&gt;&#123;</span><br><span class="line">    <span class="title function_">setTabType</span>(type)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&#123;<span class="comment">/* 使用map进行列表数据遍历渲染 需要加上key */</span>&#125;</span><br><span class="line">&lt;li className=<span class="string">&quot;nav-sort&quot;</span>&gt;</span><br><span class="line">  &#123;tabs.<span class="title function_">map</span>(<span class="function"><span class="params">item</span> =&gt;</span>(</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">span</span> </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    // <span class="attr">模板字符串是一种在</span> <span class="attr">JavaScript</span>（<span class="attr">以及其他一些编程语言</span>）<span class="attr">中用于更方便地处理字符串的语法</span>。</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    // <span class="attr">它使用反引号</span>（`）<span class="attr">来包裹字符串内容</span>，<span class="attr">而不是单引号</span>（&#x27;）<span class="attr">或双引号</span>（&quot;）</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    //  $&#123;&#125;<span class="attr">是一个模板占位符</span>，<span class="attr">它会被里面的值所替换</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">className</span>=<span class="string">&#123;</span>`<span class="attr">nav-item</span> $&#123;<span class="attr">TabType</span> === <span class="string">item.type</span> &amp;&amp; &#x27;<span class="attr">active</span>&#x27;&#125;`&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">key</span>=<span class="string">&#123;item.type&#125;</span> </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span>handleTypeChange(item.type)&#125;&gt;</span></span><br><span class="line"><span class="language-xml">    &#123;item.text&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line">  ))&#125;</span><br><span class="line"></span><br><span class="line">&lt;/li&gt;</span><br></pre></td></tr></table></figure>

<h2 id="评论排序功能"><a href="#评论排序功能" class="headerlink" title="评论排序功能"></a>评论排序功能</h2><p>需求：</p>
<p>点击最新，评论列表按照创建事件倒序排列（新的在前），点击最热按照点赞数排序（多的在前）</p>
<p>核心思路：</p>
<p><font color="yellow">把评论列表状态数据进行不同的排序处理，当成新值传给set函数重新渲染视图UI</font></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">handleTypeChange</span> = (<span class="params">type</span>)=&gt;&#123;</span><br><span class="line">    <span class="title function_">setTabType</span>(type)</span><br><span class="line">    <span class="keyword">if</span> (type === <span class="string">&#x27;hot&#x27;</span>)<span class="title function_">setContentList</span>(lodash_.<span class="title function_">orderBy</span>(commentList,<span class="string">&#x27;like&#x27;</span>,<span class="string">&#x27;desc&#x27;</span>))</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (type === <span class="string">&#x27;time&#x27;</span>)<span class="title function_">setContentList</span>(lodash_.<span class="title function_">orderBy</span>(commentList,<span class="string">&#x27;ctime&#x27;</span>,<span class="string">&#x27;desc&#x27;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用了一个三方库lodash进行排序 orderBy( 列表 , 字段 , 排序方式 )</p>
<h2 id="classnames优化类名控制"><a href="#classnames优化类名控制" class="headerlink" title="classnames优化类名控制"></a>classnames优化类名控制</h2><p>classnames是一个简单的JS库，可以非常方便地通过<font color="yellow">条件动态控制class类名的显示</font></p>


<p>这里的class类名是通过字符串的拼接而成，不够直观，并且容易出错。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install classnames</span><br></pre></td></tr></table></figure>



<h1 id="Day2"><a href="#Day2" class="headerlink" title="Day2"></a>Day2</h1><h2 id="受控表单绑定"><a href="#受控表单绑定" class="headerlink" title="受控表单绑定"></a>受控表单绑定</h2><p>使用React组件的状态（useState）控制表单的状态</p>


<ul>
<li>准备一个React状态值</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [value1,setValue1] = <span class="title function_">useState</span>(<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>通过value属性绑定状态，通过onChange属性绑定状态同步的函数</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&#123;value1&#125;</span><br><span class="line">&lt;input value=&#123;value1&#125; onChange=&#123;<span class="function">(<span class="params">e</span>)=&gt;</span><span class="title function_">setValue1</span>(e.<span class="property">target</span>.<span class="property">value</span>)&#125; type=<span class="string">&#x27;text&#x27;</span>&gt;</span><br><span class="line">&lt;/input&gt;</span><br></pre></td></tr></table></figure>

<h2 id="React中获取Dom"><a href="#React中获取Dom" class="headerlink" title="React中获取Dom"></a>React中获取Dom</h2><p>在React组件中获取&#x2F;操作DOM，需要使用useRef hook函数，分为两步：</p>
<ul>
<li>使用useRef创建ref对象，并与JSX绑定</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// useRef生成ref对象，绑定到dom标签身上</span></span><br><span class="line">  <span class="keyword">const</span> inputRef = <span class="title function_">useRef</span>(<span class="literal">null</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;<span class="comment">/* 使用ref绑定 */</span>&#125;</span><br><span class="line">&lt;input ref=&#123;inputRef&#125; value=<span class="string">&quot;sza&quot;</span>&gt;&lt;/input&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>在dom可用时，通过.current获取dom对象</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">onShow</span> = (<span class="params"></span>)=&gt;&#123;</span><br><span class="line">  <span class="comment">// dom可用时，ref.current获取dom</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(inputRef.<span class="property">current</span>.<span class="property">value</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&#123;<span class="comment">/* 点击会打印sza的字样 */</span>&#125;</span><br><span class="line">&lt;button onClick=&#123;onShow&#125;&gt;打印dom&lt;/button&gt;</span><br></pre></td></tr></table></figure>

<h2 id="B站评论-发表评论"><a href="#B站评论-发表评论" class="headerlink" title="B站评论 发表评论"></a>B站评论 发表评论</h2>

<p>获取评论内容：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个将要发布的评论 content1</span></span><br><span class="line">  <span class="keyword">const</span> [content1,setContent1] = <span class="title function_">useState</span>(<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;textarea</span><br><span class="line">  value=&#123;content1&#125;</span><br><span class="line">  <span class="comment">// ref=&#123;textareaRef&#125;</span></span><br><span class="line">  onChange=&#123;<span class="function">(<span class="params">e</span>) =&gt;</span> <span class="title function_">setContent1</span>(e.<span class="property">target</span>.<span class="property">value</span>)&#125;</span><br><span class="line">  className=<span class="string">&quot;reply-box-textarea&quot;</span></span><br><span class="line">  placeholder=<span class="string">&quot;发一条友善的评论&quot;</span></span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure>

<p>点击发布按钮发布评论：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;div className=<span class="string">&quot;reply-box-send&quot;</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;send-text&quot;</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> handleClickPublish()&#125;&gt;发布<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个将要发布的评论 content1</span></span><br><span class="line">  <span class="keyword">const</span> [content1,setContent1] = <span class="title function_">useState</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 发布评论 这里抄一份之前的评论结构</span></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">handleClickPublish</span> = (<span class="params"></span>)=&gt;&#123;</span><br><span class="line">    <span class="title function_">setContentList</span>([...commentList,  &#123;</span><br><span class="line">      <span class="attr">rpid</span>: <span class="number">10086</span>,</span><br><span class="line">      <span class="attr">user</span>: &#123;</span><br><span class="line">        <span class="attr">uid</span>: <span class="string">&#x27;30009257&#x27;</span>,</span><br><span class="line">        <span class="attr">avatar</span>:avatar1,</span><br><span class="line">        <span class="attr">uname</span>: <span class="string">&#x27;前端&#x27;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">content</span>: content1,</span><br><span class="line">      <span class="attr">ctime</span>: <span class="string">&#x27;10-19 09:00&#x27;</span>,</span><br><span class="line">      <span class="attr">like</span>: <span class="number">667</span>,</span><br><span class="line">    &#125;,])</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="独一id和时间处理"><a href="#独一id和时间处理" class="headerlink" title="独一id和时间处理"></a>独一id和时间处理</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">rpid</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">user</span>: &#123;</span><br><span class="line">    <span class="attr">uid</span>: <span class="string">&#x27;30009257&#x27;</span>,</span><br><span class="line">    <span class="attr">avatar</span>:avatar1,</span><br><span class="line">    <span class="attr">uname</span>: <span class="string">&#x27;前端&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">content</span>: <span class="string">&#x27;学前端就&#x27;</span>,</span><br><span class="line">  <span class="attr">ctime</span>: <span class="string">&#x27;10-19 09:00&#x27;</span>,</span><br><span class="line">  <span class="attr">like</span>: <span class="number">66</span>,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>评论的信息 的rpid和cime应该重新设置，分别使用uuid和dayjs</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;v4 <span class="keyword">as</span> uuidV4&#125; <span class="keyword">from</span> <span class="string">&#x27;uuid&#x27;</span></span><br><span class="line"><span class="keyword">import</span> dayjs <span class="keyword">from</span> <span class="string">&#x27;dayjs&#x27;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 发布评论 这里抄一份之前的评论结构</span></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">handleClickPublish</span> = (<span class="params"></span>)=&gt;&#123;</span><br><span class="line">    <span class="title function_">setContentList</span>([...commentList,  </span><br><span class="line">      &#123;</span><br><span class="line">      <span class="attr">rpid</span>: <span class="number">10086</span>,</span><br><span class="line">      <span class="attr">user</span>: &#123;</span><br><span class="line">        <span class="attr">uid</span>: <span class="title function_">uuidV4</span>(),</span><br><span class="line">        <span class="attr">avatar</span>:avatar1,</span><br><span class="line">        <span class="attr">uname</span>: <span class="string">&#x27;前端&#x27;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">content</span>: content1,</span><br><span class="line">      <span class="attr">ctime</span>: <span class="title function_">dayjs</span>(<span class="keyword">new</span> <span class="title class_">Date</span>()).<span class="title function_">format</span>(<span class="string">&#x27;MM-DD hh:mm&#x27;</span>),</span><br><span class="line">      <span class="attr">like</span>: <span class="number">667</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  ])</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="b站评论案例-清空内容并重新聚焦"><a href="#b站评论案例-清空内容并重新聚焦" class="headerlink" title="b站评论案例 清空内容并重新聚焦"></a>b站评论案例 清空内容并重新聚焦</h2><ul>
<li>清空内容，将input框的value属性设为空字符串</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 发布评论 这里抄一份之前的评论结构</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">handleClickPublish</span> = (<span class="params"></span>)=&gt;&#123;</span><br><span class="line">  <span class="title function_">setContentList</span>([...commentList,  </span><br><span class="line">    &#123;</span><br><span class="line">    <span class="attr">rpid</span>: <span class="number">10086</span>,</span><br><span class="line">    <span class="attr">user</span>: &#123;</span><br><span class="line">      <span class="attr">uid</span>: <span class="title function_">uuidv4</span>(),<span class="comment">// 随机id</span></span><br><span class="line">      <span class="attr">avatar</span>:avatar1,</span><br><span class="line">      <span class="attr">uname</span>: <span class="string">&#x27;前端&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">content</span>: content1,</span><br><span class="line">    <span class="attr">ctime</span>: <span class="title function_">dayjs</span>(<span class="keyword">new</span> <span class="title class_">Date</span>()).<span class="title function_">format</span>(<span class="string">&#x27;MM-DD hh:mm&#x27;</span>),</span><br><span class="line">    <span class="attr">like</span>: <span class="number">667</span>,</span><br><span class="line">  &#125;</span><br><span class="line">])</span><br><span class="line">  <span class="title function_">setContent1</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>重新聚焦：拿到input的dom元素，调用focus方法</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> textareaRef = <span class="title function_">useRef</span>(<span class="literal">null</span>)</span><br><span class="line"><span class="comment">// 发布评论 这里抄一份之前的评论结构</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">handleClickPublish</span> = (<span class="params"></span>)=&gt;&#123;</span><br><span class="line">  <span class="title function_">setContentList</span>([...commentList,  </span><br><span class="line">    &#123;</span><br><span class="line">    <span class="attr">rpid</span>: <span class="number">10086</span>,</span><br><span class="line">    <span class="attr">user</span>: &#123;</span><br><span class="line">      <span class="attr">uid</span>: <span class="title function_">uuidv4</span>(),<span class="comment">// 随机id</span></span><br><span class="line">      <span class="attr">avatar</span>:avatar1,</span><br><span class="line">      <span class="attr">uname</span>: <span class="string">&#x27;前端&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">content</span>: content1,</span><br><span class="line">    <span class="attr">ctime</span>: <span class="title function_">dayjs</span>(<span class="keyword">new</span> <span class="title class_">Date</span>()).<span class="title function_">format</span>(<span class="string">&#x27;MM-DD hh:mm&#x27;</span>),</span><br><span class="line">    <span class="attr">like</span>: <span class="number">667</span>,</span><br><span class="line">  &#125;</span><br><span class="line">])</span><br><span class="line">  <span class="title function_">setContent1</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">  <span class="comment">// 先使用 ref绑定 聚焦</span></span><br><span class="line">  textareaRef.<span class="property">current</span>.<span class="title function_">focus</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="父子通信-父传子-父组件传参给子组件"><a href="#父子通信-父传子-父组件传参给子组件" class="headerlink" title="父子通信 父传子 父组件传参给子组件"></a>父子通信 父传子 父组件传参给子组件</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父传子</span></span><br><span class="line"><span class="comment">// 1. 父组件传递数据 自组件标签身上绑定属性</span></span><br><span class="line"><span class="comment">// 2. 自组件接受数据 props的参数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Son</span>(<span class="params">props</span>)&#123;</span><br><span class="line">    <span class="comment">// props：对象里面包含了父组件中传递过来的所有数据</span></span><br><span class="line">    </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(props);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span>   <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>this is Son &#123;props.fuck&#125;-----&#123;props.a&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App2</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> var1 = <span class="string">&quot;this is father variable&quot;</span></span><br><span class="line">    <span class="keyword">const</span> var2 = <span class="string">&quot;this is father variable2&quot;</span></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Son</span> <span class="attr">name</span>=<span class="string">&#123;var1&#125;</span> <span class="attr">a</span>=<span class="string">&#123;var2&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App2</span></span><br></pre></td></tr></table></figure>

<p>传过来的props Object</p>


<ul>
<li>props可传递任意的数据：数字、字符串、布尔值、数组、对象、函数、JSX</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">App2</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> var1 = <span class="string">&quot;this is father variable&quot;</span></span><br><span class="line">    <span class="keyword">const</span> var2 = <span class="string">&quot;this is father variable2&quot;</span></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Son</span> </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">name</span>=<span class="string">&#123;var1&#125;</span> </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">a</span>=<span class="string">&#123;var2&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">isTrue</span>=<span class="string">&#123;false&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">list</span>=<span class="string">&#123;[</span>&#x27;<span class="attr">Vue</span>&#x27;,&#x27;<span class="attr">React</span>&#x27;]&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">obj</span>=<span class="string">&#123;&#123;name:</span>&#x27;<span class="attr">sza</span>&#x27;&#125;&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">cb</span>=<span class="string">&#123;()</span>=&gt;</span>&#123;console.log(&#x27;something else&#x27;)&#125;&#125;</span></span><br><span class="line"><span class="language-xml">            children = &#123;<span class="tag">&lt;<span class="name">span</span>&gt;</span>what?<span class="tag">&lt;/<span class="name">span</span>&gt;</span>&#125;</span></span><br><span class="line"><span class="language-xml">            /&gt;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App2</span></span><br></pre></td></tr></table></figure>



<ul>
<li>props是只读对象</li>
</ul>
<p>子组件<font color="yellow">只能读取props中的数据，不能直接进行修改</font>，父组件的数据只能由父组件修改</p>
<p>特殊的prop children</p>
<p>场景：当我们把内容嵌套在自组件标签当中时，父组件会自动在名为children的prop属性中接受改内容</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父传子</span></span><br><span class="line"><span class="comment">// 1. 父组件传递数据 自组件标签身上绑定属性</span></span><br><span class="line"><span class="comment">// 2. 自组件接受数据 props的参数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Son</span>(<span class="params">props</span>)&#123;</span><br><span class="line">    <span class="comment">// props：对象里面包含了父组件中传递过来的所有数据</span></span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(props);</span><br><span class="line">    <span class="comment">//  默认都是children </span></span><br><span class="line">    <span class="keyword">return</span>   <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>this is Son &#123;props.children[0]&#125; ----  &#123;props.children[1]&#125; ----  &#123;props.children[2]&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App2</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> var1 = <span class="string">&quot;this is father variable1&quot;</span></span><br><span class="line">    <span class="keyword">const</span> var2 = <span class="string">&quot;this is father variable2&quot;</span></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Son</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                &#123;var1&#125;</span></span><br><span class="line"><span class="language-xml">                &#123;var2&#125;</span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">span</span>&gt;</span> this is span 3<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">Son</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App2</span></span><br></pre></td></tr></table></figure>



<h2 id="父子通信-子传父"><a href="#父子通信-子传父" class="headerlink" title="父子通信 子传父"></a>父子通信 子传父</h2>
<p>核心思路是：在子组件中调用父组件中的函数并传递参数</p>


<p>子组件调用父组件传的带参函数，子组件在赋值参数的时候，就会传递给了父组件的函数，相当于是子传父</p>
<ul>
<li>在返回的 JSX 结构中，包含一个文本内容 “this is son” 和一个按钮。当按钮被点击时，会调用 <code>onGetMsg</code> 函数并将 <code>sonMsg</code> 作为参数传递给父组件。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父传子</span></span><br><span class="line"><span class="comment">// 1. 父组件传递数据 自组件标签身上绑定属性</span></span><br><span class="line"><span class="comment">// 2. 自组件接受数据 props的参数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Son</span>(<span class="params">props</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> sonMsg = <span class="string">&#x27;this is son msg&#x27;</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span>  (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        this is son</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span>props.onGetMsg(sonMsg)&#125;&gt;send<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App2</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">getMsg</span> = (<span class="params">msg</span>) =&gt;&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(msg)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Son</span> <span class="attr">onGetMsg</span>=<span class="string">&#123;getMsg&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App2</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父传子</span></span><br><span class="line"><span class="comment">// 1. 父组件传递数据 自组件标签身上绑定属性</span></span><br><span class="line"><span class="comment">// 2. 自组件接受数据 props的参数</span></span><br><span class="line"><span class="comment">// // 接收一个名为 onGetMsg 的属性，该属性是一个函数，用于将子组件的数据传递给父组件</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Son</span>(<span class="params">&#123;onGetMsg&#125;</span>)&#123;<span class="comment">// onGetMsg必须与&lt;Son onGetMsg=&#123;getMsg&#125;/&gt;这里的属性一致</span></span><br><span class="line">    <span class="keyword">const</span> sonMsg = <span class="string">&#x27;this is son msg&#x27;</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span>  (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        this is son</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span>onGetMsg(sonMsg)&#125;&gt;send<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App2</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">getMsg</span> = (<span class="params">msg</span>) =&gt;&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(msg)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Son</span> <span class="attr">onGetMsg</span>=<span class="string">&#123;getMsg&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App2</span></span><br></pre></td></tr></table></figure>

<h2 id="使用状态提升实现兄弟组件通信"><a href="#使用状态提升实现兄弟组件通信" class="headerlink" title="使用状态提升实现兄弟组件通信"></a>使用状态提升实现兄弟组件通信</h2>

<p>借助父组件进行兄弟组件之间的数据传递</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; useState &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收一个名为 onGetMsg 的属性，该属性是一个函数，用于将子组件的数据传递给父组件</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Son1</span>(<span class="params">&#123;onGetMsg&#125;</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> sonMsg = <span class="string">&#x27;this is son1 msg&#x27;</span> <span class="comment">// son1 要传递的数据</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span>  (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span>onGetMsg(sonMsg)&#125;&gt;send<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Son2</span>(<span class="params">props</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;props.msg2&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App2</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> [msg_,setMsg_] = <span class="title function_">useState</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">getMsg</span> = (<span class="params">msg</span>) =&gt;&#123;</span><br><span class="line">        <span class="title function_">setMsg_</span>(msg) <span class="comment">// son1传来的数据 到了父节点这里使用useState的set 改变该值传给子组件son2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Son1</span> <span class="attr">onGetMsg</span>=<span class="string">&#123;getMsg&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Son2</span> <span class="attr">msg2</span>=<span class="string">&#123;msg_&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">Son2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App2</span></span><br></pre></td></tr></table></figure>

<h2 id="使用Context机制跨层级组件通信"><a href="#使用Context机制跨层级组件通信" class="headerlink" title="使用Context机制跨层级组件通信"></a>使用Context机制跨层级组件通信</h2>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父传子</span></span><br><span class="line"><span class="comment">// 1. 父组件传递数据 自组件标签身上绑定属性</span></span><br><span class="line"><span class="comment">// 2. 自组件接受数据 props的参数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; createContext, useContext, useState &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. createContext方法创建一个上下文对象</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Ctx</span> = <span class="title function_">createContext</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Son1</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span>  (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Son2</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Son2</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">// 3. 在底层组件 通过useContest钩子函数使用数据 参数为createContext方法创造的上下文对象</span></span><br><span class="line">    <span class="keyword">const</span> msg = <span class="title function_">useContext</span>(<span class="title class_">Ctx</span>) </span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;msg&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App2</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> app2Msg = <span class="string">&#x27;顶层msg&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            &#123;/* 2.在顶层组件 通过Provider组件提供数据 */&#125;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Ctx.Provider</span> <span class="attr">value</span>=<span class="string">&#123;app2Msg&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">Son1</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">Ctx.Provider</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"> </span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App2</span></span><br></pre></td></tr></table></figure>

<p>这里的顶层和底层其实是相对的概念，只要存在嵌套的机制就可以用Context，比如父子</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父传子</span></span><br><span class="line"><span class="comment">// 1. 父组件传递数据 自组件标签身上绑定属性</span></span><br><span class="line"><span class="comment">// 2. 自组件接受数据 props的参数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; createContext, useContext, useState &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. createContext方法创建一个上下文对象</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Ctx</span> = <span class="title function_">createContext</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Son1</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">// 父子也是顶层和底层 都可以用Context</span></span><br><span class="line">    <span class="keyword">const</span> msg = <span class="title function_">useContext</span>(<span class="title class_">Ctx</span>)</span><br><span class="line">    <span class="keyword">return</span>  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;msg&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Son2</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">// 3. 在底层组件 通过useContest钩子函数使用数据 参数为createContext方法创造的上下文对象</span></span><br><span class="line">    <span class="keyword">const</span> msg = <span class="title function_">useContext</span>(<span class="title class_">Ctx</span>) </span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;msg&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App2</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> app2Msg = <span class="string">&#x27;顶层msg&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            &#123;/* 2.在顶层组件 通过Provider组件提供数据 */&#125;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Ctx.Provider</span> <span class="attr">value</span>=<span class="string">&#123;app2Msg&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">Son1</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">Son2</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">Ctx.Provider</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"> </span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App2</span></span><br></pre></td></tr></table></figure>

<h2 id="useEffect概念理解"><a href="#useEffect概念理解" class="headerlink" title="useEffect概念理解"></a>useEffect概念理解</h2><p>useEffect是一个React Hook函数，用于在React组件中创建不是由事件（点击、滑动等）引起而是<font color="yellow">由渲染本身引起的操作</font>（发送ajax请求、更改dom等）。</p>


<p>说明：上面的组件中没有发生任何的用户事件，<font color="yellow">组件渲染完毕之后</font>就需要和服务器要数据，整个过程属于<font color="yellow">“只由渲染引起的操作”</font>。</p>
<p>需求：在组件渲染完毕后，立刻从服务端获取频道列表数据并显示到页面中</p>
<p>语法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>( <span class="function">()=&gt;</span>&#123;&#125; , [] )</span><br></pre></td></tr></table></figure>

<p>参数1 是一个函数，可以把它称为副作用函数，在函数内部可以放置要执行的操作</p>
<p>参数2 是一个数组，在数组里放置依赖项，不同依赖项会影响第一个参数函数的执行，<font color="yellow">当是一个空数组时，副作用函数只会在组件渲染完毕后执行一次</font></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useEffect, useState &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> url = <span class="string">&#x27;http://geek.itheima.net/v1_0/channels&#x27;</span> <span class="comment">// 获取服务端数据的api</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App3</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> [list,setList] = <span class="title function_">useState</span>([])</span><br><span class="line">    <span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getList</span>(<span class="params"></span>) &#123;</span><br><span class="line">          <span class="comment">// 当使用fetch进行网络请求时，这个请求是异步发送的。</span></span><br><span class="line">          <span class="comment">// 程序不会等待请求返回结果才继续执行其他代码。</span></span><br><span class="line">            <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="title function_">fetch</span>(url)</span><br><span class="line">            <span class="keyword">const</span> jsonRes = <span class="keyword">await</span> res.<span class="title function_">json</span>()</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(jsonRes)</span><br><span class="line">            <span class="title function_">setList</span>(jsonRes.<span class="property">data</span>.<span class="property">channels</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">getList</span>()</span><br><span class="line">    &#125;,[])</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                &#123;list.map(item =&gt; <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;item.id&#125;</span>&gt;</span>&#123;item.name&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span>)&#125;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App3</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>Java基础</title>
    <url>/Java%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="多线程基础"><a href="#多线程基础" class="headerlink" title="多线程基础"></a>多线程基础</h1><blockquote>
<p>source from <a href="https://liaoxuefeng.com/books/java/threading/basic/index.html">https://liaoxuefeng.com/books/java/threading/basic/index.html</a></p>
</blockquote>
<p>现代操作系统（Windows，macOS，Linux）都可以执行多任务。多任务就是同时运行多个任务。</p>
<p>CPU执行代码都是一条一条顺序执行的，但是，即使是单核cpu，也可以同时运行多个任务。因为操作系统执行多任务实际上就是让CPU对多个任务轮流交替执行。</p>
<p>例如，假设我们有语文、数学、英语3门作业要做，每个作业需要30分钟。我们把这3门作业看成是3个任务，可以做1分钟语文作业，再做1分钟数学作业，再做1分钟英语作业。</p>
<p>类似的，操作系统轮流让多个任务交替执行，例如，让浏览器执行0.001秒，让QQ执行0.001秒，再让音乐播放器执行0.001秒，在人看来，CPU就是在同时执行多个任务。</p>
<p>即使是多核CPU，因为通常任务的数量远远多于CPU的核数，所以任务也是交替执行的。</p>
<h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>在计算机中，我们把一个任务称为一个进程，浏览器就是一个进程，视频播放器是另一个进程，类似的，音乐播放器和Word都是进程。</p>
<p>某些进程内部还需要同时执行多个子任务。例如，我们在使用Word时，Word可以让我们一边打字，一边进行拼写检查，同时还可以在后台进行打印，我们把子任务称为线程。</p>
<p>进程和线程的关系就是：一个进程可以包含一个或多个线程，但至少会有一个线程。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">                        ┌──────────┐</span><br><span class="line">                        │Process   │</span><br><span class="line">                        │┌────────┐│</span><br><span class="line">            ┌──────────┐││ Thread ││┌──────────┐</span><br><span class="line">            │Process   ││└────────┘││Process   │</span><br><span class="line">            │┌────────┐││┌────────┐││┌────────┐│</span><br><span class="line">┌──────────┐││ Thread ││││ Thread ││││ Thread ││</span><br><span class="line">│Process   ││└────────┘││└────────┘││└────────┘│</span><br><span class="line">│┌────────┐││┌────────┐││┌────────┐││┌────────┐│</span><br><span class="line">││ Thread ││││ Thread ││││ Thread ││││ Thread ││</span><br><span class="line">│└────────┘││└────────┘││└────────┘││└────────┘│</span><br><span class="line">└──────────┘└──────────┘└──────────┘└──────────┘</span><br><span class="line">┌──────────────────────────────────────────────┐</span><br><span class="line">│               Operating System               │</span><br><span class="line">└──────────────────────────────────────────────┘</span><br></pre></td></tr></table></figure>

<p>操作系统调度的最小任务单位其实不是进程，而是线程。常用的Windows、Linux等操作系统都采用抢占式多任务，如何调度线程完全由操作系统决定，程序自己不能决定什么时候执行，以及执行多长时间。</p>
<p>因为同一个应用程序，既可以有多个进程，也可以有多个线程，因此，实现多任务的方法，有以下几种：</p>
<p>多进程模式（每个进程只有一个线程）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">┌──────────┐ ┌──────────┐ ┌──────────┐</span><br><span class="line">│Process   │ │Process   │ │Process   │</span><br><span class="line">│┌────────┐│ │┌────────┐│ │┌────────┐│</span><br><span class="line">││ Thread ││ ││ Thread ││ ││ Thread ││</span><br><span class="line">│└────────┘│ │└────────┘│ │└────────┘│</span><br><span class="line">└──────────┘ └──────────┘ └──────────┘</span><br></pre></td></tr></table></figure>

<p>多线程模式（一个进程有多个线程）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">┌────────────────────┐</span><br><span class="line">│Process             │</span><br><span class="line">│┌────────┐┌────────┐│</span><br><span class="line">││ Thread ││ Thread ││</span><br><span class="line">│└────────┘└────────┘│</span><br><span class="line">│┌────────┐┌────────┐│</span><br><span class="line">││ Thread ││ Thread ││</span><br><span class="line">│└────────┘└────────┘│</span><br><span class="line">└────────────────────┘</span><br></pre></td></tr></table></figure>

<p>多进程＋多线程模式（复杂度最高）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">┌──────────┐┌──────────┐┌──────────┐</span><br><span class="line">│Process   ││Process   ││Process   │</span><br><span class="line">│┌────────┐││┌────────┐││┌────────┐│</span><br><span class="line">││ Thread ││││ Thread ││││ Thread ││</span><br><span class="line">│└────────┘││└────────┘││└────────┘│</span><br><span class="line">│┌────────┐││┌────────┐││┌────────┐│</span><br><span class="line">││ Thread ││││ Thread ││││ Thread ││</span><br><span class="line">│└────────┘││└────────┘││└────────┘│</span><br><span class="line">└──────────┘└──────────┘└──────────┘</span><br></pre></td></tr></table></figure>

<h3 id="进程-vs-线程"><a href="#进程-vs-线程" class="headerlink" title="进程 vs 线程"></a>进程 vs 线程</h3><p>进程和线程是包含关系，但是多任务既可以由多进程实现，也可以由单进程内的多线程实现，还可以混合多进程＋多线程。</p>
<p>具体采用哪种方式，要考虑到进程和线程的特点。</p>
<p>和多线程相比，多进程的缺点在于：</p>
<ul>
<li>创建进程比创建线程开销大，尤其是在Windows系统上；</li>
<li>进程间通信比线程间通信要慢，因为线程间通信就是读写同一个变量，速度很快。</li>
</ul>
<p>而多进程的优点在于：</p>
<p>多进程稳定性比多线程高，因为在多进程的情况下，一个进程崩溃不会影响其他进程，而在多线程的情况下，任何一个线程崩溃会直接导致整个进程崩溃。</p>
<h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><p>Java语言内置了多线程支持：一个Java程序实际上是一个JVM进程，JVM进程用一个主线程来执行<code>main()</code>方法，在<code>main()</code>方法内部，我们又可以启动多个线程。此外，JVM还有负责垃圾回收的其他工作线程等。</p>
<p>因此，对于大多数Java程序来说，我们说多任务，实际上是说如何使用多线程实现多任务。</p>
<p>和单线程相比，多线程编程的特点在于：多线程经常需要读写共享数据，并且需要同步。例如，播放电影时，就必须由一个线程播放视频，另一个线程播放音频，两个线程需要协调运行，否则画面和声音就不同步。因此，多线程编程的复杂度高，调试更困难。</p>
<p>Java多线程编程的特点又在于：</p>
<ul>
<li>多线程模型是Java程序最基本的并发模型；</li>
<li>后续读写网络、数据库、Web开发等都依赖Java多线程模型。</li>
</ul>
<h2 id="创建新线程"><a href="#创建新线程" class="headerlink" title="创建新线程"></a>创建新线程</h2><p>Java语言内置了多线程支持。当Java程序启动的时候，实际上是启动了一个JVM进程，然后，JVM启动主线程来执行<code>main()</code>方法。在<code>main()</code>方法中，我们又可以启动其他线程。</p>
<p>要创建一个新线程非常容易，我们需要实例化一个<code>Thread</code>实例，然后调用它的<code>start()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 多线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>();</span><br><span class="line">        t.start(); <span class="comment">// 启动新线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这个线程启动后实际上什么也不做就立刻结束了。我们希望新线程能执行指定的代码，有以下几种方法：</p>
<p>方法一：从<code>Thread</code>派生一个自定义类，然后覆写<code>run()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 多线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        t.start(); <span class="comment">// 启动新线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;start new thread!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行上述代码，注意到<code>start()</code>方法会在内部自动调用实例的<code>run()</code>方法。</p>
<p>方法二：创建<code>Thread</code>实例时，传入一个<code>Runnable</code>实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 多线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>());</span><br><span class="line">        t.start(); <span class="comment">// 启动新线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;start new thread!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者用Java 8引入的lambda语法进一步简写为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 多线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;start new thread!&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        t.start(); <span class="comment">// 启动新线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有童鞋会问，使用线程执行的打印语句，和直接在<code>main()</code>方法执行有区别吗？</p>
<p>区别大了去了。我们看以下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;main start...&quot;);</span><br><span class="line">        Thread t = new Thread() &#123;</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                System.out.println(&quot;thread run...&quot;);</span><br><span class="line">                System.out.println(&quot;thread end.&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t.start();</span><br><span class="line">        System.out.println(&quot;main end...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们用蓝色表示主线程，也就是<code>main</code>线程，<code>main</code>线程执行的代码有4行，首先打印<code>main start</code>，然后创建<code>Thread</code>对象，紧接着调用<code>start()</code>启动新线程。当<code>start()</code>方法被调用时，JVM就创建了一个新线程，我们通过实例变量<code>t</code>来表示这个新线程对象，并开始执行。</p>
<p>接着，<code>main</code>线程继续执行打印<code>main end</code>语句，而<code>t</code>线程在<code>main</code>线程执行的同时会并发执行，打印<code>thread run</code>和<code>thread end</code>语句。</p>
<p>当<code>run()</code>方法结束时，新线程就结束了。而<code>main()</code>方法结束时，主线程也结束了。</p>
<p>我们再来看线程的执行顺序：</p>
<ol>
<li><code>main</code>线程肯定是先打印<code>main start</code>，再打印<code>main end</code>；</li>
<li><code>t</code>线程肯定是先打印<code>thread run</code>，再打印<code>thread end</code>。</li>
</ol>
<p>但是，除了可以肯定，<code>main start</code>会先打印外，<code>main end</code>打印在<code>thread run</code>之前、<code>thread end</code>之后或者之间，都无法确定。因为从<code>t</code>线程开始运行以后，两个线程就开始同时运行了，并且由操作系统调度，程序本身无法确定线程的调度顺序。</p>
<p>要模拟并发执行的效果，我们可以在线程中调用<code>Thread.sleep()</code>，强迫当前线程暂停一段时间：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 多线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;main start...&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;thread run...&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;&#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;thread end.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">20</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;&#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;main end...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>sleep()</code>传入的参数是毫秒。调整暂停时间的大小，我们可以看到<code>main</code>线程和<code>t</code>线程执行的先后顺序。</p>
<p>要特别注意：直接调用<code>Thread</code>实例的<code>run()</code>方法是无效的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        t.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接调用<code>run()</code>方法，相当于调用了一个普通的Java方法，当前线程并没有任何改变，也不会启动新线程。上述代码实际上是在<code>main()</code>方法内部又调用了<code>run()</code>方法，打印<code>hello</code>语句是在<code>main</code>线程中执行的，没有任何新线程被创建。</p>
<p>必须调用<code>Thread</code>实例的<code>start()</code>方法才能启动新线程，如果我们查看<code>Thread</code>类的源代码，会看到<code>start()</code>方法内部调用了一个<code>private native void start0()</code>方法，<code>native</code>修饰符表示这个方法是由JVM虚拟机内部的C代码实现的，不是由Java代码实现的。</p>
<h3 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h3><p>可以对线程设定优先级，设定优先级的方法是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread.setPriority(<span class="type">int</span> n) <span class="comment">// 1~10, 默认值5</span></span><br></pre></td></tr></table></figure>

<p>JVM自动把1（低）~10（高）的优先级映射到操作系统实际优先级上（不同操作系统有不同的优先级数量）。优先级高的线程被操作系统调度的优先级较高，操作系统对高优先级线程可能调度更频繁，但我们决不能通过设置优先级来确保高优先级的线程一定会先执行。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>Java用<code>Thread</code>对象表示一个线程，通过调用<code>start()</code>启动一个新线程；</p>
<p>一个线程对象只能调用一次<code>start()</code>方法；</p>
<p>线程的执行代码写在<code>run()</code>方法中；</p>
<p>线程调度由操作系统决定，程序本身无法决定调度顺序；</p>
<p><code>Thread.sleep()</code>可以把当前线程暂停一段时间。</p>
<h2 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h2><p>在Java程序中，一个线程对象只能调用一次<code>start()</code>方法启动新线程，并在新线程中执行<code>run()</code>方法。一旦<code>run()</code>方法执行完毕，线程就结束了。因此，Java线程的状态有以下几种：</p>
<ul>
<li>New：新创建的线程，尚未执行；</li>
<li>Runnable：运行中的线程，正在执行<code>run()</code>方法的Java代码；</li>
<li>Blocked：运行中的线程，因为某些操作被阻塞而挂起；</li>
<li>Waiting：运行中的线程，因为某些操作在等待中；</li>
<li>Timed Waiting：运行中的线程，因为执行<code>sleep()</code>方法正在计时等待；</li>
<li>Terminated：线程已终止，因为<code>run()</code>方法执行完毕。</li>
</ul>
<p>用一个状态转移图表示如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">         ┌─────────────┐</span><br><span class="line">         │     New     │</span><br><span class="line">         └─────────────┘</span><br><span class="line">                │</span><br><span class="line">                ▼</span><br><span class="line">┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┐</span><br><span class="line"> ┌─────────────┐ ┌─────────────┐</span><br><span class="line">││  Runnable   │ │   Blocked   ││</span><br><span class="line"> └─────────────┘ └─────────────┘</span><br><span class="line">│┌─────────────┐ ┌─────────────┐│</span><br><span class="line"> │   Waiting   │ │Timed Waiting│</span><br><span class="line">│└─────────────┘ └─────────────┘│</span><br><span class="line"> ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─</span><br><span class="line">                │</span><br><span class="line">                ▼</span><br><span class="line">         ┌─────────────┐</span><br><span class="line">         │ Terminated  │</span><br><span class="line">         └─────────────┘</span><br></pre></td></tr></table></figure>

<p>当线程启动后，它可以在<code>Runnable</code>、<code>Blocked</code>、<code>Waiting</code>和<code>Timed Waiting</code>这几个状态之间切换，直到最后变成<code>Terminated</code>状态，线程终止。</p>
<p>线程终止的原因有：</p>
<ul>
<li>线程正常终止：<code>run()</code>方法执行到<code>return</code>语句返回；</li>
<li>线程意外终止：<code>run()</code>方法因为未捕获的异常导致线程终止；</li>
<li>对某个线程的<code>Thread</code>实例调用<code>stop()</code>方法强制终止（强烈不推荐使用）。</li>
</ul>
<p>一个线程还可以等待另一个线程直到其运行结束。例如，<code>main</code>线程在启动<code>t</code>线程后，可以通过<code>t.join()</code>等待<code>t</code>线程结束后再继续运行：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 多线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(<span class="string">&quot;start&quot;</span>);</span><br><span class="line">        t.start(); <span class="comment">// 启动t线程</span></span><br><span class="line">        t.join(); <span class="comment">// 此处main线程会等待t结束</span></span><br><span class="line">        System.out.println(<span class="string">&quot;end&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当<code>main</code>线程对线程对象<code>t</code>调用<code>join()</code>方法时，主线程将等待变量<code>t</code>表示的线程运行结束，即<code>join</code>就是指等待该线程结束，然后才继续往下执行自身线程。所以，上述代码打印顺序可以肯定是<code>main</code>线程先打印<code>start</code>，<code>t</code>线程再打印<code>hello</code>，<code>main</code>线程最后再打印<code>end</code>。</p>
<p>如果<code>t</code>线程已经结束，对实例<code>t</code>调用<code>join()</code>会立刻返回。此外，<code>join(long)</code>的重载方法也可以指定一个等待时间，超过等待时间后就不再继续等待。</p>
<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>Java线程对象<code>Thread</code>的状态包括：<code>New</code>、<code>Runnable</code>、<code>Blocked</code>、<code>Waiting</code>、<code>Timed Waiting</code>和<code>Terminated</code>；</p>
<p>通过对另一个线程对象调用<code>join()</code>方法可以等待其执行结束；</p>
<p>可以指定等待时间，超过等待时间线程仍然没有结束就不再等待；</p>
<p>对已经运行结束的线程调用<code>join()</code>方法会立刻返回。</p>
<h2 id="中断线程"><a href="#中断线程" class="headerlink" title="中断线程"></a>中断线程</h2><p>如果线程需要执行一个长时间任务，就可能需要能中断线程。中断线程就是其他线程给该线程发一个信号，该线程收到信号后结束执行<code>run()</code>方法，使得自身线程能立刻结束运行。</p>
<p>我们举个栗子：假设从网络下载一个100M的文件，如果网速很慢，用户等得不耐烦，就可能在下载过程中点“取消”，这时，程序就需要中断下载线程的执行。</p>
<p>中断一个线程非常简单，只需要在其他线程中对目标线程调用<code>interrupt()</code>方法，目标线程需要反复检测自身状态是否是interrupted状态，如果是，就立刻结束运行。</p>
<p>我们还是看示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 中断线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        t.start();</span><br><span class="line">        Thread.sleep(<span class="number">1</span>); <span class="comment">// 暂停1毫秒</span></span><br><span class="line">        t.interrupt(); <span class="comment">// 中断t线程</span></span><br><span class="line">        t.join(); <span class="comment">// 等待t线程结束</span></span><br><span class="line">        System.out.println(<span class="string">&quot;end&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (! isInterrupted()) &#123;</span><br><span class="line">            n ++;</span><br><span class="line">            System.out.println(n + <span class="string">&quot; hello!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>仔细看上述代码，<code>main</code>线程通过调用<code>t.interrupt()</code>方法中断<code>t</code>线程，但是要注意，<code>interrupt()</code>方法仅仅向<code>t</code>线程发出了“中断请求”，至于<code>t</code>线程是否能立刻响应，要看具体代码。而<code>t</code>线程的<code>while</code>循环会检测<code>isInterrupted()</code>，所以上述代码能正确响应<code>interrupt()</code>请求，使得自身立刻结束运行<code>run()</code>方法。</p>
<p>如果线程处于等待状态，例如，<code>t.join()</code>会让<code>main</code>线程进入等待状态，此时，如果对<code>main</code>线程调用<code>interrupt()</code>，<code>join()</code>方法会立刻抛出<code>InterruptedException</code>，因此，目标线程只要捕获到<code>join()</code>方法抛出的<code>InterruptedException</code>，就说明有其他线程对其调用了<code>interrupt()</code>方法，通常情况下该线程应该立刻结束运行。</p>
<p>我们来看下面的示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 中断线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        t.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        t.interrupt(); <span class="comment">// 中断t线程</span></span><br><span class="line">        t.join(); <span class="comment">// 等待t线程结束</span></span><br><span class="line">        System.out.println(<span class="string">&quot;end&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">hello</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HelloThread</span>();</span><br><span class="line">        hello.start(); <span class="comment">// 启动hello线程</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            hello.join(); <span class="comment">// 等待hello线程结束</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;interrupted!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        hello.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HelloThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!isInterrupted()) &#123;</span><br><span class="line">            n++;</span><br><span class="line">            System.out.println(n + <span class="string">&quot; hello!&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>main</code>线程通过调用<code>t.interrupt()</code>从而通知<code>t</code>线程中断，而此时<code>t</code>线程正位于<code>hello.join()</code>的等待中，此方法会立刻结束等待并抛出<code>InterruptedException</code>。由于我们在<code>t</code>线程中捕获了<code>InterruptedException</code>，因此，就可以准备结束该线程。在<code>t</code>线程结束前，对<code>hello</code>线程也进行了<code>interrupt()</code>调用通知其中断。如果去掉这一行代码，可以发现<code>hello</code>线程仍然会继续运行，且JVM不会退出。</p>
<p>另一个常用的中断线程的方法是设置标志位。我们通常会用一个<code>running</code>标志位来标识线程是否应该继续运行，在外部线程中，通过把<code>HelloThread.running</code>置为<code>false</code>，就可以让线程结束：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 中断线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>  <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">HelloThread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HelloThread</span>();</span><br><span class="line">        t.start();</span><br><span class="line">        Thread.sleep(<span class="number">1</span>);</span><br><span class="line">        t.running = <span class="literal">false</span>; <span class="comment">// 标志位置为false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HelloThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">running</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (running) &#123;</span><br><span class="line">            n ++;</span><br><span class="line">            System.out.println(n + <span class="string">&quot; hello!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;end!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意到<code>HelloThread</code>的标志位<code>boolean running</code>是一个线程间共享的变量。线程间共享变量需要使用<code>volatile</code>关键字标记，确保每个线程都能读取到更新后的变量值。</p>
<p>为什么要对线程间共享的变量用关键字<code>volatile</code>声明？这涉及到Java的内存模型。在Java虚拟机中，变量的值保存在主内存中，但是，当线程访问变量时，它会先获取一个副本，并保存在自己的工作内存中。如果线程修改了变量的值，虚拟机会在某个时刻把修改后的值回写到主内存，但是，这个时间是不确定的！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┐</span><br><span class="line">           Main Memory</span><br><span class="line">│                               │</span><br><span class="line">   ┌───────┐┌───────┐┌───────┐</span><br><span class="line">│  │ var A ││ var B ││ var C │  │</span><br><span class="line">   └───────┘└───────┘└───────┘</span><br><span class="line">│     │ ▲               │ ▲     │</span><br><span class="line"> ─ ─ ─│─│─ ─ ─ ─ ─ ─ ─ ─│─│─ ─ ─</span><br><span class="line">      │ │               │ │</span><br><span class="line">┌ ─ ─ ┼ ┼ ─ ─ ┐   ┌ ─ ─ ┼ ┼ ─ ─ ┐</span><br><span class="line">      ▼ │               ▼ │</span><br><span class="line">│  ┌───────┐  │   │  ┌───────┐  │</span><br><span class="line">   │ var A │         │ var C │</span><br><span class="line">│  └───────┘  │   │  └───────┘  │</span><br><span class="line">   Thread 1          Thread 2</span><br><span class="line">└ ─ ─ ─ ─ ─ ─ ┘   └ ─ ─ ─ ─ ─ ─ ┘</span><br></pre></td></tr></table></figure>

<p>这会导致如果一个线程更新了某个变量，另一个线程读取的值可能还是更新前的。例如，主内存的变量<code>a = true</code>，线程1执行<code>a = false</code>时，它在此刻仅仅是把变量<code>a</code>的副本变成了<code>false</code>，主内存的变量<code>a</code>还是<code>true</code>，在JVM把修改后的<code>a</code>回写到主内存之前，其他线程读取到的<code>a</code>的值仍然是<code>true</code>，这就造成了多线程之间共享的变量不一致。</p>
<p>因此，<code>volatile</code>关键字的目的是告诉虚拟机：</p>
<ul>
<li>每次访问变量时，总是获取主内存的最新值；</li>
<li>每次修改变量后，立刻回写到主内存。</li>
</ul>
<p><code>volatile</code>关键字解决的是可见性问题：当一个线程修改了某个共享变量的值，其他线程能够立刻看到修改后的值。</p>
<p>如果我们去掉<code>volatile</code>关键字，运行上述程序，发现效果和带<code>volatile</code>差不多，这是因为在x86的架构下，JVM回写主内存的速度非常快，但是，换成ARM的架构，就会有显著的延迟。</p>
<h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p>对目标线程调用<code>interrupt()</code>方法可以请求中断一个线程，目标线程通过检测<code>isInterrupted()</code>标志获取自身是否已中断。如果目标线程处于等待状态，该线程会捕获到<code>InterruptedException</code>；</p>
<p>目标线程检测到<code>isInterrupted()</code>为<code>true</code>或者捕获了<code>InterruptedException</code>都应该立刻结束自身线程；</p>
<p>通过标志位判断需要正确使用<code>volatile</code>关键字；</p>
<p><code>volatile</code>关键字解决了共享变量在线程间的可见性问题。</p>
<h2 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h2><p>Java程序入口就是由JVM启动<code>main</code>线程，<code>main</code>线程又可以启动其他线程。当所有线程都运行结束时，JVM退出，进程结束。</p>
<p>如果有一个线程没有退出，JVM进程就不会退出。所以，必须保证所有线程都能及时结束。</p>
<p>但是有一种线程的目的就是无限循环，例如，一个定时触发任务的线程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TimerThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.println(LocalTime.now());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果这个线程不结束，JVM进程就无法结束。问题是，由谁负责结束这个线程？</p>
<p>然而这类线程经常没有负责人来负责结束它们。但是，当其他线程结束时，JVM进程又必须要结束，怎么办？</p>
<p>答案是使用守护线程（Daemon Thread）。</p>
<blockquote>
<p>守护线程 就是大家常说的 Daemon Thread 线程也叫 后台线程，是程序运行时在后台提供的一种通用服务的线程。<br>　　比如垃圾回收线程就是一个很称职的守护者，并且这种线程并不属于程序中不可或缺的部分。因此，当所有的非守护线程结束时，程序也就终止了，同时会杀死进程中的所有守护线程。反过来说，只要任何非守护线程还在运行，程序就不会终止。事实上，User Thread（用户线程）和 Daemon Thread（守护线程）从本质上来说并没有什么区别，唯一的不同之处就在于虚拟机的离开：如果用户线程已经全部退出运行了，只剩下守护线程存在了，虚拟机也就退出了。 因为没有了被守护者，守护线程也就没有工作可做了，也就没有继续运行程序的必要了。</p>
</blockquote>
<p>守护线程是指为其他线程服务的线程。在JVM中，所有非守护线程都执行完毕后，无论有没有守护线程，虚拟机都会自动退出。</p>
<p>因此，JVM退出时，不必关心守护线程是否已结束。</p>
<p>如何创建守护线程呢？方法和普通线程一样，只是在调用<code>start()</code>方法前，调用<code>setDaemon(true)</code>把该线程标记为守护线程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">t.setDaemon(<span class="literal">true</span>);</span><br><span class="line">t.start();</span><br></pre></td></tr></table></figure>

<p>在守护线程中，编写代码要注意：守护线程不能持有任何需要关闭的资源，例如打开文件等，因为虚拟机退出时，守护线程没有任何机会来关闭文件，这会导致数据丢失。</p>
<h3 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h3><p>守护线程是为其他线程服务的线程；</p>
<p>所有非守护线程都执行完毕后，虚拟机退出，守护线程随之结束；</p>
<p>守护线程不能持有需要关闭的资源（如打开文件等）。</p>
<p>守护线程就是用来告诉JVM，我的这个线程是一个低级别的线程，不需要等待它运行完才退出，让JVM喜欢什么时候退出就退出，不用管这个线程。</p>
<h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><p>当多个线程同时运行时，线程的调度由操作系统决定，程序本身无法决定。因此，任何一个线程都有可能在任何指令处被操作系统暂停，然后在某个时间段后继续执行。</p>
<p>这个时候，有个单线程模型下不存在的问题就来了：如果多个线程同时读写共享变量，会出现数据不一致的问题。</p>
<p>我们来看一个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 多线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">var</span> <span class="variable">add</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AddThread</span>();</span><br><span class="line">        <span class="type">var</span> <span class="variable">dec</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DecThread</span>();</span><br><span class="line">        add.start();</span><br><span class="line">        dec.start();</span><br><span class="line">        add.join();</span><br><span class="line">        dec.join();</span><br><span class="line">        System.out.println(Counter.count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AddThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10000</span>; i++) &#123; Counter.count += <span class="number">1</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DecThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10000</span>; i++) &#123; Counter.count -= <span class="number">1</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码很简单，两个线程同时对一个<code>int</code>变量进行操作，一个加10000次，一个减10000次，最后结果应该是0，但是，每次运行，结果实际上都是不一样的。</p>
<p>这是因为对变量进行读取和写入时，结果要正确，必须保证是原子操作。原子操作是指不能被中断的一个或一系列操作。</p>
<p>例如，对于语句：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">n = n + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>看上去是一行语句，实际上对应了3条指令：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ILOAD</span><br><span class="line">IADD</span><br><span class="line">ISTORE</span><br></pre></td></tr></table></figure>

<p>我们假设<code>n</code>的值是<code>100</code>，如果两个线程同时执行<code>n = n + 1</code>，得到的结果很可能不是<code>102</code>，而是<code>101</code>，原因在于：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">┌───────┐     ┌───────┐</span><br><span class="line">│Thread1│     │Thread2│</span><br><span class="line">└───┬───┘     └───┬───┘</span><br><span class="line">    │             │</span><br><span class="line">    │ILOAD (100)  │</span><br><span class="line">    │             │ILOAD (100)</span><br><span class="line">    │             │IADD</span><br><span class="line">    │             │ISTORE (101)</span><br><span class="line">    │IADD         │</span><br><span class="line">    │ISTORE (101) │</span><br><span class="line">    ▼             ▼</span><br></pre></td></tr></table></figure>

<p>如果线程1在执行<code>ILOAD</code>后被操作系统中断，此刻如果线程2被调度执行，它执行<code>ILOAD</code>后获取的值仍然是<code>100</code>，最终结果被两个线程的<code>ISTORE</code>写入后变成了<code>101</code>，而不是期待的<code>102</code>。</p>
<p>这说明多线程模型下，要保证逻辑正确，对共享变量进行读写时，必须保证一组指令以原子方式执行：即某一个线程执行时，其他线程必须等待：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">┌───────┐     ┌───────┐</span><br><span class="line">│Thread1│     │Thread2│</span><br><span class="line">└───┬───┘     └───┬───┘</span><br><span class="line">    │             │</span><br><span class="line">    │-- lock --   │</span><br><span class="line">    │ILOAD (100)  │</span><br><span class="line">    │IADD         │</span><br><span class="line">    │ISTORE (101) │</span><br><span class="line">    │-- unlock -- │</span><br><span class="line">    │             │-- lock --</span><br><span class="line">    │             │ILOAD (101)</span><br><span class="line">    │             │IADD</span><br><span class="line">    │             │ISTORE (102)</span><br><span class="line">    │             │-- unlock --</span><br><span class="line">    ▼             ▼</span><br></pre></td></tr></table></figure>

<p>通过加锁和解锁的操作，就能保证3条指令总是在一个线程执行期间，不会有其他线程会进入此指令区间。即使在执行期线程被操作系统中断执行，其他线程也会因为无法获得锁导致无法进入此指令区间。只有执行线程将锁释放后，其他线程才有机会获得锁并执行。这种加锁和解锁之间的代码块我们称之为临界区（Critical Section），任何时候临界区最多只有一个线程能执行。</p>
<p>可见，保证一段代码的原子性就是通过加锁和解锁实现的。Java程序使用<code>synchronized</code>关键字对一个对象进行加锁：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(lock) &#123;</span><br><span class="line">    n = n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>synchronized</code>保证了代码块在任意时刻最多只有一个线程能执行。我们把上面的代码用<code>synchronized</code>改写如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 多线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">var</span> <span class="variable">add</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AddThread</span>();</span><br><span class="line">        <span class="type">var</span> <span class="variable">dec</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DecThread</span>();</span><br><span class="line">        add.start();</span><br><span class="line">        dec.start();</span><br><span class="line">        add.join();</span><br><span class="line">        dec.join();</span><br><span class="line">        System.out.println(Counter.count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AddThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Counter.lock) &#123;</span><br><span class="line">                Counter.count += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DecThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Counter.lock) &#123;</span><br><span class="line">                Counter.count -= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意到代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(Counter.lock) &#123; <span class="comment">// 获取锁</span></span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="comment">// 释放锁</span></span><br></pre></td></tr></table></figure>

<p>它表示用<code>Counter.lock</code>实例作为锁，两个线程在执行各自的<code>synchronized(Counter.lock) &#123; ... &#125;</code>代码块时，必须先获得锁，才能进入代码块进行。执行结束后，在<code>synchronized</code>语句块结束会自动释放锁。这样一来，对<code>Counter.count</code>变量进行读写就不可能同时进行。上述代码无论运行多少次，最终结果都是0。</p>
<p>使用<code>synchronized</code>解决了多线程同步访问共享变量的正确性问题。但是，它的缺点是带来了性能下降。因为<code>synchronized</code>代码块无法并发执行。此外，加锁和解锁需要消耗一定的时间，所以，<code>synchronized</code>会降低程序的执行效率。</p>
<p>我们来概括一下如何使用<code>synchronized</code>：</p>
<ol>
<li>找出修改共享变量的线程代码块；</li>
<li>选择一个共享实例作为锁；</li>
<li>使用<code>synchronized(lockObject) &#123; ... &#125;</code>。</li>
</ol>
<p>在使用<code>synchronized</code>的时候，不必担心抛出异常。因为无论是否有异常，都会在<code>synchronized</code>结束处正确释放锁：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> m)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">        <span class="keyword">if</span> (m &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.value += m;</span><br><span class="line">    &#125; <span class="comment">// 无论有无异常，都会在此释放锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们再来看一个错误使用<code>synchronized</code>的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 多线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">var</span> <span class="variable">add</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AddThread</span>();</span><br><span class="line">        <span class="type">var</span> <span class="variable">dec</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DecThread</span>();</span><br><span class="line">        add.start();</span><br><span class="line">        dec.start();</span><br><span class="line">        add.join();</span><br><span class="line">        dec.join();</span><br><span class="line">        System.out.println(Counter.count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AddThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Counter.lock1) &#123;</span><br><span class="line">                Counter.count += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DecThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Counter.lock2) &#123;</span><br><span class="line">                Counter.count -= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果并不是0，这是因为两个线程各自的<code>synchronized</code>锁住的<em>不是同一个对象</em>！这使得两个线程各自都可以同时获得锁：因为JVM只保证同一个锁在任意时刻只能被一个线程获取，但两个不同的锁在同一时刻可以被两个线程分别获取。</p>
<p>因此，使用<code>synchronized</code>的时候，获取到的是哪个锁非常重要。锁对象如果不对，代码逻辑就不对。</p>
<p>我们再看一个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 多线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">var</span> <span class="variable">ts</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>[] &#123; <span class="keyword">new</span> <span class="title class_">AddStudentThread</span>(), <span class="keyword">new</span> <span class="title class_">DecStudentThread</span>(), <span class="keyword">new</span> <span class="title class_">AddTeacherThread</span>(), <span class="keyword">new</span> <span class="title class_">DecTeacherThread</span>() &#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> t : ts) &#123;</span><br><span class="line">            t.start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> t : ts) &#123;</span><br><span class="line">            t.join();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Counter.studentCount);</span><br><span class="line">        System.out.println(Counter.teacherCount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">studentCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">teacherCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AddStudentThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Counter.lock) &#123;</span><br><span class="line">                Counter.studentCount += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DecStudentThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Counter.lock) &#123;</span><br><span class="line">                Counter.studentCount -= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AddTeacherThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Counter.lock) &#123;</span><br><span class="line">                Counter.teacherCount += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DecTeacherThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Counter.lock) &#123;</span><br><span class="line">                Counter.teacherCount -= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码的4个线程对两个共享变量分别进行读写操作，但是使用的锁都是<code>Counter.lock</code>这一个对象，这就造成了原本可以并发执行的<code>Counter.studentCount += 1</code>和<code>Counter.teacherCount += 1</code>，现在无法并发执行了，执行效率大大降低。实际上，需要同步的线程可以分成两组：<code>AddStudentThread</code>和<code>DecStudentThread</code>，<code>AddTeacherThread</code>和<code>DecTeacherThread</code>，组之间不存在竞争，因此，应该使用两个不同的锁，即：</p>
<p><code>AddStudentThread</code>和<code>DecStudentThread</code>使用<code>lockStudent</code>锁：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(Counter.lockStudent) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>AddTeacherThread</code>和<code>DecTeacherThread</code>使用<code>lockTeacher</code>锁：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(Counter.lockTeacher) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样才能最大化地提高执行效率。</p>
<h3 id="不需要synchronized的操作"><a href="#不需要synchronized的操作" class="headerlink" title="不需要synchronized的操作"></a>不需要synchronized的操作</h3><blockquote>
<p><strong>原子操作的定义</strong></p>
<p><strong>原子性（Atomicity）</strong> 是指某个操作不可分割，要么全部执行成功，要么完全不执行。</p>
<p>在多线程环境下，如果一个操作是原子操作，就不会出现线程安全问题。</p>
<p>根据 JVM 规范，以下操作是<strong>天然线程安全的原子操作</strong>，无需使用 synchronized 或其他同步机制</p>
</blockquote>
<h4 id="1-基本类型赋值（long-和-double-除外）"><a href="#1-基本类型赋值（long-和-double-除外）" class="headerlink" title="1. 基本类型赋值（long 和 double 除外）"></a>1. 基本类型赋值（long 和 double 除外）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">10</span>; <span class="comment">// 原子操作</span></span><br><span class="line"><span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span>; <span class="comment">// 原子操作</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>; <span class="comment">// 原子操作</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>JVM 中的基本类型（int、short、byte、char、float、boolean）赋值是单步操作，线程不会在操作中途被切换，因此是安全的。</p>
</li>
<li><p><strong>例外情况</strong>：long 和 double 是 64 位的，在 32 位的 JVM 中赋值可能会被分为两步操作（高位和低位），因此不保证原子性：</p>
</li>
<li><pre><code class="java">long l = 100L; // 非原子操作（可能被拆分为两步）
double d = 10.5; // 非原子操作（可能被拆分为两步）
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- **解决方法：**使用 volatile 修饰 long 或 double，可以保证其赋值操作是原子的：</span><br><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  volatile long l = 100L;</span><br><span class="line">  volatile double d = 10.5;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<h4 id="2-引用类型赋值"><a href="#2-引用类型赋值" class="headerlink" title="2. 引用类型赋值"></a>2. 引用类型赋值</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">// 原子操作</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>(); <span class="comment">// 原子操作</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>引用赋值（将一个对象的引用赋值给变量）是原子操作，因为 JVM 保证引用赋值操作是不可分割的。</p>
</li>
<li><p><strong>为什么是线程安全的？</strong>引用赋值操作仅更改变量的指针（引用），不涉及对象本身的内容，操作是一步完成的，因此不存在中断或数据不一致问题。</p>
</li>
</ul>
<h4 id="3-读取和写入-volatile-变量"><a href="#3-读取和写入-volatile-变量" class="headerlink" title="3. 读取和写入 volatile 变量"></a>3. 读取和写入 volatile 变量</h4><blockquote>
<p>volatile <strong>的特性：</strong></p>
<ul>
<li>保证对变量的 <strong>可见性</strong>（一个线程修改后，其他线程立即可见）。</li>
<li>对于单次的读取和写入操作，volatile 是原子的。</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">count = <span class="number">10</span>; <span class="comment">// 原子操作</span></span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> count; <span class="comment">// 原子操作</span></span><br></pre></td></tr></table></figure>

<p><strong>注意事项：非原子的复合操作</strong></p>
<p>尽管赋值是原子的，但复合操作不是。例如：自增和自减</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">count++; <span class="comment">// 非原子操作</span></span><br></pre></td></tr></table></figure>

<p>count++ 的实际操作是：</p>
<ol>
<li>读取 count 的值。</li>
<li>将值加 1。</li>
<li>将结果写回 count。</li>
</ol>
<p>多个线程同时执行 count++ 时，可能发生竞态条件，导致结果不正确。</p>
<h3 id="不可变对象无需同步"><a href="#不可变对象无需同步" class="headerlink" title="不可变对象无需同步"></a>不可变对象无需同步</h3><p>如果多线程读写的是一个不可变对象，那么无需同步，因为不会修改对象的状态：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Data</span> &#123;</span><br><span class="line">    List&lt;String&gt; names;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(String[] names)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.names = List.of(names);</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;String&gt; <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.names;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意到<code>set()</code>方法内部创建了一个不可变<code>List</code>，这个<code>List</code>包含的对象也是不可变对象<code>String</code>，因此，整个<code>List&lt;String&gt;</code>对象都是不可变的，因此读写均无需同步。</p>
<p>分析变量是否能被多线程访问时，首先要理清概念，多线程同时执行的是方法。对于下面这个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Status</span> &#123;</span><br><span class="line">    List&lt;String&gt; names;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(String[] names, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        List&lt;String&gt; ns = List.of(names);</span><br><span class="line">        <span class="built_in">this</span>.names = ns;</span><br><span class="line">        <span class="type">int</span> <span class="variable">step</span> <span class="operator">=</span> n * <span class="number">10</span>;</span><br><span class="line">        <span class="built_in">this</span>.x += step;</span><br><span class="line">        <span class="built_in">this</span>.y += step;</span><br><span class="line">    &#125;</span><br><span class="line">    StatusRecord <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StatusRecord</span>(<span class="built_in">this</span>.names, <span class="built_in">this</span>.x, <span class="built_in">this</span>.y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-多线程执行方法时的可能场景"><a href="#1-多线程执行方法时的可能场景" class="headerlink" title="1.多线程执行方法时的可能场景"></a>1.多线程执行方法时的可能场景</h4><p>假设有两个线程 A 和 B，同时对 Status 类操作，以下情况可能发生：</p>
<ul>
<li><strong>同时执行</strong> set() <strong>方法</strong>：两个线程可能同时写入共享变量 names、x 和 y。</li>
<li><strong>同时执行</strong> get() <strong>方法</strong>：两个线程可能同时读取 names、x 和 y，这不会导致问题，因为读取是线程安全的。</li>
<li><strong>一个线程执行</strong> set()<strong>，另一个线程执行</strong> get()：这是关键问题，因为一个线程在写共享变量时，另一个线程正在读取这些变量，可能导致读取到不一致的数据。</li>
</ul>
<h4 id="2-局部变量的线程安全性"><a href="#2-局部变量的线程安全性" class="headerlink" title="2.局部变量的线程安全性"></a><strong>2.局部变量的线程安全性</strong></h4><ul>
<li><strong>局部变量是线程安全的</strong>，因为它们存储在每个线程的栈上，线程栈是独立的，互不干扰。</li>
<li>只要局部变量没有逃逸（没有被外部引用或传递到其他线程），它们的生命周期和作用范围仅限于当前线程。</li>
</ul>
<p>在 set() 方法中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; ns = List.of(names);</span><br><span class="line"><span class="type">int</span> <span class="variable">step</span> <span class="operator">=</span> n * <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>ns <strong>和</strong> step <strong>是局部变量：</strong></p>
<ul>
<li>每个线程调用 set() 时都会在自己线程的栈中创建独立的 ns 和 step。</li>
<li>即使两个线程同时调用 set()，它们各自的 ns 和 step 互不干扰。</li>
</ul>
<p><strong>局部变量的逃逸：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.names = ns;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>当 ns 被赋值给类的成员变量 this.names 时，ns 的引用变得可见于其他线程。</p>
</li>
<li><p>这意味着其他线程可能同时读取或写入 names，需要通过同步机制保护。</p>
</li>
</ul>
<h4 id="3-同步的必要性"><a href="#3-同步的必要性" class="headerlink" title="3. 同步的必要性"></a><strong>3. 同步的必要性</strong></h4><p><strong>为什么同步？</strong></p>
<ul>
<li><em>成员变量（如</em>* names<strong>、</strong>x<strong>、</strong>y<strong>）是共享资源</strong>：</li>
<li>它们存储在堆上，可以被多个线程访问。</li>
<li>如果没有同步机制，可能会发生竞态条件（Race Condition），导致数据不一致。</li>
<li>在 set() 中，this.names &#x3D; ns; 和 this.x +&#x3D; step;、this.y +&#x3D; step; 是对共享变量的修改，必须通过 synchronized 来保护。</li>
</ul>
<p>优化后的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">set</span><span class="params">(String[] names, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="comment">// 局部变量其他线程不可见:</span></span><br><span class="line">    List&lt;String&gt; ns = List.of(names);</span><br><span class="line">    <span class="type">int</span> <span class="variable">step</span> <span class="operator">=</span> n * <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.names = ns;</span><br><span class="line">        <span class="built_in">this</span>.x += step;</span><br><span class="line">        <span class="built_in">this</span>.y += step;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>仅对修改共享资源的代码加锁（this.names、this.x、this.y）。<strong>好处：</strong></p>
<ul>
<li>避免了锁定整个方法，提升性能。</li>
<li>局部变量仍然在线程的栈中，完全不受同步影响。</li>
</ul>
<h4 id="4-get-方法中的问题"><a href="#4-get-方法中的问题" class="headerlink" title="4. get() 方法中的问题"></a><strong>4. get() 方法中的问题</strong></h4><p>在多线程环境中，如果一个线程执行 set() 时，另一个线程正在执行 get()，可能导致数据不一致：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StatusRecord <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StatusRecord</span>(<span class="built_in">this</span>.names, <span class="built_in">this</span>.x, <span class="built_in">this</span>.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>get() 方法直接返回共享变量 names、x、y 的值，但它们可能正在被另一个线程修改。</li>
<li>如果要保证读取时的一致性，可以对 get() 加锁：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StatusRecord</span>(<span class="built_in">this</span>.names, <span class="built_in">this</span>.x, <span class="built_in">this</span>.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完整代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Status</span> &#123;</span><br><span class="line">    List&lt;String&gt; names;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(String[] names, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.names = List.of(names);</span><br><span class="line">            <span class="built_in">this</span>.x += n * <span class="number">10</span>;</span><br><span class="line">            <span class="built_in">this</span>.y += n * <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> StatusRecord <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StatusRecord</span>(<span class="built_in">this</span>.names, <span class="built_in">this</span>.x, <span class="built_in">this</span>.y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>synchronized (this) 和 synchronized StatusRecord get() 使用的是<strong>同一个锁</strong>，即当前对象实例的锁（this 的锁）。</p>
<blockquote>
<p>synchronized (this) 的锁</p>
<ul>
<li>synchronized (this) 显式指定锁对象为 this，即当前 Status 类的实例。</li>
<li>每个实例都有自己独立的锁，多个线程要想进入 synchronized (this) 保护的代码块，必须先获取当前对象实例的锁。</li>
</ul>
<p>synchronized 方法的锁</p>
<ul>
<li><p>声明为 synchronized 的非静态方法（如 synchronized StatusRecord get()）<strong>隐式地锁定当前实例对象</strong>。</p>
<ul>
<li><p>等效于在方法体外包裹 synchronized (this)：</p>
</li>
<li><pre><code class="java">StatusRecord get() &#123;
    synchronized (this) &#123;  // 锁定当前对象
        return new StatusRecord(this.names, this.x, this.y);
    &#125;
&#125;
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- **静态方法的不同**：如果方法是 static synchronized，它使用的锁是**类对象的锁**（Class 对象的锁），而不是实例锁。</span><br><span class="line"></span><br><span class="line">  - ```java</span><br><span class="line">    StatusRecord get() &#123;</span><br><span class="line">        synchronized (this) &#123;  // 锁定当前对象</span><br><span class="line">            return new StatusRecord(this.names, this.x, this.y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>static synchronized 使用的锁是 Status.class。</p>
</li>
<li><p>它与 synchronized (this) 和非静态 synchronized 方法使用的锁不同。</p>
</li>
</ul>
</li>
</ul>
</blockquote>
<p>demo:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Status</span> <span class="variable">status</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Status</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建线程 A，执行 set() 方法</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            status.set(<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Bob&quot;</span>&#125;, <span class="number">1</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;Thread A&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建线程 B，执行 get() 方法</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            status.get();</span><br><span class="line">        &#125;, <span class="string">&quot;Thread B&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动线程</span></span><br><span class="line">        threadA.start();</span><br><span class="line">        threadB.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>线程 A 获取锁：</p>
<ul>
<li>线程 A 在进入 set() 方法时，锁定了 this。</li>
<li>其他线程必须等待线程 A 完成并释放锁。</li>
</ul>
<p>	</p>
</li>
<li><p>线程 B 被阻塞：</p>
<ul>
<li>线程 B 调用 get() 时，发现 this 的锁已被线程 A 占用。</li>
<li>线程 B 进入阻塞状态，直到线程 A 释放锁。</li>
</ul>
</li>
<li><p>互斥保证一致性：</p>
<ul>
<li>无论线程 A 如何修改共享变量，线程 B 在读取时都能看到完整的状态，不会读取到中间状态的数据。</li>
</ul>
</li>
</ul>
<h2 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h2><p>我们知道Java程序依靠<code>synchronized</code>对线程进行同步，使用<code>synchronized</code>的时候，锁住的是哪个对象非常重要。</p>
<p>让线程自己选择锁对象往往会使得代码逻辑混乱，也不利于封装。更好的方法是把<code>synchronized</code>逻辑封装起来。例如，我们编写一个计数器如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;</span><br><span class="line">            count += n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dec</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;</span><br><span class="line">            count -= n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样一来，线程调用<code>add()</code>、<code>dec()</code>方法时，它不必关心同步逻辑，因为<code>synchronized</code>代码块在<code>add()</code>、<code>dec()</code>方法内部。并且，我们注意到，<code>synchronized</code>锁住的对象是<code>this</code>，即当前实例，这又使得创建多个<code>Counter</code>实例的时候，它们之间互不影响，可以并发执行：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">c1</span> <span class="operator">=</span> Counter();</span><br><span class="line"><span class="type">var</span> <span class="variable">c2</span> <span class="operator">=</span> Counter();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对c1进行操作的线程:</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    c1.add();</span><br><span class="line">&#125;).start();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    c1.dec();</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对c2进行操作的线程:</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    c2.add();</span><br><span class="line">&#125;).start();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    c2.dec();</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure>

<p>现在，对于<code>Counter</code>类，多线程可以正确调用。</p>
<p>如果一个类被设计为允许多线程正确访问，我们就说这个类就是“线程安全”的（thread-safe），上面的<code>Counter</code>类就是线程安全的。Java标准库的<code>java.lang.StringBuffer</code>也是线程安全的。</p>
<p>还有一些不变类，例如<code>String</code>，<code>Integer</code>，<code>LocalDate</code>，它们的所有成员变量都是<code>final</code>，多线程同时访问时只能读不能写，这些不变类也是线程安全的。</p>
<p>最后，类似<code>Math</code>这些只提供静态方法，没有成员变量的类，也是线程安全的。</p>
<p>除了上述几种少数情况，大部分类，例如<code>ArrayList</code>，都是非线程安全的类，我们不能在多线程中修改它们。但是，如果所有线程都只读取，不写入，那么<code>ArrayList</code>是可以安全地在线程间共享的。</p>
<blockquote>
<p>提示</p>
<p>没有特殊说明时，一个类默认是非线程安全的。</p>
</blockquote>
<p>我们再观察<code>Counter</code>的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;</span><br><span class="line">            count += n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们锁住的是<code>this</code>实例时，实际上可以用<code>synchronized</code>修饰这个方法。下面两种写法是等价的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123; <span class="comment">// 锁住this</span></span><br><span class="line">        count += n;</span><br><span class="line">    &#125; <span class="comment">// 解锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写法二：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> n)</span> &#123; <span class="comment">// 锁住this</span></span><br><span class="line">    count += n;</span><br><span class="line">&#125; <span class="comment">// 解锁</span></span><br></pre></td></tr></table></figure>

<p>因此，用<code>synchronized</code>修饰的方法就是同步方法，它表示整个方法都必须用<code>this</code>实例加锁。</p>
<p>我们再思考一下，如果对一个静态方法添加<code>synchronized</code>修饰符，它锁住的是哪个对象？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于<code>static</code>方法，是没有<code>this</code>实例的，因为<code>static</code>方法是针对类而不是实例。但是我们注意到任何一个类都有一个由JVM自动创建的<code>Class</code>实例，因此，对<code>static</code>方法添加<code>synchronized</code>，锁住的是该类的<code>Class</code>实例。上述<code>synchronized static</code>方法实际上相当于：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(Counter.class) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们再考察<code>Counter</code>的<code>get()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它没有同步，因为读一个<code>int</code>变量不需要同步。</p>
<blockquote>
<p>读取 count 是原子的，int 类型的变量在读取时不会受到中断。</p>
<p>因此，在多线程环境中，即使其他线程同时修改 count，读取操作仍然是安全的。</p>
</blockquote>
<p>然而，如果我们把代码稍微改一下，返回一个包含两个<code>int</code>的对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> first;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> last;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Pair <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Pair</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Pair</span>();</span><br><span class="line">        p.first = first;</span><br><span class="line">        p.last = last;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就必须要同步了。</p>
<blockquote>
<p><strong>问题分析：</strong></p>
<ul>
<li>first 和 last 是两个独立的变量。</li>
<li>在多线程环境中，如果一个线程调用 get() 方法，另一个线程正在修改 first 或 last，就可能导致读取到的值不一致。</li>
<li>例如：<ul>
<li><strong>线程 A：</strong> 正在调用 get()，读取 first 的值。</li>
<li><strong>线程 B：</strong> 在此时修改了 last。</li>
<li><strong>结果：</strong> get() 返回的 Pair 对象中的 first 和 last 可能属于不同的时间点的状态，数据不一致。</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>Java的线程锁是可重入的锁。</p>
<p>什么是可重入的锁？我们还是来看例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            dec(-n);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            count += n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">dec</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        count += n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>观察<code>synchronized</code>修饰的<code>add()</code>方法，一旦线程执行到<code>add()</code>方法内部，说明它已经获取了当前实例的<code>this</code>锁。如果传入的<code>n &lt; 0</code>，将在<code>add()</code>方法内部调用<code>dec()</code>方法。由于<code>dec()</code>方法也需要获取<code>this</code>锁，现在问题来了：</p>
<p>对同一个线程，能否在获取到锁以后继续获取同一个锁？</p>
<p>答案是肯定的。JVM允许同一个线程重复获取同一个锁，这种能被同一个线程反复获取的锁，就叫做<strong>可重入锁</strong>。</p>
<p>由于Java的线程锁是可重入锁，所以，获取锁的时候，不但要判断是否是第一次获取，还要记录这是第几次获取。每获取一次锁，记录+1，每退出<code>synchronized</code>块，记录-1，减到0的时候，才会真正释放锁。</p>
<h3 id="死锁-1"><a href="#死锁-1" class="headerlink" title="死锁"></a>死锁</h3><p>一个线程可以获取一个锁后，再继续获取另一个锁。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> m)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(lockA) &#123; <span class="comment">// 获得lockA的锁</span></span><br><span class="line">        <span class="built_in">this</span>.value += m;</span><br><span class="line">        <span class="keyword">synchronized</span>(lockB) &#123; <span class="comment">// 获得lockB的锁</span></span><br><span class="line">            <span class="built_in">this</span>.another += m;</span><br><span class="line">        &#125; <span class="comment">// 释放lockB的锁</span></span><br><span class="line">    &#125; <span class="comment">// 释放lockA的锁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dec</span><span class="params">(<span class="type">int</span> m)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(lockB) &#123; <span class="comment">// 获得lockB的锁</span></span><br><span class="line">        <span class="built_in">this</span>.another -= m;</span><br><span class="line">        <span class="keyword">synchronized</span>(lockA) &#123; <span class="comment">// 获得lockA的锁</span></span><br><span class="line">            <span class="built_in">this</span>.value -= m;</span><br><span class="line">        &#125; <span class="comment">// 释放lockA的锁</span></span><br><span class="line">    &#125; <span class="comment">// 释放lockB的锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在获取多个锁的时候，不同线程获取多个不同对象的锁可能导致死锁。对于上述代码，线程1和线程2如果分别执行<code>add()</code>和<code>dec()</code>方法时：</p>
<ul>
<li>线程1：进入<code>add()</code>，获得<code>lockA</code>；</li>
<li>线程2：进入<code>dec()</code>，获得<code>lockB</code>。</li>
</ul>
<p>随后：</p>
<ul>
<li>线程1：准备获得<code>lockB</code>，失败，等待中；</li>
<li>线程2：准备获得<code>lockA</code>，失败，等待中。</li>
</ul>
<p>此时，两个线程各自持有不同的锁，然后各自试图获取对方手里的锁，造成了双方无限等待下去，这就是死锁。</p>
<p>死锁发生后，没有任何机制能解除死锁，只能强制结束JVM进程。</p>
<p>因此，在编写多线程应用时，要特别注意防止死锁。因为死锁一旦形成，就只能强制结束进程。</p>
<p>那么我们应该如何避免死锁呢？答案是：线程获取锁的顺序要一致。即严格按照先获取<code>lockA</code>，再获取<code>lockB</code>的顺序，改写<code>dec()</code>方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dec</span><span class="params">(<span class="type">int</span> m)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(lockA) &#123; <span class="comment">// 获得lockA的锁</span></span><br><span class="line">        <span class="built_in">this</span>.value -= m;</span><br><span class="line">        <span class="keyword">synchronized</span>(lockB) &#123; <span class="comment">// 获得lockB的锁</span></span><br><span class="line">            <span class="built_in">this</span>.another -= m;</span><br><span class="line">        &#125; <span class="comment">// 释放lockB的锁</span></span><br><span class="line">    &#125; <span class="comment">// 释放lockA的锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用wait和notify"><a href="#使用wait和notify" class="headerlink" title="使用wait和notify"></a>使用wait和notify</h2><p>在Java程序中，<code>synchronized</code>解决了多线程竞争的问题。例如，对于一个任务管理器，多个线程同时往队列中添加任务，可以用<code>synchronized</code>加锁：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TaskQueue</span> &#123;</span><br><span class="line">    Queue&lt;String&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">addTask</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.queue.add(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是<code>synchronized</code>并没有解决多线程协调的问题。</p>
<p>仍然以上面的<code>TaskQueue</code>为例，我们再编写一个<code>getTask()</code>方法取出队列的第一个任务：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TaskQueue</span> &#123;</span><br><span class="line">    Queue&lt;String&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">addTask</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.queue.add(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title function_">getTask</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (queue.isEmpty()) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> queue.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码看上去没有问题：<code>getTask()</code>内部先判断队列是否为空，如果为空，就循环等待，直到另一个线程往队列中放入了一个任务，<code>while()</code>循环退出，就可以返回队列的元素了。</p>
<p>但实际上<code>while()</code>循环永远不会退出。因为线程在执行<code>while()</code>循环时，已经在<code>getTask()</code>入口获取了<code>this</code>锁，其他线程根本无法调用<code>addTask()</code>，因为<code>addTask()</code>执行条件也是获取<code>this</code>锁。</p>
<p>因此，执行上述代码，线程会在<code>getTask()</code>中因为死循环而100%占用CPU资源。</p>
<p>如果深入思考一下，我们想要的执行效果是：</p>
<ul>
<li>线程1可以调用<code>addTask()</code>不断往队列中添加任务；</li>
<li>线程2可以调用<code>getTask()</code>从队列中获取任务。如果队列为空，则<code>getTask()</code>应该等待，直到队列中至少有一个任务时再返回。</li>
</ul>
<p>因此，多线程协调运行的原则就是：当条件不满足时，线程进入等待状态；当条件满足时，线程被唤醒，继续执行任务。</p>
<p>对于上述<code>TaskQueue</code>，我们先改造<code>getTask()</code>方法，在条件不满足时，线程进入等待状态：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title function_">getTask</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (queue.isEmpty()) &#123;</span><br><span class="line">        <span class="built_in">this</span>.wait();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> queue.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当一个线程执行到<code>getTask()</code>方法内部的<code>while</code>循环时，它必定已经获取到了<code>this</code>锁，此时，线程执行<code>while</code>条件判断，如果条件成立（队列为空），线程将执行<code>this.wait()</code>，进入等待状态。</p>
<p>这里的关键是：<code>wait()</code>方法必须在当前获取的锁对象上调用，这里获取的是<code>this</code>锁，因此调用<code>this.wait()</code>。</p>
<p>调用<code>wait()</code>方法后，线程进入等待状态，<code>wait()</code>方法不会返回，直到将来某个时刻，线程从等待状态被其他线程唤醒后，<code>wait()</code>方法才会返回，然后，继续执行下一条语句。</p>
<p>有些仔细的童鞋会指出：即使线程在<code>getTask()</code>内部等待，其他线程如果拿不到<code>this</code>锁，照样无法执行<code>addTask()</code>，肿么办？</p>
<p>这个问题的关键就在于<code>wait()</code>方法的执行机制非常复杂。首先，它不是一个普通的Java方法，而是定义在<code>Object</code>类的一个<code>native</code>方法，也就是由JVM的C代码实现的。其次，必须在<code>synchronized</code>块中才能调用<code>wait()</code>方法，因为<code>wait()</code>方法调用时，会<em>释放</em>线程获得的锁，<code>wait()</code>方法返回时，线程又会重新试图获得锁。</p>
<p>因此，只能在锁对象上调用<code>wait()</code>方法。因为在<code>getTask()</code>中，我们获得了<code>this</code>锁，因此，只能在<code>this</code>对象上调用<code>wait()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title function_">getTask</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (queue.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 释放this锁:</span></span><br><span class="line">        <span class="built_in">this</span>.wait();</span><br><span class="line">        <span class="comment">// 重新获取this锁</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> queue.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当一个线程在<code>this.wait()</code>等待时，它就会释放<code>this</code>锁，从而使得其他线程能够在<code>addTask()</code>方法获得<code>this</code>锁。</p>
<p>现在我们面临第二个问题：如何让等待的线程被重新唤醒，然后从<code>wait()</code>方法返回？答案是在相同的锁对象上调用<code>notify()</code>方法。我们修改<code>addTask()</code>如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">addTask</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.queue.add(s);</span><br><span class="line">    <span class="built_in">this</span>.notify(); <span class="comment">// 唤醒在this锁等待的线程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意到在往队列中添加了任务后，线程立刻对<code>this</code>锁对象调用<code>notify()</code>方法，这个方法会唤醒一个正在<code>this</code>锁等待的线程（就是在<code>getTask()</code>中位于<code>this.wait()</code>的线程），从而使得等待线程从<code>this.wait()</code>方法返回。</p>
<p>我们来看一个完整的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">var</span> <span class="variable">q</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TaskQueue</span>();</span><br><span class="line">        <span class="type">var</span> <span class="variable">ts</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Thread&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="type">var</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="comment">// 执行task:</span></span><br><span class="line">                    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> q.getTask();</span><br><span class="line">                            System.out.println(<span class="string">&quot;execute task: &quot;</span> + s);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            t.start();</span><br><span class="line">            ts.add(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">var</span> <span class="variable">add</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="comment">// 放入task:</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;t-&quot;</span> + Math.random();</span><br><span class="line">                System.out.println(<span class="string">&quot;add task: &quot;</span> + s);</span><br><span class="line">                q.addTask(s);</span><br><span class="line">                <span class="keyword">try</span> &#123; Thread.sleep(<span class="number">100</span>); &#125; <span class="keyword">catch</span>(InterruptedException e) &#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        add.start();</span><br><span class="line">        add.join();</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> t : ts) &#123;</span><br><span class="line">            t.interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TaskQueue</span> &#123;</span><br><span class="line">    Queue&lt;String&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">addTask</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.queue.add(s);</span><br><span class="line">        <span class="built_in">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title function_">getTask</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">while</span> (queue.isEmpty()) &#123;</span><br><span class="line">            <span class="built_in">this</span>.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> queue.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个例子中，我们重点关注<code>addTask()</code>方法，内部调用了<code>this.notifyAll()</code>而不是<code>this.notify()</code>，使用<code>notifyAll()</code>将唤醒所有当前正在<code>this</code>锁等待的线程，而<code>notify()</code>只会唤醒其中一个（具体哪个依赖操作系统，有一定的随机性）。这是因为可能有多个线程正在<code>getTask()</code>方法内部的<code>wait()</code>中等待，使用<code>notifyAll()</code>将一次性全部唤醒。通常来说，<code>notifyAll()</code>更安全。有些时候，如果我们的代码逻辑考虑不周，用<code>notify()</code>会导致只唤醒了一个线程，而其他线程可能永远等待下去醒不过来了。</p>
<p>但是，注意到<code>wait()</code>方法返回时需要<em>重新</em>获得<code>this</code>锁。假设当前有3个线程被唤醒，唤醒后，首先要等待执行<code>addTask()</code>的线程结束此方法后，才能释放<code>this</code>锁，随后，这3个线程中只能有一个获取到<code>this</code>锁，剩下两个将继续等待。</p>
<p>再注意到我们在<code>while()</code>循环中调用<code>wait()</code>，而不是<code>if</code>语句：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title function_">getTask</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (queue.isEmpty()) &#123;</span><br><span class="line">        <span class="built_in">this</span>.wait();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> queue.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种写法实际上是错误的，因为线程被唤醒时，需要再次获取<code>this</code>锁。多个线程被唤醒后，只有一个线程能获取<code>this</code>锁，此刻，该线程执行<code>queue.remove()</code>可以获取到队列的元素，然而，剩下的线程如果获取<code>this</code>锁后执行<code>queue.remove()</code>，此刻队列可能已经没有任何元素了，所以，要始终在<code>while</code>循环中<code>wait()</code>，并且每次被唤醒后拿到<code>this</code>锁就必须再次判断：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (queue.isEmpty()) &#123;</span><br><span class="line">    <span class="built_in">this</span>.wait();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以，正确编写多线程代码是非常困难的，需要仔细考虑的条件非常多，任何一个地方考虑不周，都会导致多线程运行时不正常。</p>
<h3 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h3><p><code>wait</code>和<code>notify</code>用于多线程协调运行：</p>
<ul>
<li>在<code>synchronized</code>内部可以调用<code>wait()</code>使线程进入等待状态；</li>
<li>必须在已获得的锁对象上调用<code>wait()</code>方法；</li>
<li>在<code>synchronized</code>内部可以调用<code>notify()</code>或<code>notifyAll()</code>唤醒其他等待线程；</li>
<li>必须在已获得的锁对象上调用<code>notify()</code>或<code>notifyAll()</code>方法；</li>
<li>已唤醒的线程还需要重新获得锁后才能继续执行。</li>
</ul>
<h1 id="深拷贝与浅拷贝"><a href="#深拷贝与浅拷贝" class="headerlink" title="深拷贝与浅拷贝"></a>深拷贝与浅拷贝</h1><ol>
<li><p>利用序列化和反序列化实现深拷贝的原理</p>
<ul>
<li>当对一个对象进行序列化时，对象的状态（包括基本数据类型成员变量的值和引用数据类型成员变量所指向对象的状态）会被转换为字节流。在反序列化过程中，会根据字节流重新构建对象。这个重新构建的过程实际上是创建了全新的对象，而不是简单地复制引用。</li>
<li>对于引用数据类型的成员变量，会根据字节流中的信息重新创建这些对象，而不是共享原始对象的引用。这样就实现了深拷贝，即新对象和原始对象在内存中是完全独立的，修改其中一个对象不会影响到另一个对象。</li>
</ul>
</li>
<li><p>示例代码实现步骤</p>
<ul>
<li>步骤一：定义可序列化的类<ul>
<li>假设有一个<code>Person</code>类，包含基本数据类型的<code>age</code>和引用数据类型的<code>Address</code>。<code>Address</code>类也需要是可序列化的。</li>
</ul>
</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Address</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String city;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Address</span><span class="params">(String city)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.city = city;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getCity</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> city;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCity</span><span class="params">(String city)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.city = city;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> Address address;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(<span class="type">int</span> age, Address address)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Address <span class="title function_">getAddress</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> address;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAddress</span><span class="params">(Address address)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>步骤二：实现深拷贝的方法<ul>
<li>在<code>Person</code>类中可以定义一个方法来进行深拷贝，通过序列化和反序列化来实现。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.ByteArrayInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="comment">// 前面的成员变量和构造函数等代码省略</span></span><br><span class="line">    <span class="keyword">public</span> Person <span class="title function_">deepCopy</span><span class="params">()</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(bos);</span><br><span class="line">        oos.writeObject(<span class="built_in">this</span>);</span><br><span class="line">        <span class="type">ByteArrayInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(bos.toByteArray());</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(bis);</span><br><span class="line">        <span class="keyword">return</span> (Person) ois.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码定义了一个名为<code>deepCopy</code>的方法，用于在 Java 中通过序列化和反序列化的机制实现对<code>Person</code>对象的深拷贝。其目的是创建一个与原始<code>Person</code>对象完全独立的副本，使得对副本对象的修改不会影响到原始对象。</p>
<h3 id="代码逐行分析"><a href="#代码逐行分析" class="headerlink" title="代码逐行分析"></a>代码逐行分析</h3><ol>
<li><strong>创建字节数组输出流对象</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ByteArrayOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br></pre></td></tr></table></figure>

<p>这里创建了一个<code>ByteArrayOutputStream</code>对象<code>bos</code>。<code>ByteArrayOutputStream</code>是一个可以将数据写入字节数组的输出流类。它的作用是在内存中开辟一块缓冲区，用于暂存即将要序列化的<code>Person</code>对象转化成的字节流数据。</p>
<ol>
<li><strong>创建对象输出流对象并关联字节数组输出流</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(bos);</span><br></pre></td></tr></table></figure>

<p>创建了一个<code>ObjectOutputStream</code>对象<code>oos</code>，并将之前创建的<code>ByteArrayOutputStream</code>对象<code>bos</code>作为参数传递给它。<code>ObjectOutputStream</code>用于将对象转换为字节流进行序列化操作。通过这种关联，后续调用<code>oos.writeObject(this)</code>时，会将<code>Person</code>对象（由<code>this</code>指代当前对象，也就是调用<code>deepCopy</code>方法的那个<code>Person</code>对象）序列化后的字节流数据写入到<code>bos</code>所指向的内存缓冲区中。</p>
<ol>
<li><strong>执行对象序列化操作</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">oos.writeObject(<span class="built_in">this</span>);</span><br></pre></td></tr></table></figure>

<p>这行代码是真正执行对象序列化的步骤。<code>writeObject</code>方法是<code>ObjectOutputStream</code>类的核心方法之一，它会根据<code>Person</code>对象的内部结构（包括其成员变量的类型和值等信息），将整个<code>Person</code>对象转换为字节流，并将这些字节流数据写入到与之关联的<code>ByteArrayOutputStream</code>（即<code>bos</code>）的内存缓冲区中。此时，<code>Person</code>对象的所有状态信息，包括基本数据类型的属性值以及引用数据类型所指向对象的状态（如果引用类型也可序列化），都被转化成了字节流形式存储在<code>bos</code>的缓冲区中。</p>
<ol>
<li><strong>创建字节数组输入流对象</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ByteArrayInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(bos.toByteArray());</span><br></pre></td></tr></table></figure>

<p>在完成对象的序列化并将字节流数据暂存到<code>bos</code>的缓冲区后，接下来要进行反序列化操作以重建对象。首先创建一个<code>ByteArrayInputStream</code>对象<code>bis</code>，它的构造函数接受一个字节数组作为参数。这里通过调用<code>bos.toByteArray()</code>获取到存储在<code>ByteArrayOutputStream</code>缓冲区中的字节流数据数组，并将其作为参数传递给<code>ByteArrayInputStream</code>的构造函数，使得<code>bis</code>可以从这个字节流数据数组中读取数据，为后续的反序列化操作做准备。</p>
<ol>
<li><strong>创建对象输入流对象并关联字节数组输入流</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(bis);</span><br></pre></td></tr></table></figure>

<p>创建一个<code>ObjectInputStream</code>对象<code>ois</code>，并将刚才创建的<code>ByteArrayInputStream</code>对象<code>bis</code>作为参数传递给它。<code>ObjectInputStream</code>用于从字节流中读取数据并将其转换为对象，也就是执行反序列化操作。通过这种关联，后续<code>ois.readObject()</code>就能从<code>bis</code>所指向的字节流数据中读取并重建<code>Person</code>对象。</p>
<ol>
<li><strong>执行对象反序列化操作并返回拷贝后的对象</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> (Person) ois.readObject();</span><br></pre></td></tr></table></figure>

<p>这行代码执行反序列化的核心操作。<code>readObject</code>方法是<code>ObjectInputStream</code>类的核心方法之一，它会从与之关联的<code>ByteArrayInputStream</code>（即<code>bis</code>）所提供的字节流数据中读取信息，并根据这些信息重建一个<code>Person</code>对象。由于<code>readObject</code>方法返回的是一个<code>Object</code>类型的对象，所以需要将其强制转换为<code>Person</code>类型，以符合方法定义的返回值类型要求，最后将这个重建的<code>Person</code>对象作为深拷贝的结果返回。</p>
<p>通过以上一系列步骤，实现了对<code>Person</code>对象的深拷贝，创建出一个与原始<code>Person</code>对象在内存中完全独立的副本对象。</p>
<ul>
<li>步骤三：测试深拷贝<ul>
<li>可以通过以下代码来测试深拷贝的效果。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeepCopySerializationTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">        <span class="type">Address</span> <span class="variable">address</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Address</span>(<span class="string">&quot;Beijing&quot;</span>);</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">20</span>, address);</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person2</span> <span class="operator">=</span> person1.deepCopy();</span><br><span class="line">        System.out.println(<span class="string">&quot;Before change:&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;person1&#x27;s age: &quot;</span> + person1.getAge() + <span class="string">&quot;, address city: &quot;</span> + person1.getAddress().getCity());</span><br><span class="line">        System.out.println(<span class="string">&quot;person2&#x27;s age: &quot;</span> + person2.getAge() + <span class="string">&quot;, address city: &quot;</span> + person2.getAddress().getCity());</span><br><span class="line">        person2.setAge(<span class="number">21</span>);</span><br><span class="line">        person2.getAddress().setCity(<span class="string">&quot;Shanghai&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;After change:&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;person1&#x27;s age: &quot;</span> + person1.getAge() + <span class="string">&quot;, address city: &quot;</span> + person1.getAddress().getCity());</span><br><span class="line">        System.out.println(<span class="string">&quot;person2&#x27;s age: &quot;</span> + person2.getAge() + <span class="string">&quot;, address city: &quot;</span> + person2.getAddress().getCity());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在这个测试代码中，首先创建了<code>person1</code>，然后通过<code>deepCopy</code>方法得到<code>person2</code>。当修改<code>person2</code>的<code>age</code>和<code>Address</code>的<code>city</code>属性时，<code>person1</code>的相应属性不会受到影响，这就验证了通过序列化和反序列化实现了深拷贝。</li>
</ul>
<ol>
<li>注意事项<ul>
<li><strong>类必须实现<code>Serializable</code>接口</strong>：参与序列化和反序列化过程的类（包括包含引用数据类型成员变量的类及其引用的类）都必须实现<code>Serializable</code>接口，否则会抛出<code>NotSerializableException</code>异常。</li>
<li><strong>性能考虑</strong>：序列化和反序列化操作会带来一定的性能开销。这包括对象转换为字节流和字节流转换回对象的时间成本，以及字节流的存储或传输成本。如果对性能要求较高，需要谨慎使用这种方式来实现深拷贝。</li>
</ul>
</li>
</ol>
<h1 id="Java-IO操作"><a href="#Java-IO操作" class="headerlink" title="Java IO操作"></a>Java IO操作</h1><p>IO 即 Input&#x2F;Output，数据输入到计算机内存的过程即输入，反之输出到外部存储（比如数据库，文件，远程主机）的过程即输出。数据传输过程类似于水流，因此称为 IO 流。IO 流在 Java 中分为输入流和输出流，而根据数据的处理方式又分为字节流和字符流。</p>
<p>字节输入流FileInputStream（它用于从文件系统中的文件读取数据）。<u>当你实例化FileInputStream时，实际上是创建一个对象，这个对象可以用来打开一个到文件的输入流通道，以便后续从该文件中读取数据。</u></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;文件路径&quot;</span>);</span><br></pre></td></tr></table></figure>

<img src="image-20241027203118411.png" class title="image-20241027203118411">

<h2 id="InputStream（字节输入流）"><a href="#InputStream（字节输入流）" class="headerlink" title="InputStream（字节输入流）"></a>InputStream（字节输入流）</h2><p>常见的字节输入流FileInputStream（它用于从文件系统中的文件读取数据）。<u>当你实例化FileInputStream时，实际上是创建一个对象，这个对象可以用来打开一个到文件的输入流通道，以便后续从该文件中读取数据。</u></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;文件路径&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><font color="blue">值得注意的是</font><code>InputStream</code>本身不会直接进行硬盘数据的读取操作，它只是在需要读取数据时，通过调用底层系统的 I&#x2F;O 函数（这些函数会和硬件驱动等进行交互）来从已经定位的地址处获取数据。</p>
<p>InputStream常用方法：</p>
<p>（1）read():</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">从输入流中读取下一个数据字节。 值字节返回`int` ，范围为`0`至`255` 。 如果由于到达流末尾而没有可用字节，则返回值`-1` 。 此方法将阻塞，直到输入数据可用，检测到流的末尾或抛出异常。</span></span><br><span class="line"><span class="comment">- 结果</span></span><br><span class="line"><span class="comment">  数据的下一个字节，如果到达流的末尾， `-1` 。</span></span><br><span class="line"><span class="comment">- 异常</span></span><br><span class="line"><span class="comment">  `IOException` - 如果发生I / O错误。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><font color="blue">理解：</font></p>
<p>read()方法没有缓冲区，每次的read操作会直接通过inputstream从磁盘读取到程序当中（程序运行时，也就是读取到内存当中），而read操作每次读取一个字节，那么意味着read方法会频繁地与硬盘进行交互，而若inputstream并没有准备好这一个字节的数据的地址，read则无法进行读取数据到内存当中，因而会阻塞（等待数据的地址定位）。</p>
<img src="shangtou-04.png" class title="img">

<p>至于为什么read()读取一个字节却不是返回byte，而是将字节转为int返回，这涉及到计算机的编码问题：返回的int类型（32位bit）的-1可以表示为文件到了末尾，而如果是byte类型，如果文件的某个字节为-1，则无法判断是到了末尾还是文件本身存在-1的内容。<a href="https://www.bilibili.com/video/BV1L34y1R7Xs/?p=4&vd_source=f4c23eef1d4e259929ac8b44b97dd07b">https://www.bilibili.com/video/BV1L34y1R7Xs/?p=4&amp;vd_source=f4c23eef1d4e259929ac8b44b97dd07b</a></p>
<p>Demo:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">FileInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// 111.txt中存储  helloworld世界</span></span><br><span class="line">			inputStream = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;E:\\111.txt&quot;</span>);</span><br><span class="line">			<span class="type">int</span> readdata;<span class="comment">//每次读取一个字节，转成int类型返回</span></span><br><span class="line">			<span class="keyword">while</span> ( (readdata = inputStream.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">				System.out.println((<span class="type">char</span>)readdata);</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		</span><br><span class="line">		&#125;<span class="keyword">catch</span>(FileNotFoundException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;<span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				inputStream.close();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">				<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>返回的结果是<code>helloworldä¸ç</code>，出现乱码，这是因为windows的txt默认编码为utf-8，而英文字符占一个字节，中文字符占3个字节，因此无法打出世界这个两个中文</p>
<p>（2）read(byte[] b)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">从输入流中读取一些字节数并将它们存储到缓冲区数组b 。 实际读取的字节数以整数形式返回。 此方法将阻塞，直到输入数据可用，检测到文件结尾或引发异常。</span></span><br><span class="line"><span class="comment">如果b的长度为零，则不读取任何字节，并返回0 ; 否则，尝试读取至少一个字节。 如果由于流位于文件末尾而没有可用字节，则返回值-1 ; 否则，至少读取一个字节并存储到b 。</span></span><br><span class="line"><span class="comment">参数</span></span><br><span class="line"><span class="comment">b - 读取数据的缓冲区。</span></span><br><span class="line"><span class="comment">结果</span></span><br><span class="line"><span class="comment">读入缓冲区的总字节数，如果由于已到达流末尾而没有更多数据， -1 。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">(<span class="type">byte</span>[] b)</span> <span class="keyword">throws</span> IOException</span><br></pre></td></tr></table></figure>

<p>byte[]b缓冲区，之前read()，每一个字节的数据都需要调动一次IO操作，从硬盘再到内存当中，设立一个缓冲区，每次读取的数据存储在该缓冲区内（程序里自建当然在内存当中），再读取数据时候就可以直接从缓冲区中拿，内存之间的传输就很快了，避免了之前频繁访问硬盘的问题。</p>
<p><font color="blue">这里需要注意的是:</font> byte[] b（假设你开辟了8个字节大小 byte[] b &#x3D; new byte[8]）作为缓冲区是重复使用的，当到了文件的末尾，最后只剩下6个，那么b的前6个字节会被覆盖，而最后2个字节则仍然是上一次读取的数据，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">FileInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// 111.txt中存储helloworld世界你好</span></span><br><span class="line">			<span class="comment">// 10个英文10个字节 + 4个中文每个中文3个字节12个字节 = 22</span></span><br><span class="line">			inputStream = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;E:\\111.txt&quot;</span>);</span><br><span class="line">			<span class="type">int</span> readlength;<span class="comment">//读入到缓冲区的字节数，返回实际读取的字节数</span></span><br><span class="line">			<span class="type">byte</span>[] buf = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">8</span>];</span><br><span class="line">			<span class="keyword">while</span> ( (readlength = inputStream.read(buf)) != -<span class="number">1</span>) &#123;</span><br><span class="line">				System.out.print(readlength); <span class="comment">// 886</span></span><br><span class="line">				</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		</span><br><span class="line">		&#125;<span class="keyword">catch</span>(FileNotFoundException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;<span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				inputStream.close();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">				<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>最后一次实际的读取字节数为6，打印出来：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">inputStream = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;E:\\111.txt&quot;</span>);</span><br><span class="line"><span class="type">int</span> readlength;<span class="comment">//读入到缓冲区的字节数，返回实际读取的字节数</span></span><br><span class="line"><span class="type">byte</span>[] buf = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">8</span>];</span><br><span class="line"><span class="keyword">while</span> ( (readlength = inputStream.read(buf)) != -<span class="number">1</span>) &#123;</span><br><span class="line">	<span class="comment">//System.out.print(readlength); // 886</span></span><br><span class="line">	System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(buf,<span class="number">0</span>,readlength));</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*结果：（这里也是碰巧没有将中文三个字节分开来）</span></span><br><span class="line"><span class="comment">	 * hellowor</span></span><br><span class="line"><span class="comment">	   ld世界</span></span><br><span class="line"><span class="comment">	   你好</span></span><br><span class="line"><span class="comment">	 * */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(3) available()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 返回可以从此输入流中无阻塞地读取（或跳过）的字节数的估计值，可以是0，或者在检测到流结束时为0。</span></span><br><span class="line"><span class="comment">// InputStream类的available()方法用于返回此输入流中可以无阻塞地读取的字节数估计值。注意这是一个估计值，在某些情况下可能并不准确。</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">available</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span><br></pre></td></tr></table></figure>

<h2 id="OutputStream（字节输入流）"><a href="#OutputStream（字节输入流）" class="headerlink" title="OutputStream（字节输入流）"></a>OutputStream（字节输入流）</h2><p>和InputStream相似不多赘述</p>
<p>FileOutputStream 方法:</p>
<p>(1) <code>void write(int b)</code>： 写入一个字节，虽然参数是一个 int 类型，但只有低 8 位才会写入，高 24 位会舍弃</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// b - 要写入的字节</span></span><br><span class="line"><span class="comment">// 将指定的字节写入此文件输出流。 实现write的方法OutputStream 。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> b)</span> <span class="keyword">throws</span> IOException</span><br></pre></td></tr></table></figure>

<p>(2) <code>void write(byte b[], int off, int len)</code>： 将数组 b 中的从 off 位置开始，长度为 len 的字节写入</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将指定字节数组中的 b.length个字节写入此文件输出流。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">byte</span>[] b)</span> <span class="keyword">throws</span> IOException</span><br></pre></td></tr></table></figure>

<p>(3) <code>void flush()</code>： 强制刷新，将缓冲区的数据写入 ,<font color="red">FileOutputStream flush方法为空s</font>，原因是FileOutputStream没有使用任何的缓冲区，因此flush()为空</p>
<p>要写入字节数组，可以调用getBytes()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">outputStream.write(<span class="string">&quot;helloworld123&quot;</span>.getBytes());</span><br></pre></td></tr></table></figure>

<h2 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h2><p>Java 的缓冲流是对字节流和字符流的一种封装，通过在内存中开辟缓冲区来提高 I&#x2F;O 操作的效率。Java 通过 BufferedInputStream 和 BufferedOutputStream 来实现字节流的缓冲，通过 BufferedReader 和 BufferedWriter 来实现字符流的缓冲。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BufferedInputStream</span> <span class="keyword">extends</span> <span class="title class_">FilterInputStream</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">DEFAULT_BUFFER_SIZE</span> <span class="operator">=</span> <span class="number">8192</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The maximum size of array to allocate.</span></span><br><span class="line"><span class="comment">     * Some VMs reserve some header words in an array.</span></span><br><span class="line"><span class="comment">     * Attempts to allocate larger arrays may result in</span></span><br><span class="line"><span class="comment">     * OutOfMemoryError: Requested array size exceeds VM limit</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAX_BUFFER_SIZE</span> <span class="operator">=</span> Integer.MAX_VALUE - <span class="number">8</span>;</span><br></pre></td></tr></table></figure>

<p>直接使用默认缓冲流读取：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 记录开始时间</span></span><br><span class="line"><span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"><span class="comment">// 创建流对象</span></span><br><span class="line"><span class="keyword">try</span> (<span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;py.mp4&quot;</span>));</span><br><span class="line">        <span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;copyPy.mp4&quot;</span>));)&#123;</span><br><span class="line">    <span class="comment">// 读写数据</span></span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    <span class="keyword">while</span> ((b = bis.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">        bos.write(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 记录结束时间</span></span><br><span class="line"><span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis(); </span><br><span class="line">System.out.println(<span class="string">&quot;缓冲流使用数组复制时间:&quot;</span>+(end - start)+<span class="string">&quot; 毫秒&quot;</span>); <span class="comment">// 8016ms</span></span><br></pre></td></tr></table></figure>

<p>可以换数组的方式来读写，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 记录开始时间</span></span><br><span class="line"><span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"><span class="comment">// 创建流对象</span></span><br><span class="line"><span class="keyword">try</span> (<span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;py.mp4&quot;</span>));</span><br><span class="line">        <span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;copyPy.mp4&quot;</span>));)&#123;</span><br><span class="line">    <span class="comment">// 读写数据</span></span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">8</span>*<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">while</span> ((len = bis.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">        bos.write(bytes, <span class="number">0</span> , len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 记录结束时间</span></span><br><span class="line"><span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">System.out.println(<span class="string">&quot;缓冲流使用数组复制时间:&quot;</span>+(end - start)+<span class="string">&quot; 毫秒&quot;</span>); <span class="comment">// 521ms</span></span><br></pre></td></tr></table></figure>

<h3 id="缓冲流是内置了一个数组，增加了效率，不是内置了数组吗，为何还需要传递一个数组增加效率呢？"><a href="#缓冲流是内置了一个数组，增加了效率，不是内置了数组吗，为何还需要传递一个数组增加效率呢？" class="headerlink" title="缓冲流是内置了一个数组，增加了效率，不是内置了数组吗，为何还需要传递一个数组增加效率呢？"></a><font color="red"><strong>缓冲流是内置了一个数组，增加了效率，不是内置了数组吗，为何还需要传递一个数组增加效率呢？</strong></font></h3><p>首先声明一下缓冲流的基本原理：是在创建流对象时，会创建一个内置的默认大小的缓冲区数组，<font color="red">通过缓冲区读写，减少系统IO次数，</font>从而提高读写的效率。通过看源码，知道了这个默认的缓冲区数组大小是8192。</p>
<p>标红的部分，减少的是 系统IO次数 ，但是 缓冲区读写  这个部分，缓冲流做了优化吗，答案是没有</p>
<p>我们回到源码，字节缓冲输入流的add()无参方法如下，看返回值我们知道它返回的是int，诶，为什么不是返回数组呢，不是内置了数组吗？</p>
<img src="2135194-20201115031408498-651802370.png" class title="img">

<p>画一个示意图来说明吧，为什么说返回的是数组呢，因为返回给缓冲流的的确是数组，但是我们还有一个返回值就是我们每次读取的一个字节，源码的数据返回类型是int也证明了这一点，我们可以输出上面我提供的代码里面的b</p>
<p>就会知道的确每一次从被读取的文件中读数据是一个个字节读的，这样效率就很低下</p>
<img src="2135194-20201115032051472-76660950.png" class title="img">

<p>因此就有了我提供的代码里面的那种写法，缓冲区数组不再一个个读取，而是一次读取一个字符数组，这样在缓冲区读写这个部分进行了再次优化，实际过程如下（部分）</p>
<img src="2135194-20201115033226792-699674964.png" class title="img">

<p>缓冲流内置的缓冲区数组增加的效率的原因是在文件所在位置，也就是磁盘位置，到缓冲流这个部分的IO次数进行了优化，但是没有对读取磁盘文件这个步骤做优化，仍是单字节读取</p>
<p>我们可以使用数组读取的方式从磁盘读，进一步提升速度。</p>
<h3 id="为什么字节缓冲流会加快"><a href="#为什么字节缓冲流会加快" class="headerlink" title="为什么字节缓冲流会加快"></a>为什么字节缓冲流会加快</h3><p>字节缓冲流解决的就是这个问题：<strong>一次多读点多写点，减少读写的频率，用空间换时间</strong>。</p>
<ul>
<li>减少系统调用次数：在使用字节缓冲流时，数据不是立即写入磁盘或输出流，而是先写入缓冲区，当缓冲区满时再一次性写入磁盘或输出流。这样可以减少系统调用的次数，从而提高 I&#x2F;O 操作的效率。</li>
<li>减少磁盘读写次数：在使用字节缓冲流时，当需要读取数据时，缓冲流会先从缓冲区中读取数据，如果缓冲区中没有足够的数据，则会一次性从磁盘或输入流中读取一定量的数据。同样地，当需要写入数据时，缓冲流会先将数据写入缓冲区，如果缓冲区满了，则会一次性将缓冲区中的数据写入磁盘或输出流。这样可以减少磁盘读写的次数，从而提高 I&#x2F;O 操作的效率。</li>
<li>提高数据传输效率：在使用字节缓冲流时，由于数据是以块的形式进行传输，因此可以减少数据传输的次数，从而提高数据传输的效率。</li>
</ul>
<p>我们来看 BufferedInputStream 的 read 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">if</span> (pos &gt;= count) &#123;     <span class="comment">// 如果当前位置已经到达缓冲区末尾</span></span><br><span class="line">        fill();             <span class="comment">// 填充缓冲区</span></span><br><span class="line">        <span class="keyword">if</span> (pos &gt;= count)   <span class="comment">// 如果填充后仍然到达缓冲区末尾，说明已经读取完毕</span></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;      <span class="comment">// 返回 -1 表示已经读取完毕</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> getBufIfOpen()[pos++] &amp; <span class="number">0xff</span>; <span class="comment">// 返回当前位置的字节，并将位置加 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再来看 FileInputStream 的 read 方法：</p>
<img src="buffer-20230321154534.png" class title="img">

<p>在这段代码中，<code>read0()</code> 方法是一个<a href="https://javabetter.cn/oo/native-method.html">本地方法</a>，它的实现是由底层操作系统提供的，并不是 Java 语言实现的。在不同的操作系统上，<code>read0()</code> 方法的实现可能会有所不同，但是它们的功能都是相同的，都是用于<strong>读取一个字节</strong>。</p>
<p>再来看一下 BufferedOutputStream 的 <code>write(byte b[], int off, int len)</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">byte</span> b[], <span class="type">int</span> off, <span class="type">int</span> len)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">if</span> (len &gt;= buf.length) &#123;    <span class="comment">// 如果写入的字节数大于等于缓冲区长度</span></span><br><span class="line">        <span class="comment">/* 如果请求的长度超过了输出缓冲区的大小，</span></span><br><span class="line"><span class="comment">           先刷新缓冲区，然后直接将数据写入。</span></span><br><span class="line"><span class="comment">           这样可以避免缓冲流级联时的问题。*/</span></span><br><span class="line">        flushBuffer();          <span class="comment">// 先刷新缓冲区</span></span><br><span class="line">        out.write(b, off, len); <span class="comment">// 直接将数据写入输出流</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (len &gt; buf.length - count) &#123; <span class="comment">// 如果写入的字节数大于空余空间</span></span><br><span class="line">        flushBuffer();              <span class="comment">// 先刷新缓冲区</span></span><br><span class="line">    &#125;</span><br><span class="line">    System.arraycopy(b, off, buf, count, len); <span class="comment">// 将数据拷贝到缓冲区中</span></span><br><span class="line">    count += len;                             <span class="comment">// 更新计数器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先，该方法会检查写入的字节数是否大于等于缓冲区长度，如果是，则先将缓冲区中的数据刷新到磁盘中，然后直接将数据写入输出流。这样做是为了避免缓冲流级联时的问题，即缓冲区的大小不足以容纳写入的数据时，可能会引发级联刷新，导致效率降低。</p>
<blockquote>
<p>级联问题（Cascade Problem）是指在一组缓冲流（Buffered Stream）中，由于缓冲区的大小不足以容纳要写入的数据，导致数据被分割成多个部分，并分别写入到不同的缓冲区中，最终需要逐个刷新缓冲区，从而导致性能下降的问题。</p>
</blockquote>
<p>其次，如果写入的字节数小于缓冲区长度，则检查缓冲区中剩余的空间是否足够容纳要写入的字节数，如果不够，则先将缓冲区中的数据刷新到磁盘中。然后，使用 <code>System.arraycopy()</code> 方法将要写入的数据拷贝到缓冲区中，并更新计数器 count。</p>
<p>最后，如果写入的字节数小于缓冲区长度且缓冲区中还有剩余空间，则直接将要写入的数据拷贝到缓冲区中，并更新计数器 count。</p>
<p>也就是说，只有当 buf 写满了，才会 flush，将数据刷到磁盘，默认一次刷 8192 个字节。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">BufferedOutputStream</span><span class="params">(OutputStream out)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(out, <span class="number">8192</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果 buf 没有写满，会继续写 buf。</p>
<p>对比一下 FileOutputStream 的 write 方法，同样是本地方法，一次只能写入一个字节。</p>
<img src="buffer-20230321162808.png" class title="img">

<p>当把 BufferedOutputStream 和 BufferedInputStream 配合起来使用后，就减少了大量的读写次数，尤其是 <code>byte[] bytes = new byte[8*1024]</code>，就相当于缓冲区的空间有 8 个 1024 字节，那读写效率就会大大提高。</p>
<h2 id="字符流Reader-Writer"><a href="#字符流Reader-Writer" class="headerlink" title="字符流Reader&#x2F;Writer"></a>字符流Reader&#x2F;Writer</h2><p>字节流是将内容转为了字节形式进行传输，1字节&#x3D;8二进制，二进制可以传输任何类型的数据，因此字节流可以传输任何类型的数据</p>
<p>字符流处理的是16位的unicode字符</p>
<p>字符输入流Reader方法：</p>
<p>(1) <code>read()</code>：从输入流读取一个字符。</p>
<p>(2) <code>read(char[] cbuf)</code>：从输入流中读取一些字符，并将它们存储到字符数组 <code>cbuf</code>中</p>
<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1>



<h2 id="Java-HashMap"><a href="#Java-HashMap" class="headerlink" title="Java HashMap"></a>Java HashMap</h2><h4 id="Java-HashMap-put-方法"><a href="#Java-HashMap-put-方法" class="headerlink" title="Java HashMap put() 方法"></a><font color="blue">Java HashMap put() 方法</font></h4><p>put()方法将指定的键值对插入到HashMap中。若插入的key对应的value已经存在，则执行value替换操作，返回旧的value值，如果不存在则执行插入，返回null</p>
<p>语法为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">hashmap.put（K key，V value）</span><br></pre></td></tr></table></figure>

<p>Demo：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HashMap&lt;Character, Integer&gt; dic = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">System.out.println( dic.put(<span class="string">&#x27;a&#x27;</span>, <span class="number">0</span>) ); <span class="comment">// null</span></span><br><span class="line">System.out.println( dic.put(<span class="string">&#x27;a&#x27;</span>, <span class="number">1</span>) ); <span class="comment">// 1</span></span><br><span class="line">System.out.println(dic); <span class="comment">// &#123;a=1&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="Java-HashMap-getOrDefault-方法"><a href="#Java-HashMap-getOrDefault-方法" class="headerlink" title="Java HashMap getOrDefault() 方法"></a><font color="blue">Java HashMap getOrDefault() 方法</font></h4><p>getOrDefault()方法获取指定key对应value，如果找不到key，则返回设置的默认值。</p>
<p>语法为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">hashmap.getOrDefault(Object key, V defaultValue)</span><br></pre></td></tr></table></figure>

<p>Demo：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HashMap&lt;Character, Integer&gt; dic = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">		<span class="comment">// 字符串的字符频率统计</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;abcdefabc&quot;</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;str.length();i++) &#123;</span><br><span class="line">			dic.put(str.charAt(i), dic.getOrDefault(str.charAt(i), <span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		System.out.println(dic); <span class="comment">//  &#123;a=2, b=2, c=2, d=1, e=1, f=1&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="Java-HashMap-containsValue-方法"><a href="#Java-HashMap-containsValue-方法" class="headerlink" title="Java HashMap containsValue() 方法"></a><font color="blue">Java HashMap containsValue() 方法</font></h4><p>containsValue() 方法检查 hashMap 中是否存在指定的 value 对应的映射关系。</p>
<p>语法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containsValue</span><span class="params">(Object value)</span></span><br></pre></td></tr></table></figure>

<p>Demo：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个 HashMap</span></span><br><span class="line">      HashMap&lt;Integer, String&gt; sites = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 往 HashMap 添加一些元素</span></span><br><span class="line">      sites.put(<span class="number">1</span>, <span class="string">&quot;Google&quot;</span>);</span><br><span class="line">      sites.put(<span class="number">2</span>, <span class="string">&quot;Runoob&quot;</span>);</span><br><span class="line">      sites.put(<span class="number">3</span>, <span class="string">&quot;Taobao&quot;</span>);</span><br><span class="line">      System.out.println(<span class="string">&quot;sites HashMap: &quot;</span> + sites);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//检查映射中值value是否有Java</span></span><br><span class="line">      <span class="keyword">if</span>(sites.containsValue(<span class="string">&quot;Runoob&quot;</span>)) &#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;Runoob 存在于 sites 中&quot;</span>);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<h4 id="Java-HashMap-containsKey-方法"><a href="#Java-HashMap-containsKey-方法" class="headerlink" title="Java HashMap containsKey() 方法"></a><font color="blue">Java HashMap containsKey() 方法</font></h4><p>containsKey() 方法检查 hashMap 中是否存在指定的 key 对应的映射关系。</p>
<p>语法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containsKey</span><span class="params">(Object key)</span></span><br></pre></td></tr></table></figure>

<p>Demo：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个 HashMap</span></span><br><span class="line">      HashMap&lt;Integer, String&gt; sites = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 往 HashMap 添加一些元素</span></span><br><span class="line">      sites.put(<span class="number">1</span>, <span class="string">&quot;Google&quot;</span>);</span><br><span class="line">      sites.put(<span class="number">2</span>, <span class="string">&quot;Runoob&quot;</span>);</span><br><span class="line">      sites.put(<span class="number">3</span>, <span class="string">&quot;Taobao&quot;</span>);</span><br><span class="line">      System.out.println(<span class="string">&quot;sites HashMap: &quot;</span> + sites);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//检查 key 为 1 是否存在</span></span><br><span class="line">      <span class="keyword">if</span>(sites.containsKey(<span class="number">1</span>)) &#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;key 为 1 存在于 sites 中&quot;</span>);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>



<h4 id="Java-HashMap-values-方法"><a href="#Java-HashMap-values-方法" class="headerlink" title="Java HashMap values() 方法 "></a><font color="blue">Java HashMap values() 方法 </font></h4><p>values() 方法返回映射中所有 value 组成的 Set 视图。</p>
<p>语法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Collection&lt;V&gt; <span class="title function_">values</span><span class="params">()</span></span><br></pre></td></tr></table></figure>

<p>Demo：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HashMap&lt;Character, Integer&gt; dic = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// 字符串的字符频率统计</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;abcdefabc&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;str.length();i++) &#123;</span><br><span class="line">	dic.put(str.charAt(i), dic.getOrDefault(str.charAt(i), <span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Collection&lt;Integer&gt; values = dic.values();</span><br><span class="line">System.out.println(values);</span><br><span class="line"><span class="keyword">for</span> (Integer value:values) &#123;</span><br><span class="line">	System.out.print(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Java-HashSet"><a href="#Java-HashSet" class="headerlink" title="Java HashSet"></a><font color="red"><strong>Java HashSet</strong></font></h2><p>HashSet 基于 HashMap 来实现的，是一个不允许有重复元素的集合。<br>HashSet 允许有 null 值。<br>HashSet 是无序的，即不会记录插入的顺序。<br>HashSet 不是线程安全的， 如果多个线程尝试同时修改 HashSet，则最终结果是不确定的。 您必须在多线程访问时显式同步对 HashSet 的并发访问。<br>HashSet 实现了 Set 接口。</p>
<h4 id="Java-HashSet-add-方法"><a href="#Java-HashSet-add-方法" class="headerlink" title="Java HashSet add() 方法"></a><font color="blue">Java HashSet add() 方法</font></h4><p>添加元素：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HashSet&lt;Integer&gt; set1 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Integer&gt;();</span><br><span class="line">	</span><br><span class="line">set1.add(<span class="number">1</span>);</span><br><span class="line">set1.add(<span class="number">1</span>);</span><br><span class="line">System.out.println(set1); <span class="comment">// [1]</span></span><br></pre></td></tr></table></figure>

<h4 id="Java-HashSet-contains-方法"><a href="#Java-HashSet-contains-方法" class="headerlink" title="Java HashSet contains() 方法"></a><font color="blue">Java HashSet contains() 方法</font></h4><p>如果此set包含指定的元素，则返回<code>true</code> 。 更正式地说，返回<code>true</code>当且仅当此set包含的元素<code>e</code> ，使得<code>Objects.equals(o, e)</code> 。</p>
<p>语法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span></span><br></pre></td></tr></table></figure>

<p>Demo：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HashSet&lt;String&gt; sites = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;String&gt;();</span><br><span class="line">    sites.add(<span class="string">&quot;Google&quot;</span>);</span><br><span class="line">    sites.add(<span class="string">&quot;Runoob&quot;</span>);</span><br><span class="line">    sites.add(<span class="string">&quot;Taobao&quot;</span>);</span><br><span class="line">    sites.add(<span class="string">&quot;Zhihu&quot;</span>);</span><br><span class="line">    sites.add(<span class="string">&quot;Runoob&quot;</span>);  <span class="comment">// 重复的元素不会被添加</span></span><br><span class="line">    System.out.println(sites.contains(<span class="string">&quot;Taobao&quot;</span>)); <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Java-HashSet-size-方法"><a href="#Java-HashSet-size-方法" class="headerlink" title="Java HashSet size() 方法"></a><font color="blue">Java HashSet size() 方法</font></h4><p>返回此集合中的元素数（基数）。<br>语法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span></span><br></pre></td></tr></table></figure>



<h2 id="Java-String"><a href="#Java-String" class="headerlink" title="Java String"></a><font color="red"><u>Java String</u></font></h2><p><strong>length——数组的属性；</strong></p>
<p><strong>length()——String的方法；</strong></p>
<p><strong>size()——集合的方法；</strong></p>
<h4 id="Java-charAt-方法"><a href="#Java-charAt-方法" class="headerlink" title="Java charAt() 方法"></a><font color="blue">Java charAt() 方法</font></h4><p>charAt()方法用于返回指定索引处的字符。索引范围为从 0 到 length() - 1。</p>
<p>语法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">char</span> <span class="title function_">charAt</span><span class="params">(<span class="type">int</span> index)</span></span><br></pre></td></tr></table></figure>

<p>Demo:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;www.baidu.com&quot;</span>;</span><br><span class="line"><span class="type">char</span> <span class="variable">result</span> <span class="operator">=</span> s.charAt(<span class="number">6</span>);</span><br><span class="line">   System.out.println(result);<span class="comment">// i </span></span><br></pre></td></tr></table></figure>

<h4 id="Java-String-遍历方法"><a href="#Java-String-遍历方法" class="headerlink" title="Java String 遍历方法"></a><font color="blue">Java String 遍历方法</font></h4><p>使用toCharArray()，增强for：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;1243523&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">char</span> c:str.toCharArray()) &#123;</span><br><span class="line">	System.out.println(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用charAt()，普通for循环：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;1243523&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;str.length() ; i++) &#123;</span><br><span class="line">	System.out.println(str.charAt(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Java-ArrayList"><a href="#Java-ArrayList" class="headerlink" title="Java ArrayList"></a><font color="red"><strong><u>Java ArrayList</u></strong></font></h3><p>ArrayList 和 Vector 都实现了List接口，List接口继承了Collection接口，都是有序集合</p>
<p>区别在于Vector使用了<strong>Synchronized</strong> 来实现<a href="https://so.csdn.net/so/search?q=%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5&spm=1001.2101.3001.7020">线程同步</a>，是线程安全的，而 ArrayList 是非线程安全的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList; <span class="comment">// 引入 ArrayList 类</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// E:泛型数据类型，用于设置objectName的数据类型，只能为引用类型</span></span><br><span class="line">ArrayList&lt;E&gt; objectName =<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();　 <span class="comment">// 初始化</span></span><br><span class="line"><span class="comment">// 错误ArrayList&lt;char&gt; ==&gt; 正确ArrayList&lt;Character&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="ArrayList-添加元素add"><a href="#ArrayList-添加元素add" class="headerlink" title="ArrayList 添加元素add"></a><font color="blue">ArrayList 添加元素add</font></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt; sites = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        sites.add(<span class="string">&quot;Google&quot;</span>);</span><br><span class="line">        sites.add(<span class="string">&quot;Runoob&quot;</span>);</span><br><span class="line">        sites.add(<span class="string">&quot;Taobao&quot;</span>);</span><br><span class="line">        sites.add(<span class="string">&quot;Weibo&quot;</span>);</span><br><span class="line">        System.out.println(sites);</span><br></pre></td></tr></table></figure>

<h4 id="ArrayList-访问元素get"><a href="#ArrayList-访问元素get" class="headerlink" title="ArrayList 访问元素get()"></a><font color="blue">ArrayList 访问元素get()</font></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt; sites = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        sites.add(<span class="string">&quot;Google&quot;</span>);</span><br><span class="line">        sites.add(<span class="string">&quot;Runoob&quot;</span>);</span><br><span class="line">        sites.add(<span class="string">&quot;Taobao&quot;</span>);</span><br><span class="line">        sites.add(<span class="string">&quot;Weibo&quot;</span>);</span><br><span class="line">        System.out.println(sites.get(<span class="number">1</span>));  <span class="comment">// 访问第二个元素</span></span><br></pre></td></tr></table></figure>

<h4 id="ArrayList-修改元素set-int-index-E-element"><a href="#ArrayList-修改元素set-int-index-E-element" class="headerlink" title="ArrayList 修改元素set(int index, E element)"></a><font color="blue">ArrayList 修改元素set(int index, E element)</font></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt; sites = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        sites.add(<span class="string">&quot;Google&quot;</span>);</span><br><span class="line">        sites.add(<span class="string">&quot;Runoob&quot;</span>);</span><br><span class="line">        sites.add(<span class="string">&quot;Taobao&quot;</span>);</span><br><span class="line">        sites.add(<span class="string">&quot;Weibo&quot;</span>);</span><br><span class="line">        sites.set(<span class="number">2</span>, <span class="string">&quot;Wiki&quot;</span>); <span class="comment">// 第一个参数为索引位置，第二个为要修改的值</span></span><br><span class="line">        System.out.println(sites);</span><br></pre></td></tr></table></figure>

<h4 id="ArrayList-删除元素remove"><a href="#ArrayList-删除元素remove" class="headerlink" title="ArrayList 删除元素remove()"></a><font color="blue">ArrayList 删除元素remove()</font></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt; sites = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        sites.add(<span class="string">&quot;Google&quot;</span>);</span><br><span class="line">        sites.add(<span class="string">&quot;Runoob&quot;</span>);</span><br><span class="line">        sites.add(<span class="string">&quot;Taobao&quot;</span>);</span><br><span class="line">        sites.add(<span class="string">&quot;Weibo&quot;</span>);</span><br><span class="line">        sites.remove(<span class="number">3</span>); <span class="comment">// 删除第四个元素</span></span><br><span class="line">        System.out.println(sites);</span><br></pre></td></tr></table></figure>

<h4 id="ArrayList-计算大小size-Collection都是size"><a href="#ArrayList-计算大小size-Collection都是size" class="headerlink" title="ArrayList 计算大小size() Collection都是size()"></a><font color="blue">ArrayList 计算大小size()</font> Collection都是size()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt; sites = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">System.out.println(sites.size());</span><br></pre></td></tr></table></figure>

<h2 id="Java-Arrays：专为数组而生的工具类"><a href="#Java-Arrays：专为数组而生的工具类" class="headerlink" title="Java Arrays：专为数组而生的工具类"></a><u>Java Arrays：专为数组而生的工具类</u></h2><h4 id="Arrays-创建数组"><a href="#Arrays-创建数组" class="headerlink" title="Arrays 创建数组"></a><font color="blue">Arrays 创建数组</font></h4><ol>
<li>copyOf：复制指定的数组，截取或用 null 填充</li>
</ol>
   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] intro = <span class="keyword">new</span> <span class="title class_">String</span>[] &#123; <span class="string">&quot;沉&quot;</span>, <span class="string">&quot;默&quot;</span>, <span class="string">&quot;王&quot;</span>, <span class="string">&quot;二&quot;</span> &#125;;</span><br><span class="line">String[] revised = Arrays.copyOf(intro, <span class="number">3</span>);</span><br><span class="line">String[] expanded = Arrays.copyOf(intro, <span class="number">5</span>);</span><br><span class="line">System.out.println(Arrays.toString(revised));</span><br><span class="line">System.out.println(Arrays.toString(expanded));</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>copyOfRange，复制指定范围内的数组到一个新的数组：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] intro = <span class="keyword">new</span> <span class="title class_">String</span>[] &#123; <span class="string">&quot;沉&quot;</span>, <span class="string">&quot;默&quot;</span>, <span class="string">&quot;王&quot;</span>, <span class="string">&quot;二&quot;</span> &#125;;</span><br><span class="line">String[] abridgement = Arrays.copyOfRange(intro, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">System.out.println(Arrays.toString(abridgement));</span><br></pre></td></tr></table></figure>
</li>
<li><p>fill，对数组进行填充：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] stutter = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">4</span>];</span><br><span class="line">Arrays.fill(stutter, <span class="string">&quot;沉默王二&quot;</span>);</span><br><span class="line">System.out.println(Arrays.toString(stutter)); </span><br><span class="line"><span class="comment">// [沉默王二, 沉默王二, 沉默王二, 沉默王二] 如果想要一个元素完全相同的数组时 fill() 方法就派上用场了</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="Arrays-比较数组"><a href="#Arrays-比较数组" class="headerlink" title="Arrays 比较数组"></a><font color="blue">Arrays 比较数组</font></h4><p>Arrays 类的 <code>equals()</code> 方法用来判断两个数组是否相等：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] intro = <span class="keyword">new</span> <span class="title class_">String</span>[] &#123; <span class="string">&quot;沉&quot;</span>, <span class="string">&quot;默&quot;</span>, <span class="string">&quot;王&quot;</span>, <span class="string">&quot;二&quot;</span> &#125;;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> Arrays.equals(<span class="keyword">new</span> <span class="title class_">String</span>[] &#123; <span class="string">&quot;沉&quot;</span>, <span class="string">&quot;默&quot;</span>, <span class="string">&quot;王&quot;</span>, <span class="string">&quot;二&quot;</span> &#125;, intro);</span><br><span class="line">System.out.println(result);</span><br><span class="line"><span class="type">boolean</span> <span class="variable">result1</span> <span class="operator">=</span> Arrays.equals(<span class="keyword">new</span> <span class="title class_">String</span>[] &#123; <span class="string">&quot;沉&quot;</span>, <span class="string">&quot;默&quot;</span>, <span class="string">&quot;王&quot;</span>, <span class="string">&quot;三&quot;</span> &#125;, intro);</span><br><span class="line">System.out.println(result1);</span><br></pre></td></tr></table></figure>

<h4 id="Arrays-数组排序"><a href="#Arrays-数组排序" class="headerlink" title="Arrays 数组排序"></a><font color="blue">Arrays 数组排序</font></h4><p>Arrays 类的 <code>sort()</code> 方法用来对数组进行排序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] intro1 = <span class="keyword">new</span> <span class="title class_">String</span>[] &#123; <span class="string">&quot;chen&quot;</span>, <span class="string">&quot;mo&quot;</span>, <span class="string">&quot;wang&quot;</span>, <span class="string">&quot;er&quot;</span> &#125;;</span><br><span class="line">String[] sorted = Arrays.copyOf(intro1, <span class="number">4</span>);</span><br><span class="line">Arrays.sort(sorted);</span><br><span class="line">System.out.println(Arrays.toString(sorted));</span><br></pre></td></tr></table></figure>

<h4 id="Arrays-数组检索"><a href="#Arrays-数组检索" class="headerlink" title="Arrays 数组检索"></a><font color="blue">Arrays 数组检索</font></h4><p>数组排序后就可以使用 Arrays 类的 <code>binarySearch()</code> 方法进行二分查找了。否则的话，只能线性检索，效率就会低很多。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] intro1 = <span class="keyword">new</span> <span class="title class_">String</span>[] &#123; <span class="string">&quot;chen&quot;</span>, <span class="string">&quot;mo&quot;</span>, <span class="string">&quot;wang&quot;</span>, <span class="string">&quot;er&quot;</span> &#125;;</span><br><span class="line">String[] sorted = Arrays.copyOf(intro1, <span class="number">4</span>);</span><br><span class="line">Arrays.sort(sorted);</span><br><span class="line"><span class="type">int</span> <span class="variable">exact</span> <span class="operator">=</span> Arrays.binarySearch(sorted, <span class="string">&quot;wang&quot;</span>);</span><br><span class="line">System.out.println(exact);</span><br><span class="line"><span class="type">int</span> <span class="variable">caseInsensitive</span> <span class="operator">=</span> Arrays.binarySearch(sorted, <span class="string">&quot;Wang&quot;</span>, String::compareToIgnoreCase);</span><br><span class="line">System.out.println(caseInsensitive);</span><br></pre></td></tr></table></figure>

<h4 id="Arrays-数组打印"><a href="#Arrays-数组打印" class="headerlink" title="Arrays 数组打印"></a><font color="blue">Arrays 数组打印</font></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Arrays.toString()</span><br></pre></td></tr></table></figure>

<h4 id="Arrays-数组转-List"><a href="#Arrays-数组转-List" class="headerlink" title="Arrays 数组转 List"></a><font color="blue">Arrays 数组转 List</font></h4><p>尽管数组非常强大，但它自身可以操作的工具方法很少，比如说判断数组中是否包含某个值。如果能转成 List 的话，就简便多了，因为 Java 的<a href="https://javabetter.cn/collection/gailan.html">集合框架 List</a> 中封装了很多常用的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] intro = <span class="keyword">new</span> <span class="title class_">String</span>[] &#123; <span class="string">&quot;沉&quot;</span>, <span class="string">&quot;默&quot;</span>, <span class="string">&quot;王&quot;</span>, <span class="string">&quot;二&quot;</span> &#125;;</span><br><span class="line">List&lt;String&gt; rets = Arrays.asList(intro);</span><br><span class="line">System.out.println(rets.contains(<span class="string">&quot;二&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>不过需要注意的是，<code>Arrays.asList()</code> 返回的是 <code>java.util.Arrays.ArrayList</code>，并不是<code> java.util.ArrayList</code>，它的长度是固定的，无法进行元素的删除或者添加。</p>
<p>要想操作元素的话，需要多一步转化，转成真正的 <code>java.util.ArrayList</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; rets1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(intro));</span><br><span class="line">rets1.add(<span class="string">&quot;三&quot;</span>);</span><br><span class="line">rets1.remove(<span class="string">&quot;二&quot;</span>);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis</title>
    <url>/MyBatis/</url>
    <content><![CDATA[<h1 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h1><p>MyBatis是一款优秀的持久型（JavaEE三层架构：表现层、业务层和持久层&#x2F;数据访问层）框架，它支持自定义SQL、存储过程以及高级映射。MyBatis免除了几乎所有的JDBC代码以及设置参数和获取结果集的工作。MyBatis可以通过简单的XML或注解来配置和映射原始类型、接口和Java POJO（Plain Old Java Objects，普通老式Java对象）为数据库中的记录。</p>
<img src="image-20241111201140000.png" class title="image-20241111201140000">

<h2 id="MyBatis快速入门"><a href="#MyBatis快速入门" class="headerlink" title="MyBatis快速入门"></a>MyBatis快速入门</h2><h3 id="创建user表，添加数据"><a href="#创建user表，添加数据" class="headerlink" title="创建user表，添加数据"></a>创建user表，添加数据</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> database mybatisDb; </span><br><span class="line">use mybatisDb;</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> if <span class="keyword">exists</span> tb_user;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tb_user( </span><br><span class="line">	id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment, </span><br><span class="line">	username <span class="type">varchar</span>(<span class="number">20</span>), </span><br><span class="line">	password <span class="type">varchar</span>(<span class="number">20</span>), </span><br><span class="line">	gender <span class="type">char</span>(<span class="number">1</span>), </span><br><span class="line">	addr <span class="type">varchar</span>(<span class="number">30</span>) </span><br><span class="line">); </span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tb_user <span class="keyword">VALUES</span> (<span class="number">1</span>,<span class="string">&#x27;zhangsan&#x27;</span>,<span class="string">&#x27;123&#x27;</span>,<span class="string">&#x27;男&#x27;</span>,<span class="string">&#x27;北京&#x27;</span>); </span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tb_user <span class="keyword">VALUES</span> (<span class="number">2</span>,<span class="string">&#x27;李四&#x27;</span>,<span class="string">&#x27;234&#x27;</span>,<span class="string">&#x27;女&#x27;</span>,<span class="string">&#x27;天津&#x27;</span>); </span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tb_user <span class="keyword">VALUES</span> (<span class="number">3</span>,<span class="string">&#x27;王五&#x27;</span>,<span class="string">&#x27;11&#x27;</span>,<span class="string">&#x27;男&#x27;</span>,<span class="string">&#x27;西安&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="创建模块，导入坐标"><a href="#创建模块，导入坐标" class="headerlink" title="创建模块，导入坐标"></a>创建模块，导入坐标</h3><p>通过maven创建java项目，pom.xml导入依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.28<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="编写MyBatis核心配置文件，–-替换连接信息，解决硬编码问题"><a href="#编写MyBatis核心配置文件，–-替换连接信息，解决硬编码问题" class="headerlink" title="编写MyBatis核心配置文件，–&gt; 替换连接信息，解决硬编码问题"></a>编写MyBatis核心配置文件，–&gt; 替换连接信息，解决硬编码问题</h3><img src="image-20241111210957641.png" class title="image-20241111210957641">

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 数据库连接信息--&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">                MySQL 8.0 以上 com.mysql.jdbc.Driver 更换为 com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="comment">                --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">                    mybatisDb是数据库名称</span></span><br><span class="line"><span class="comment">                    jdbc:mysql:// 是连接协议</span></span><br><span class="line"><span class="comment">                    在 xml 中 &amp; 符合要转义成 &amp;amp; 符号</span></span><br><span class="line"><span class="comment">                    MySQL 8.0 以上版本不需要建立 SSL 连接的，需要显示关闭。</span></span><br><span class="line"><span class="comment">                    allowPublicKeyRetrieval=true 允许客户端从服务器获取公钥。</span></span><br><span class="line"><span class="comment">                    最后还需要设置 CST(也就是设置时区)。</span></span><br><span class="line"><span class="comment">                --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/mybatisDB?useSSL=false<span class="symbol">&amp;amp;</span>allowPublicKeyRetrieval=true<span class="symbol">&amp;amp;</span>serverTimezone=UTC&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;xxxx&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        加载映射文件。</span></span><br><span class="line"><span class="comment">        映射文件即SQL映射文件，该文件中配置了操作数据库的SQL语句，需要在MyBatis配置文件mybatis-config.xml中加载。</span></span><br><span class="line"><span class="comment">        mybatis-config.xml 文件可以加载多个映射文件，每个文件对应数据库中的一张表。</span></span><br><span class="line"><span class="comment">				一般会有个规范写法，操作User表就是 UserMapper.xml</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;mapper/UserMapper.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="创建-Mapper-XML-文件"><a href="#创建-Mapper-XML-文件" class="headerlink" title="创建 Mapper XML 文件"></a>创建 Mapper XML 文件</h4><p>sql语句将通过namespace.sqlId获得sql语句。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- UserMapper.xml --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- namespace 名称空间 通过namespace.sqlId获得sql语句 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- com.sza.mapper.UserMapper.selectAll--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.sza.mapper.UserMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--  resultType指向封装的java类  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectAll&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.sza.pojo.User&quot;</span>&gt;</span></span><br><span class="line">        SELECT * FROM tb_user;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>Mapper XML文件，通常存放在项目的classpath下的一个目录中，例如<code>resources/mapper/UserMapper.xml</code>。在上述示例中，我们定义了一个名为<code>selectAll</code>的查询操作，并将结果映射到<code>com.sza.pojo.User</code>类型（封装数据表的数据）的对象中。</p>
<h4 id="配置-MyBatis"><a href="#配置-MyBatis" class="headerlink" title="配置 MyBatis"></a>配置 MyBatis</h4><p>要使用Mapper XML文件，需要在MyBatis的配置文件中引入它们。MyBatis的配置文件通常是mybatis-config.xml，您需要在其中配置Mapper XML文件的路径。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- mybatis-config.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;mapper/UserMapper.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在上述配置中，我们使用<code>&lt;mappers&gt;</code>元素引入了Mapper XML文件，使用<code>&lt;mapper&gt;</code>元素的<code>resource</code>属性指定了XML文件的路径。</p>
<h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><h3 id="定义POJO类"><a href="#定义POJO类" class="headerlink" title="定义POJO类"></a>定义POJO类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sza.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> String gender;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUsername</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUsername</span><span class="params">(String username)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPassword</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPassword</span><span class="params">(String password)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getGender</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> gender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setGender</span><span class="params">(String gender)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.gender = gender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getAddress</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAddress</span><span class="params">(String address)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, username=&#x27;&quot;</span> + username + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, password=&#x27;&quot;</span> + password + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, gender=&#x27;&quot;</span> + gender + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, address=&#x27;&quot;</span> + address + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="加载核心配置文件，获取sqlSessionFactory对象，执行sql语句"><a href="#加载核心配置文件，获取sqlSessionFactory对象，执行sql语句" class="headerlink" title="加载核心配置文件，获取sqlSessionFactory对象，执行sql语句"></a>加载核心配置文件，获取sqlSessionFactory对象，执行sql语句</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sza;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sza.pojo.User;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.io.Resources;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSession;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactoryBuilder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.加载mybatis的核心配置文件，获取sqlSessionFactory</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="string">&quot;mybatis-config.xml&quot;</span>;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getResourceAsStream(resource);</span><br><span class="line">        <span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(inputStream);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.获取sqlSession对象，用它来执行sql</span></span><br><span class="line">        <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.执行sql</span></span><br><span class="line">      	<span class="comment">// </span></span><br><span class="line">        List&lt;User&gt; users = sqlSession.selectList(<span class="string">&quot;com.sza.mapper.UserMapper.selectAll&quot;</span>);</span><br><span class="line">        System.out.println(users);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.释放资源</span></span><br><span class="line">        sqlSession.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>sqlSession：</p>
<p>sqlSession 是 MyBatis 提供的一个会话对象，负责与数据库交互。通过它可以执行 SQL 查询、插入、更新和删除操作。</p>
<p>selectList <strong>方法</strong>：</p>
<p>这是 MyBatis 的核心方法之一，用于执行 SELECT 查询，并将查询结果封装为一个 List。</p>
<p>“com.sza.mapper.UserMapper.selectAll”：</p>
<p>这是 MyBatis 中映射的 SQL 语句的唯一标识符，通常由 <strong>命名空间</strong> 和 <strong>方法名</strong> 组成。</p>
<ul>
<li>com.sza.mapper.UserMapper：Mapper 文件的命名空间。</li>
<li>selectAll：Mapper 文件中对应的方法名称。</li>
<li>List<User>：表示查询结果是一个 User 对象的列表。MyBatis 会根据查询结果中的每一行记录创建一个 User 对象。</User></li>
</ul>
</blockquote>
<h2 id="解决SQL映射文件的警告提示"><a href="#解决SQL映射文件的警告提示" class="headerlink" title="解决SQL映射文件的警告提示"></a>解决SQL映射文件的警告提示</h2><p>产生原因：idea没和数据库建立连接，不识别表信息</p>
<p>解决方式：在idea中配置MySQL数据库连接</p>
 <img src="image-20241112101828715.png" class title="image-20241112101828715">

<h2 id="Mapper映射器"><a href="#Mapper映射器" class="headerlink" title="Mapper映射器"></a>Mapper映射器</h2><blockquote>
<p>参考 <a href="http://www.mybatis.cn/717.html">http://www.mybatis.cn/717.html</a></p>
<p>建议：此知识需要 注解、反射、动态代理</p>
<p>注解 <a href="https://sza0415.github.io/%E6%B3%A8%E8%A7%A3/">https://sza0415.github.io/%E6%B3%A8%E8%A7%A3/</a></p>
<p>动态代理 <a href="https://sza0415.github.io/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/">https://sza0415.github.io/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</a></p>
</blockquote>
<h3 id="什么是MyBatis映射器？"><a href="#什么是MyBatis映射器？" class="headerlink" title="什么是MyBatis映射器？"></a>什么是MyBatis映射器？</h3><p>MyBatis框架包括两种类型的XML文件，一类是配置文件，即mybatis-config.xml，另外一类是映射文件，例如XXXMapper.xml等。在 <a href="http://www.mybatis.cn/680.html">MyBatis的配置文件mybatis-config.xml</a> 包含了<mappers></mappers>节点，这里就是MyBatis映射器。</p>
<h3 id="1、MyBatis映射器发展历史简介"><a href="#1、MyBatis映射器发展历史简介" class="headerlink" title="1、MyBatis映射器发展历史简介"></a>1、MyBatis映射器发展历史简介</h3><p>映射器是MyBatis中最核心的组件之一，在MyBatis 3之前，只支持XML映射器，<font color="green">所有的SQL语句都必须在XML文件中配置</font>。而从MyBatis 3开始，开始支持接口映射器，其底层利用的是接口绑定技术。另外，接口映射器允许通过注解定义SQL语句，用以替代XML文件配置SQL。</p>
<h3 id="2、MyBatis映射器分类"><a href="#2、MyBatis映射器分类" class="headerlink" title="2、MyBatis映射器分类"></a>2、MyBatis映射器分类</h3><h4 id="MyBatis映射器分为三类，如下所示："><a href="#MyBatis映射器分为三类，如下所示：" class="headerlink" title="MyBatis映射器分为三类，如下所示："></a>MyBatis映射器分为三类，如下所示：</h4><p>（1）纯xml映射器，利用SqlSession的各种方法实现增删改查。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> session.selectOne(<span class="string">&quot;cn.mybatis.mydemo.mapper.PersonMapper.selectPersonById&quot;</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>（2）xml映射器+接口映射器的混合类型</p>
<p>先定义接口映射器，然后再定义xml映射器，其中xml映射器的namespace应该对应接口映射器的类名。其用法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">PersonMapper</span> <span class="variable">pm</span> <span class="operator">=</span> session.getMapper(PersonMapper.class);</span><br><span class="line"><span class="comment">// 直接调用接口的方法，查询id为1的Peson数据</span></span><br><span class="line"><span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> pm.selectPersonById(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>（3）注解+接口映射器的混合形式</p>
<p>此类形式，将原先xml里面的sql配置信息，变成Java注解的形式写到接口映射器，用法与上面的例子雷同。</p>
<h3 id="3、引入映射器的三种方式"><a href="#3、引入映射器的三种方式" class="headerlink" title="3、引入映射器的三种方式"></a>3、引入映射器的三种方式</h3><h4 id="3-1、通过文件类路径引入XML映射器"><a href="#3-1、通过文件类路径引入XML映射器" class="headerlink" title="3.1、通过文件类路径引入XML映射器"></a>3.1、通过文件类路径引入XML映射器</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;cn/mybatis/mydemo/mapper/StudentMapper.xml&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="3-2、通过包名引入映射器接口"><a href="#3-2、通过包名引入映射器接口" class="headerlink" title="3.2、通过包名引入映射器接口"></a>3.2、通过包名引入映射器接口</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;cn.mybatis.mydemo.mapper&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="3-3、用类注册引入映射器接口"><a href="#3-3、用类注册引入映射器接口" class="headerlink" title="3.3、用类注册引入映射器接口"></a>3.3、用类注册引入映射器接口</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">&quot;cn.mybatis.mydemo.mapper.StudentMapper&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="4-XML映射器-接口映射器"><a href="#4-XML映射器-接口映射器" class="headerlink" title="4.XML映射器+接口映射器"></a>4.XML映射器+接口映射器</h3><p>用XML定义映射器分为两个部分：接口定义和XML配置。先定义一个映射器接口，如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">StudentMapper</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Student <span class="title function_">getStudent</span><span class="params">(Long id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：映射器只是一个接口，而不是一个实现类。初学者可能会产生一个很大的疑问：接口不是不能运行吗？的确，接口不能直接运行，但是MyBatis内部运用了动态代理技术，生成接口的实现类，从而完成接口的相关功能。只要明白 MyBatis 会为这个接口生成一个代理对象，代理对象会去处理映射器接口相关的逻辑即可。</p>
<p>具体地说，MyBatis 会根据你提供的 XML 文件或者注解配置，利用 <strong>动态代理技术</strong> 在运行时生成接口的代理实现。以下是详细解析：</p>
<p>MyBatis 使用 JDK 的动态代理机制（<code>java.lang.reflect.Proxy</code>）为映射器接口生成实现类。</p>
<ul>
<li><p>当你调用 sqlSession.getMapper(YourMapper.class) 时：MyBatis 会检查是否存在对应的 Mapper 接口（如 AccountMapper）。如果存在，它会为这个接口生成一个代理对象。代理对象的 invoke 方法会拦截接口方法的调用，并根据你的 SQL 配置（XML 或注解）动态执行对应的逻辑。<br>例如：</p>
<ul>
<li><pre><code class="java">AccountMapper mapper = sqlSession.getMapper(AccountMapper.class);
Account account = mapper.findById(1);
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">然后，用XML方式创建映射器，如下所示：</span><br><span class="line"></span><br><span class="line">```xml</span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span><br><span class="line">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;</span><br><span class="line">&lt;mapper namespace=&quot;cn.mybatis.mydemo.mapper.StudentMapper&quot;&gt;</span><br><span class="line">   &lt;select id=&quot;getStudent&quot; parameterType=&quot;long&quot; resultType=&quot;student&quot;&gt;</span><br><span class="line">       SELECT id,name,address FROM Student WHERE id =#&#123;id&#125;</span><br><span class="line">   &lt;/select&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
</blockquote>
<p>有了这两个文件，就完成了一个映射器的定义。关于XML文件内容介绍，如下所示：</p>
<p>（1）<mapper> 元素中的属性 namespace 所对应的是一个接口的全限定名，于是 MyBatis 上下文就可以通过它找到对应的接口。</mapper></p>
<p>（2）<select> 元素表明这是一条查询语句，而属性 id 标识了这条 SQL，属性 parameterType&#x3D;”long” 说明传递给 SQL 的是一个 long 型的参数，而 resultType&#x3D;”student” 表示返回的是一个 Student 类型的返回值。而 student是配置文件 mybatis-config.xml 配置的别名，指代的是 com.mybatis.domain.Student。这条 SQL 中的 #{id} 表示传递进去的参数。</select></p>
<blockquote>
<p>注意：我们并没有配置 SQL 执行后和 Student 的对应关系，它是如何映射的呢？其实，这里采用的是一种被称为自动映射的功能，MyBatis在默认情况下提供自动映射，只要SQL返回的列名能和POJO的属性对应起来即可。</p>
</blockquote>
<p>最后，在MyBatis的配置文件里面引入这个XML映射器文件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;cn/mybatis/mydemo/mapper/StudentMapper.xml&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="4-1-接口绑定"><a href="#4-1-接口绑定" class="headerlink" title="4.1 接口绑定"></a>4.1 接口绑定</h5><p>接口绑定，就是在MyBatis中任意定义接口，然后把接口里面的方法和SQL语句绑定，我们直接调用接口方法就可以，这样比起原来了SqlSession提供的方法，可以有更加灵活的选择和设置。</p>
<p>接口绑定有两种实现方式，一种是通过注解绑定，就是在接口的方法上面加上 @Select、@Update等注解，里面包含Sql语句来绑定；另外一种就是通过xml里面写SQL来绑定，在这种情况下，要指定xml映射文件里面的namespace必须为接口的全路径名。</p>
<p>当Sql语句比较简单时候，用注解绑定，当SQL语句比较复杂时候，用xml绑定。一般情况下，用xml绑定的比较多。</p>
<p>使用MyBatis的mapper接口调用时要注意的事项有：</p>
<p>（1）Mapper接口方法名和mapper.xml中定义的每个sql的id相同；</p>
<p>（2）Mapper接口方法的输入参数类型和mapper.xml中定义的每个sql 的parameterType的类型相同；</p>
<p>（3）Mapper接口方法的输出参数类型和mapper.xml中定义的每个sql的resultType的类型相同；</p>
<p>（4）Mapper.xml文件中的namespace即是mapper接口的类路径。</p>
<h3 id="5-注解-接口映射器"><a href="#5-注解-接口映射器" class="headerlink" title="5. 注解+接口映射器"></a>5. 注解+接口映射器</h3><p>除 XML方式定义映射器外，还可以采用注解方式定义映射器，它只需要一个接口就可以通过 MyBatis 的注解来注入 SQL，如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">StudentMapper2</span> &#123;</span><br><span class="line">    <span class="meta">@Select(&quot;select id,name,address from student where id=#&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Student <span class="title function_">getStudent</span><span class="params">(Long id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注解方式完全等同于XML方式创建映射器，但是使用注解的方式比XML方式要简单得多。如果注解方式和XML方式同时定义时，XML 方式将覆盖掉注解方式，一般情况下，MyBatis官方推荐使用的是XML方式，因为XML映射器能完成更复杂的SQL功能。</p>
<p>这个接口可以在 XML 中定义，如下所示：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">&quot;cn.mybatis.mydemo.mapper.StudentMapper&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>demo:</p>
<img src="image-20241112102037616.png" class title="image-20241112102037616">

<ul>
<li>定义与SQL映射文件同名的Mapper接口，并且将Mapper接口与SQL映射文件放置在同一目录下（目的其实是为了好扫描）</li>
</ul>
<img src="image-20241112103024682.png" class title="image-20241112103024682">

<p>虽然在idea上配置文件和源代码是分离的，但编译过后<code>resources</code>和<code>java</code>两个是在一起的。</p>
<p>使用maven的compile编译一下：</p>
<img src="image-20241112103252060.png" class title="image-20241112103252060">
<p>因此：我们在<code>java</code>目录下和<code>resources</code>下创建相同的路径，最后编译就会在同一目录下：</p>
<img src="image-20241204142200302.png" class title="image-20241204142200302">

<img src="image-20241204142224720.png" class title="image-20241204142224720">

<ul>
<li>设置SQL映射文件的namespace属性为Mapper接口全限定名</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 设置配置文件的namespace为对应接口全限定名--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.sza.mapper.UserMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--  resultType指向封装的java类  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectAll&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.sza.pojo.User&quot;</span>&gt;</span></span><br><span class="line">        SELECT * FROM tb_user;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在Mapper接口中定义方法，方法名就是SQL映射文件中sql语句的id，并保持参数类型和返回值类型一致</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line">    List&lt;User&gt; <span class="title function_">selectAll</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>编码：通过SqlSession的getMapper方法获取Mapper接口的代理对象，调用对应方法完成sql的执行</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 3.1 获取UserMapper接口的代理对象</span></span><br><span class="line"><span class="type">UserMapper</span> <span class="variable">userMapper</span> <span class="operator">=</span> sqlSession.getMapper(UserMapper.class);</span><br><span class="line">List&lt;User&gt; users = userMapper.selectAll();</span><br><span class="line">System.out.println(users);</span><br></pre></td></tr></table></figure>

<ul>
<li>此外。如果Mapper接口名称和SQL映射文件名称相同，并且在同一目录下，则可以使用包扫描的方式简化SQL映射文件的加载。</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    加载映射文件。</span></span><br><span class="line"><span class="comment">    映射文件即SQL映射文件，该文件中配置了操作数据库的SQL语句，需要在MyBatis配置文件mybatis-config.xml中加载。</span></span><br><span class="line"><span class="comment">    mybatis-config.xml 文件可以加载多个映射文件，每个文件对应数据库中的一张表。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--        &lt;mapper resource=&quot;com/sza/mapper/UserMapper.xml&quot;/&gt;--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 使用包扫描的方式 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.sza.mapper&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="Mybatis核心配置文件"><a href="#Mybatis核心配置文件" class="headerlink" title="Mybatis核心配置文件"></a>Mybatis核心配置文件</h2><blockquote>
<p>详细可参考：<a href="http://www.mybatis.cn/680.html">http://www.mybatis.cn/680.html</a></p>
</blockquote>
<p>MyBatis框架包括两种类型的XML文件，一类是配置文件，即mybatis-config.xml，另外一类是映射文件，例如XXXMapper.xml等。MyBatis的配置文件包含了会深深影响 MyBatis行为的设置和属性信息。配置文件的层次结构如下：</p>
<ul>
<li><blockquote>
<p>configuration（配置）</p>
<ul>
<li>properties（属性）</li>
<li>settings（设置）</li>
<li>typeAliases（类型别名）</li>
<li>typeHandlers（类型处理器）</li>
<li>objectFactory（对象工厂）</li>
<li>plugins（插件）</li>
<li>environments（环境配置）<ul>
<li>environment（环境变量）</li>
<li>transactionManager（事务管理器）</li>
<li>dataSource（数据源）</li>
</ul>
</li>
<li>databaseIdProvider（数据库厂商标识）</li>
<li>mappers（映射器）</li>
</ul>
</blockquote>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">environments：配置数据库连接环境信息</span></span><br><span class="line"><span class="comment">可以配置多个environment，通过default属性切换不同的environment 例如不同的数据源</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    transactionManager（事务管理器）--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    dataSource（数据源）--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 数据库连接信息--&gt;</span></span><br><span class="line">             <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">                MySQL 8.0 以上 com.mysql.jdbc.Driver 更换为 com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="comment">                --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">                    mybatisDb是数据库名称</span></span><br><span class="line"><span class="comment">                    jdbc:mysql:// 是连接协议</span></span><br><span class="line"><span class="comment">                    在 xml 中 &amp; 符合要转义成 &amp;amp; 符号</span></span><br><span class="line"><span class="comment">                    MySQL 8.0 以上版本不需要建立 SSL 连接的，需要显示关闭。</span></span><br><span class="line"><span class="comment">                    allowPublicKeyRetrieval=true 允许客户端从服务器获取公钥。</span></span><br><span class="line"><span class="comment">                    最后还需要设置 CST(也就是设置时区)。</span></span><br><span class="line"><span class="comment">                --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/mybatisDb?useSSL=false<span class="symbol">&amp;amp;</span>allowPublicKeyRetrieval=true<span class="symbol">&amp;amp;</span>serverTimezone=UTC&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;xxxxx&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        加载映射文件。</span></span><br><span class="line"><span class="comment">        映射文件即SQL映射文件，该文件中配置了操作数据库的SQL语句，需要在MyBatis配置文件mybatis-config.xml中加载。</span></span><br><span class="line"><span class="comment">        mybatis-config.xml 文件可以加载多个映射文件，每个文件对应数据库中的一张表。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--        &lt;mapper resource=&quot;com/sza/mapper/UserMapper.xml&quot;/&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 使用包扫描的方式 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.sza.mapper&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="typeAliases"><a href="#typeAliases" class="headerlink" title="typeAliases"></a>typeAliases</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.blog.domain&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><typeAliases>：是 MyBatis 配置文件中的一个标签，用于定义类型别名。目的是减少重复写 Java 类的全限定名（如 com.blog.domain.User）。</typeAliases></p>
<p><package>：定义了一个包的路径，MyBatis 会自动扫描该包下的所有类，并为它们生成别名。</package></p>
<p><strong>生成的默认别名规则</strong></p>
<p>MyBatis 会使用类的简单名称（不包括包名）作为默认别名。例如，如果 com.blog.domain 包下有以下类：User 类、Article 类……</p>
<p>默认生成的别名是：user、article….</p>
<p>别名是大小写不敏感的，因此可以在 MyBatis 的 XML 配置中直接使用这些简化的别名，而不用写全限定名。</p>
<p>假设 com.blog.domain 包下有一个 User 类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.blog.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">// Getters and setters...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Mapper XML 文件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.blog.mapper.UserMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectUser&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">        SELECT * FROM users WHERE id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这里的 resultType&#x3D;”user” 使用了类型别名 user，对应的是 com.blog.domain.User 类。</p>
<p>此外，显式别名的配置方式：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">alias</span>=<span class="string">&quot;user&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.blog.domain.User&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">alias</span>=<span class="string">&quot;article&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.blog.domain.Article&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果完全使用注解方式开发，那么 <typeAliases> <strong>就没有必要了</strong>，因为注解开发中根本不依赖 XML 文件，也不会用到 <typeAliases> 定义的别名。</typeAliases></typeAliases></p>
<h2 id="Mybatis案例实操"><a href="#Mybatis案例实操" class="headerlink" title="Mybatis案例实操"></a>Mybatis案例实操</h2><h3 id="数据准备"><a href="#数据准备" class="headerlink" title="数据准备"></a>数据准备</h3><p>数据库表：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">use mybatisDb;  </span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> if <span class="keyword">exists</span> tb_brand;  </span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tb_brand( </span><br><span class="line">id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,  </span><br><span class="line">brand_name <span class="type">varchar</span>(<span class="number">20</span>),  company_name <span class="type">varchar</span>(<span class="number">20</span>),  </span><br><span class="line">orderd <span class="type">int</span>,  </span><br><span class="line">description <span class="type">varchar</span>(<span class="number">100</span>),  </span><br><span class="line">status <span class="type">int</span>  );  </span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_brand(brand_name, company_name, orderd, description, status) <span class="keyword">VALUES</span>(<span class="string">&#x27;三只松鼠&#x27;</span>,<span class="string">&#x27;三只松鼠有限&#x27;</span>,<span class="number">5</span>,<span class="string">&#x27;好好&#x27;</span>,<span class="number">0</span>), (<span class="string">&#x27;asd&#x27;</span>,<span class="string">&#x27;asda&#x27;</span>,<span class="number">100</span>,<span class="string">&#x27;sdasd&#x27;</span>,<span class="number">1</span>); </span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span><span class="keyword">from</span> tb_brand;</span><br></pre></td></tr></table></figure>

<p>实体类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sza.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Brand</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String BrandName;</span><br><span class="line">    <span class="keyword">private</span> String companyName;</span><br><span class="line">    <span class="keyword">private</span> Integer ordered;</span><br><span class="line">    <span class="keyword">private</span> String description;</span><br><span class="line">    <span class="keyword">private</span> Integer status;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getBrandName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BrandName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBrandName</span><span class="params">(String brandName)</span> &#123;</span><br><span class="line">        BrandName = brandName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getCompanyName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> companyName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCompanyName</span><span class="params">(String companyName)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.companyName = companyName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getOrdered</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ordered;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setOrdered</span><span class="params">(Integer ordered)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.ordered = ordered;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDescription</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> description;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDescription</span><span class="params">(String description)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.description = description;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getStatus</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Brand&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, BrandName=&#x27;&quot;</span> + BrandName + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, companyName=&#x27;&quot;</span> + companyName + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, ordered=&quot;</span> + ordered +</span><br><span class="line">                <span class="string">&quot;, description=&#x27;&quot;</span> + description + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, status=&quot;</span> + status +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setStatus</span><span class="params">(Integer status)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.status = status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>安装插件MybatisX：配置文件和源文件会有对应</p>
<img src="image-20241112112849216.png" class title="image-20241112112849216">

<h3 id="功能实现"><a href="#功能实现" class="headerlink" title="功能实现"></a>功能实现</h3><h4 id="查询：查询所有数据"><a href="#查询：查询所有数据" class="headerlink" title="查询：查询所有数据"></a>查询：查询所有数据</h4><ul>
<li>编写接口方法：Mapper接口</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sza.mapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sza.pojo.Brand;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BrandMapper</span> &#123;</span><br><span class="line">    List&lt;Brand&gt; <span class="title function_">selectAll</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>参数：无</p>
</li>
<li><p>结果：List<Brand> </Brand></p>
</li>
<li><p>编写sql语句：sql映射文件</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE mapper</span><br><span class="line">        PUBLIC <span class="string">&quot;-//mybatis.org//DTD mapper 3.0//EN&quot;</span></span><br><span class="line">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;mapper namespace=<span class="string">&quot;com.sza.mapper.BrandMapper&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;select id=<span class="string">&quot;selectAll&quot;</span> resultType=<span class="string">&quot;com.sza.pojo.Brand&quot;</span>&gt;</span><br><span class="line">        select *</span><br><span class="line">        from tb_brand;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>执行方法，测试</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisTest</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSelectAll</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 1.加载mybatis的核心配置文件，获取sqlSessionFactory</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="string">&quot;mybatis-config.xml&quot;</span>;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getResourceAsStream(resource);</span><br><span class="line">        <span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(inputStream);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.获取sqlSession对象，用它来执行sql</span></span><br><span class="line">        <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.1 获取BrandMapper接口的代理对象</span></span><br><span class="line">        <span class="type">BrandMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(BrandMapper.class);</span><br><span class="line">        List&lt;Brand&gt; brands = mapper.selectAll();</span><br><span class="line">        System.out.println(brands);</span><br><span class="line">        <span class="comment">// 4.释放资源</span></span><br><span class="line">        sqlSession.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="image-20241112150218288.png" class title="image-20241112150218288">
<p>我们发现BrandName和companyName的值都为null</p>
<ul>
<li><p>数据表的column和封装类的属性对应不上：</p>
<img src="image-20241112150248458.png" class title="image-20241112150248458">
<p>我们发现Brand类的BrandName和companyName和数据表中的字段brand_name和company_name对应不上，因此无法自动装填。</p>
<p>使用<code>resultMap</code>对不一致的进行映射：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--BrandMapper.xml--&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.sza.mapper.BrandMapper&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    将数据表的column与Brand类不对应的属性 一一对应起来</span></span><br><span class="line"><span class="comment">    id唯一标识</span></span><br><span class="line"><span class="comment">    type映射类型，支持别名</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;brandResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.sza.pojo.Brand&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    id: 完成主键字段的映射</span></span><br><span class="line"><span class="comment">    &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt;</span></span><br><span class="line"><span class="comment">    result：完成一半字段的映射</span></span><br><span class="line"><span class="comment">      &lt;result column=&quot;brand_name&quot; property=&quot;brandName&quot;/&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;brand_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;brandName&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;company_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;companyName&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--  这里不再使用resultType，而是使用resultMap  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectAll&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;brandResultMap&quot;</span>&gt;</span></span><br><span class="line">        select *</span><br><span class="line">        from tb_brand;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>再次运行结果：</p>
<img src="image-20241112151419110.png" class title="image-20241112151419110"></li>
</ul>
<h4 id="查询：查询详情"><a href="#查询：查询详情" class="headerlink" title="查询：查询详情"></a>查询：查询详情</h4><ul>
<li>编写接口方法：Mapper方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BrandMapper</span> &#123;</span><br><span class="line">    List&lt;Brand&gt; <span class="title function_">selectAll</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    Brand <span class="title function_">selectById</span><span class="params">(<span class="type">int</span> id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>参数 ：id</li>
<li>结果：Brand</li>
<li>编写SQL语句</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!--</span><br><span class="line">    参数占位符：</span><br><span class="line">    <span class="number">1.</span> #&#123;&#125;: 会将这个地方替换为? 防止sql注入</span><br><span class="line">    <span class="number">2.</span> $&#123;&#125;: 会拼接sql语句  会存在sql注入问题</span><br><span class="line">--&gt;</span><br><span class="line">		&lt;select id=<span class="string">&quot;selectById&quot;</span> resultMap=<span class="string">&quot;brandResultMap&quot;</span>&gt;</span><br><span class="line">        select *</span><br><span class="line">        from tb_brand <span class="type">where</span> <span class="variable">id</span> <span class="operator">=</span> #&#123;id&#125;</span><br><span class="line">    &lt;/select&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>执行方法，测试</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSelectById</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 1.加载mybatis的核心配置文件，获取sqlSessionFactory</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="string">&quot;mybatis-config.xml&quot;</span>;</span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getResourceAsStream(resource);</span><br><span class="line">    <span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(inputStream);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.获取sqlSession对象，用它来执行sql</span></span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.1 获取BrandMapper接口的代理对象</span></span><br><span class="line">    <span class="type">BrandMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(BrandMapper.class);</span><br><span class="line">    <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">Brand</span> <span class="variable">brand</span> <span class="operator">=</span> mapper.selectById(id);</span><br><span class="line">    System.out.println(brand);</span><br><span class="line">    <span class="comment">// 4.释放资源</span></span><br><span class="line">    sqlSession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="查询：多条件查询"><a href="#查询：多条件查询" class="headerlink" title="查询：多条件查询"></a>查询：多条件查询</h4><img src="image-20241112170308045.png" class title="image-20241112170308045">

<ul>
<li>编写接口方法 ：Mapper接口</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//    @Param(&quot;xxx&quot;) 是为了匹配 sql语句中#&#123;xxx&#125;的占位符</span></span><br><span class="line">    List&lt;Brand&gt; <span class="title function_">selectByCondition</span><span class="params">(<span class="meta">@Param(&quot;status&quot;)</span><span class="type">int</span> status,<span class="meta">@Param(&quot;companyName&quot;)</span>String companyName,<span class="meta">@Param(&quot;brandName&quot;)</span>String brandName)</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  如果参数都属于同一个对象，那么其实可以封装成一个对象作为参数  那么sql语句中 #&#123;xxx&#125; 就会去找该对象中的属性</span></span><br><span class="line">    List&lt;Brand&gt; <span class="title function_">selectByCondition</span><span class="params">(Brand brand)</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  当然也可以传入键值对 sql语句中的#&#123;xxx&#125;就会找map中对应的key</span></span><br><span class="line">    List&lt;Brand&gt; <span class="title function_">selectByCondition</span><span class="params">(Map map)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>参数：多个参数</li>
<li>结果List<Brand></Brand></li>
<li>编写SQL语句</li>
</ul>
<p>在 SQL 中，<code>||</code>是一个字符串连接运算符。它用于将两个或多个字符串连接在一起，形成一个新的字符串。例如，在查询语句<code>select &#39;abc&#39; || &#39;def&#39;;</code>中，结果将是<code>abcdef</code>，即将<code>&#39;abc&#39;</code>和<code>&#39;def&#39;</code>这两个字符串连接起来。</p>
<p>在 MySQL 中，字符串连接运算符是<code>CONCAT()</code>函数，而不是<code>||</code>。例如，在 MySQL 中上述的字符串连接操作可以写成<code>CONCAT(#&#123;companyName&#125;, &#39;%&#39;)</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--    #&#123;xxx&#125; 中的xxx尽量与类中的属性保持一致，会省去很多麻烦  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectByCondition&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;brandResultMap&quot;</span>&gt;</span></span><br><span class="line">        select *</span><br><span class="line">        from tb_brand</span><br><span class="line">        where status= #&#123;status&#125;</span><br><span class="line">        and company_name like concat(&#x27;%&#x27;,#&#123;companyName&#125;,&#x27;%&#x27;)</span><br><span class="line">        and brand_name like concat(&#x27;%&#x27;,#&#123;brandName&#125;,&#x27;%&#x27;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>执行方法，测试</li>
</ul>
<p>散装参数，方法中有多个参数，需要使用@Param(“SQL参数占位符”)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//    @Param(&quot;xxx&quot;) 是为了匹配 sql语句中#&#123;xxx&#125;的占位符</span></span><br><span class="line">    List&lt;Brand&gt; <span class="title function_">selectByCondition</span><span class="params">(<span class="meta">@Param(&quot;status&quot;)</span><span class="type">int</span> status,<span class="meta">@Param(&quot;companyName&quot;)</span>String companyName,<span class="meta">@Param(&quot;brandName&quot;)</span>String brandName)</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSelectByCondition</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">status</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">conpanyName</span> <span class="operator">=</span> <span class="string">&quot;三只&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">brandName</span> <span class="operator">=</span> <span class="string">&quot;松鼠&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.加载mybatis的核心配置文件，获取sqlSessionFactory</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="string">&quot;mybatis-config.xml&quot;</span>;</span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getResourceAsStream(resource);</span><br><span class="line">    <span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(inputStream);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.获取sqlSession对象，用它来执行sql</span></span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.1 获取BrandMapper接口的代理对象</span></span><br><span class="line">    <span class="type">BrandMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(BrandMapper.class);</span><br><span class="line">    List&lt;Brand&gt; brands = mapper.selectByCondition(status, conpanyName, brandName);</span><br><span class="line">    System.out.println(brands);</span><br><span class="line">    <span class="comment">// 4.释放资源</span></span><br><span class="line">    sqlSession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对象参数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  如果参数都属于同一个对象，那么其实可以封装成一个对象作为参数  那么sql语句中 #&#123;xxx&#125; 就会去找该对象中的属性</span></span><br><span class="line">    List&lt;Brand&gt; <span class="title function_">selectByCondition</span><span class="params">(Brand brand)</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSelectByCondition</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">status</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">conpanyName</span> <span class="operator">=</span> <span class="string">&quot;三只&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">brandName</span> <span class="operator">=</span> <span class="string">&quot;松鼠&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">Brand</span> <span class="variable">brand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Brand</span>();</span><br><span class="line">        brand.setBrandName(brandName);</span><br><span class="line">        brand.setStatus(status);</span><br><span class="line">        brand.setCompanyName(conpanyName);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.加载mybatis的核心配置文件，获取sqlSessionFactory</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="string">&quot;mybatis-config.xml&quot;</span>;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getResourceAsStream(resource);</span><br><span class="line">        <span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(inputStream);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.获取sqlSession对象，用它来执行sql</span></span><br><span class="line">        <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.1 获取BrandMapper接口的代理对象</span></span><br><span class="line">        <span class="type">BrandMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(BrandMapper.class);</span><br><span class="line"><span class="comment">//        List&lt;Brand&gt; brands = mapper.selectByCondition(status, conpanyName, brandName);</span></span><br><span class="line">        List&lt;Brand&gt; brands = mapper.selectByCondition(brand);</span><br><span class="line">        System.out.println(brands);</span><br><span class="line">        <span class="comment">// 4.释放资源</span></span><br><span class="line">        sqlSession.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>map集合参数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  当然也可以传入键值对 sql语句中的#&#123;xxx&#125;就会找map中对应的key</span></span><br><span class="line">    List&lt;Brand&gt; <span class="title function_">selectByCondition</span><span class="params">(Map map)</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSelectByCondition</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">status</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">conpanyName</span> <span class="operator">=</span> <span class="string">&quot;三只&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">brandName</span> <span class="operator">=</span> <span class="string">&quot;松鼠&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        Brand brand = new Brand();</span></span><br><span class="line"><span class="comment">//        brand.setBrandName(brandName);</span></span><br><span class="line"><span class="comment">//        brand.setStatus(status);</span></span><br><span class="line"><span class="comment">//        brand.setCompanyName(conpanyName);</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        map.put(<span class="string">&quot;status&quot;</span>, status);</span><br><span class="line">        map.put(<span class="string">&quot;companyName&quot;</span>, conpanyName);</span><br><span class="line">        map.put(<span class="string">&quot;brandName&quot;</span>, brandName);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.加载mybatis的核心配置文件，获取sqlSessionFactory</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="string">&quot;mybatis-config.xml&quot;</span>;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getResourceAsStream(resource);</span><br><span class="line">        <span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(inputStream);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.获取sqlSession对象，用它来执行sql</span></span><br><span class="line">        <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.1 获取BrandMapper接口的代理对象</span></span><br><span class="line">        <span class="type">BrandMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(BrandMapper.class);</span><br><span class="line"><span class="comment">//        List&lt;Brand&gt; brands = mapper.selectByCondition(status, conpanyName, brandName);</span></span><br><span class="line"><span class="comment">//        List&lt;Brand&gt; brands = mapper.selectByCondition(brand);</span></span><br><span class="line">        List&lt;Brand&gt; brands = mapper.selectByCondition(map);</span><br><span class="line">        System.out.println(brands);</span><br><span class="line">        <span class="comment">// 4.释放资源</span></span><br><span class="line">        sqlSession.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="查询：动态条件查询"><a href="#查询：动态条件查询" class="headerlink" title="查询：动态条件查询"></a>查询：动态条件查询</h4><p>SQL语句会随着用户的输入或外部条件的变化而变化，我们称为<font color="yellow">动态SQL</font>。</p>
<p>动态SQL是MyBatis的强大特性之一：</p>
<ul>
<li><code>if</code>：使用动态 SQL 最常见情景是根据条件包含 where 子句的一部分</li>
</ul>
<p>使用<code>test</code>进行逻辑判断，其中的变量是类中的属性，而不是数据库的字段。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectByCondition&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;brandResultMap&quot;</span>&gt;</span></span><br><span class="line">    select *</span><br><span class="line">    from tb_brand</span><br><span class="line">    where status= #&#123;status&#125;</span><br><span class="line">    and company_name like concat(&#x27;%&#x27;,#&#123;companyName&#125;,&#x27;%&#x27;)</span><br><span class="line">    and brand_name like concat(&#x27;%&#x27;,#&#123;brandName&#125;,&#x27;%&#x27;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>例如在该where子句中，由三个条件组成，用户可能只勾选其中两个条件进行查询。我们可以使用<code>if</code>进行动态添加。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectByDynamicCondition&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;brandResultMap&quot;</span>&gt;</span></span><br><span class="line">    select *</span><br><span class="line">    from tb_brand</span><br><span class="line">    where</span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;status != null&quot;</span>&gt;</span></span><br><span class="line">        status = #&#123;status&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;companyName != null and companyName != &#x27;&#x27; &quot;</span>&gt;</span>  -- 这里判断条件中的变量要是Brand类的属性，不要写成company_name</span><br><span class="line">        and company_name like concat(&#x27;%&#x27;,#&#123;companyName&#125;,&#x27;%&#x27;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;brandName != null and brandName != &#x27;&#x27; &quot;</span>&gt;</span></span><br><span class="line">        and brand_name like concat(&#x27;%&#x27;,#&#123;brandName&#125;,&#x27;%&#x27;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// BrandMapper.java 中添加selectByDynamicCondition</span></span><br><span class="line">List&lt;Brand&gt; <span class="title function_">selectByDynamicCondition</span><span class="params">(Brand brand)</span>;</span><br></pre></td></tr></table></figure>

<p>假设我们给 status和companyName属性赋值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSelectByDynamicCondition</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">status</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">companyName</span> <span class="operator">=</span> <span class="string">&quot;三只&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">brandName</span> <span class="operator">=</span> <span class="string">&quot;松鼠&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">Brand</span> <span class="variable">brand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Brand</span>();</span><br><span class="line">        brand.setStatus(status);</span><br><span class="line">        brand.setCompanyName(companyName);</span><br><span class="line"><span class="comment">//        brand.setBrandName(brandName);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.加载mybatis的核心配置文件，获取sqlSessionFactory</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="string">&quot;mybatis-config.xml&quot;</span>;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getResourceAsStream(resource);</span><br><span class="line">        <span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(inputStream);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.获取sqlSession对象，用它来执行sql</span></span><br><span class="line">        <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.1 获取BrandMapper接口的代理对象</span></span><br><span class="line">        <span class="type">BrandMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(BrandMapper.class);</span><br><span class="line"></span><br><span class="line">        List&lt;Brand&gt; brands = mapper.selectByDynamicCondition(brand);</span><br><span class="line">        System.out.println(brands);</span><br><span class="line">        <span class="comment">// 4.释放资源</span></span><br><span class="line">        sqlSession.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>运行会发现生成的sql语句：</p>
<img src="image-20241112211600383.png" class title="image-20241112211600383">

<p>说明是有效的，选择了 status &#x3D; #{status}和 and company_name like concat(‘%’,#{companyName},’%’)两个条件进行查询，但是现在出现一个问题：<font color="yellow">如果不选择status这个条件，那么where后接的会有and，如下：</font></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">        <span class="type">Brand</span> <span class="variable">brand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Brand</span>();</span><br><span class="line"><span class="comment">//        brand.setStatus(status);</span></span><br><span class="line">        brand.setCompanyName(companyName);</span><br><span class="line">        brand.setBrandName(brandName);</span><br></pre></td></tr></table></figure>

<p>运行报错：</p>
<img src="image-20241112211857620.png" class title="image-20241112211857620">
<p>解决办法：使用<code>&lt;where&gt;</code>标签替换where关键字，<code>&lt;whrer&gt;</code>只会在它包含的标签中有返回值的情况下才插入 “WHERE” 子句。 而且，若子句的开头为 “AND” 或 “OR”，where标签也会将它们去除。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectByDynamicCondition&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;brandResultMap&quot;</span>&gt;</span></span><br><span class="line">    select *</span><br><span class="line">    from tb_brand</span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;status != null&quot;</span>&gt;</span></span><br><span class="line">            status = #&#123;status&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;companyName != null and companyName != &#x27;&#x27; &quot;</span>&gt;</span></span><br><span class="line">            and company_name like concat(&#x27;%&#x27;,#&#123;companyName&#125;,&#x27;%&#x27;)</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;brandName != null and brandName != &#x27;&#x27; &quot;</span>&gt;</span></span><br><span class="line">            and brand_name like concat(&#x27;%&#x27;,#&#123;brandName&#125;,&#x27;%&#x27;)</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<img src="image-20241112212438460.png" class title="image-20241112212438460">
<p>我们发现and被去除了，此外我们如果不设置任何的值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">        <span class="type">Brand</span> <span class="variable">brand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Brand</span>();</span><br><span class="line"><span class="comment">//        brand.setStatus(status);</span></span><br><span class="line"><span class="comment">//        brand.setCompanyName(companyName);</span></span><br><span class="line"><span class="comment">//        brand.setBrandName(brandName);</span></span><br></pre></td></tr></table></figure>

<p>运行，发现不会插入where子句：</p>
<img src="image-20241112212538086.png" class title="image-20241112212538086">

<ul>
<li>choose (when, otherwise) 选择 ，类似于Java中的switch语句，从多个条件中选择一个</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectByConditionSingle&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;brandResultMap&quot;</span>&gt;</span></span><br><span class="line">    select *</span><br><span class="line">    from tb_brand</span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">choose</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;status != null&quot;</span>&gt;</span></span><br><span class="line">                status = #&#123;status&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;companyName != null and companyName != &#x27;&#x27; &quot;</span>&gt;</span></span><br><span class="line">                company_name like concat(&#x27;%&#x27;,#&#123;companyName&#125;,&#x27;%&#x27;)</span><br><span class="line">            <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;brandName != null and brandName != &#x27;&#x27; &quot;</span>&gt;</span></span><br><span class="line">                brand_name like concat(&#x27;%&#x27;,#&#123;brandName&#125;,&#x27;%&#x27;)</span><br><span class="line">            <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">otherwise</span>&gt;</span></span><br><span class="line">                1 = 1</span><br><span class="line">            <span class="tag">&lt;/<span class="name">otherwise</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">choose</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>choose</code>相当于switch，<code>when</code>类似于case，<code>otherwise</code>类似于default。</p>
<ul>
<li>trim (where, set)</li>
<li>foreach</li>
</ul>
<h4 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;addBrand&quot;</span>&gt;</span></span><br><span class="line">    INSERT into tb_brand (brand_name,company_name,ordered,description,status)</span><br><span class="line">    VALUES (#&#123;brandName&#125;,#&#123;companyName&#125;,#&#123;ordered&#125;,#&#123;description&#125;,#&#123;status&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>需要执行sql语句后提交事务：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">BrandMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(BrandMapper.class);</span><br><span class="line"></span><br><span class="line"> mapper.addBrand(brand);</span><br><span class="line"> <span class="comment">// 提交事务</span></span><br><span class="line"> sqlSession.commit();</span><br></pre></td></tr></table></figure>

<p>Mybatis事务，可以在openSession默认开启事务：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<h5 id="主键返回"><a href="#主键返回" class="headerlink" title="主键返回"></a>主键返回</h5><p>当我们添加东西，想要返回其主键id值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mapper.addBrand(brand);</span><br><span class="line">    <span class="comment">// 提交事务</span></span><br><span class="line">    sqlSession.commit();</span><br><span class="line">    System.out.println(brand.getId()); <span class="comment">// null</span></span><br></pre></td></tr></table></figure>

<p>打印为null，及时数据库中添加了该数据</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;addBrand&quot;</span> <span class="attr">useGeneratedKeys</span>=<span class="string">&quot;true&quot;</span> <span class="attr">keyProperty</span>=<span class="string">&quot;id&quot;</span>&gt;</span></span><br><span class="line">     INSERT into tb_brand (brand_name,company_name,ordered,description,status)</span><br><span class="line">     VALUES (#&#123;brandName&#125;,#&#123;companyName&#125;,#&#123;ordered&#125;,#&#123;description&#125;,#&#123;status&#125;)</span><br><span class="line"> <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>添加useGeneratedKeys&#x3D;”true” keyProperty&#x3D;”id” id 为tb_brand的主键，添加该命令，返回添加数据的主键。再此添加，就会打印出添加的id。</p>
<h4 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h4><img src="image-20241117144429821.png" class title="image-20241117144429821">]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>前端入门</title>
    <url>/%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<img src="image-20241030195107388.png" class title="前端介绍图片">

<h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><h3 id="HTML-全称-Hypertext-Markup-Lanuage-超文本标记语言"><a href="#HTML-全称-Hypertext-Markup-Lanuage-超文本标记语言" class="headerlink" title="HTML 全称 Hypertext Markup Lanuage 超文本标记语言"></a><u><font color="blue">HTML 全称 Hypertext Markup Lanuage 超文本标记语言</font></u></h3><p>XML的标签可以由自己定义，而HTML的标签都是预定义好的</p>
<p>HTML代码直接在浏览器中运行，HTML标签由浏览器解析</p>
<p>HTML 的作用是为网页提供结构，它告诉浏览器哪些部分是标题，哪些部分是段落，哪些是列表……</p>
<p>HTML通过一系列的标签（也称为元素）来定义文本、图像、链接等等。HTML标签可以通过属性来提供更多的信息。</p>
<p>HTML标签是由尖括号包围起来的关键字。</p>
<p>标签通常成对出现，包括开始标签和结束标签（也称为双标签），内容位于这两个标签之间，例如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>这是一个段落<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>这是一个标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;www.baidu.com&quot;</span>&gt;</span>这是一个超链接<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>除了双标签，也存在单标签，顾名思义，单标签没有结束标签，例如input、换行、分割线标签：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;text&quot;</span>&gt;</span><br><span class="line">&lt;br&gt; </span><br><span class="line">&lt;hr&gt;</span><br></pre></td></tr></table></figure>

<p>区别在于：单表签用于没有内容的元素，双标签用于有内容的元素</p>
<h3 id="HTML文本结构"><a href="#HTML文本结构" class="headerlink" title="HTML文本结构"></a><font color="blue"><u>HTML文本结构</u></font></h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span> </span><br><span class="line"><span class="comment">&lt;!-- 告诉浏览器 这是一个 HTML文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!-- html标签对 也是咱HTML文档的根元素 </span></span><br><span class="line"><span class="comment">    意思就是 它是我们这个HTML文档的起始点 也是这个文档的最外层容器 包含了整个文档的结构 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!-- head标签对 表示我们这个文档的头部 包含了一些文件的原信息 </span></span><br><span class="line"><span class="comment">    比如文档的标题 title 文档的编码格式 &lt;meta charset&gt;</span></span><br><span class="line"><span class="comment">    以及外部样式表CSS和JS文件</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>HTML 练习1<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!-- body标签对 包含了实际显示在流浪器中页面的内容 </span></span><br><span class="line"><span class="comment">    比如一些文本、图像和链接等等</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>这是一个段落<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>这是一个标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.baidu.com&quot;</span>&gt;</span>这是一个超链接<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="常用文本标签"><a href="#常用文本标签" class="headerlink" title="常用文本标签"></a>常用文本标签</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span> </span><br><span class="line"><span class="comment">&lt;!-- 告诉浏览器 这是一个 HTML文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!-- html标签对 也是咱HTML文档的根元素 </span></span><br><span class="line"><span class="comment">    意思就是 它是我们这个HTML文档的起始点 也是这个文档的最外层容器 包含了整个文档的结构 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!-- head标签对 表示我们这个文档的头部 包含了一些文件的原信息 </span></span><br><span class="line"><span class="comment">    比如文档的标题 title 文档的编码格式 &lt;meta charset&gt;</span></span><br><span class="line"><span class="comment">    以及外部样式表CSS和JS文件</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>HTML 练习1<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!-- body标签对 包含了实际显示在流浪器中页面的内容 </span></span><br><span class="line"><span class="comment">    比如一些文本、图像和链接等等</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>这是一个段落<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>一级标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>二级标签<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>段落标签<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>更改文本样式： <span class="tag">&lt;<span class="name">b</span>&gt;</span>字体加粗<span class="tag">&lt;/<span class="name">b</span>&gt;</span> <span class="tag">&lt;<span class="name">i</span>&gt;</span>斜体<span class="tag">&lt;/<span class="name">i</span>&gt;</span> <span class="tag">&lt;<span class="name">u</span>&gt;</span>下划线<span class="tag">&lt;/<span class="name">u</span>&gt;</span> <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 无序列表 unordered list 包裹着几个&lt;li&gt; 标签 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span> 1 <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span> 2 <span class="tag">&lt;/<span class="name">li</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 有序列表 ordered list 包裹着几个&lt;li&gt;标签 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span> 1 <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span> 2 <span class="tag">&lt;/<span class="name">li</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 我们也可以为表格添加边框，方法就是在table标签</span></span><br><span class="line"><span class="comment">    里添加border属性 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">&quot;2&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- tr: table row --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 第一行为列标题，用&lt;th&gt;包裹而不是&lt;td&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- td: table data --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>列标题1<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>列标题2<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>列标题3<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span> 元素1 <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span> 元素2 <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span> 元素3 <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="HTML标签属性"><a href="#HTML标签属性" class="headerlink" title="HTML标签属性"></a>HTML标签属性</h4><p>属性在 HTML 中起到非常重要的作用，它们用于定义元素的行为和外观，以及与其他元素的关系。下面是 HTML 属性的一些基本概念和常见用法。</p>
<p>在 HTML 中，每个元素都可以有一个或多个属性，用于描述元素的特征和行为。属性的基本语法是：<code>&lt;开始标签 属性名=&quot;属性值&quot;&gt;</code>，其中属性名用于标识该属性，属性值则定义该属性的值。属性名和属性值之间用等号 <code>=</code> 隔开，属性值一般要用引号将其括起来，可以是单引号或双引号，示例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;image.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;图片&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>其中，<code>src</code> 是指定图片的文件路径的属性，<code>alt</code> 是指定在无法加载图片时显示的替代文本的属性。这些属性可以让用户了解图像的内容，同时也有助于调整图片的大小和位置。</p>
<p>属性是用来定义元素的性质和功能的。它们可以指定元素的尺寸、颜色、文字方向、链接目标等，有助于页面的定位和布局。下面是一些常见的属性用法：</p>
<ol>
<li><code>class</code> 属性：<code>class</code> 属性是用于向元素添加一个或多个类名，以便通过 CSS 样式表定义样式。此外，类名还可以用来实现 JavaScript 的交互效果。例如：</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;note&quot;</span>&gt;</span>这是一个带有 note 类属性的 p 标签<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol>
<li><code>id</code> 属性：<code>id</code> 属性是用于将元素标识为唯一的标识符。它使得我们可以通过 JavaScript 或 CSS 来定位和操作该元素。例如：</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;header&quot;</span>&gt;</span>这是一个带有 header id 的 div 标签<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol>
<li><code>style</code> 属性：<code>style</code> 属性是用于将CSS样式规则直接应用于元素。它可以用于控制元素的颜色、字体、大小和布局等。例如：</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;color: red; font-size: 20px;&quot;</span>&gt;</span>这是一段红色的文字<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>以上三种是所有标签都有的属性，也有一些标签具有独特的属性，比如 a 标签的 href 属性，img 标签的 src 属性等等。</p>
<h4 id="HTML区块-块元素与行内元素"><a href="#HTML区块-块元素与行内元素" class="headerlink" title="HTML区块-块元素与行内元素"></a>HTML区块-块元素与行内元素</h4><p>有些元素在浏览器中显示是独占一行的，而其他元素是不能跟这个元素位于同一行，例如p标签、h1标签以及表格table标签等等。</p>
<p>而有些元素则不是，意思就是其他元素可以和这个元素位于同一行。比如a标签、img标签等。</p>
<p>因此根据元素的表达形式可以分为：行内元素和块元素。这些不同类型的元素在 HTML 文档中的呈现和布局方面有很大的不同。下面是关于这两种类型的元素的详细说明：</p>
<ol>
<li><code>块级元素（block）</code>：块级元素通常用于组织和布局页面的主要结构和内容，例如段落、标题、列表、表格等。它们用于创建页面的主要部分，将内容分隔成逻辑块。<ul>
<li>块级元素通常会从新行开始，并占据整行的宽度，因此它们会在页面上呈现为一块独立的内容块。</li>
<li>可以包含其他块级元素和行内元素。</li>
<li>常见的块级元素包括 <code>&lt;div&gt;</code>, <code>&lt;p&gt;</code>, <code>&lt;h1&gt;</code> 到 <code>&lt;h6&gt;</code>, <code>&lt;ul&gt;</code>, <code>&lt;ol&gt;</code>, <code>&lt;li&gt;</code>, <code>&lt;table&gt;</code>, <code>&lt;form&gt;</code> 等。</li>
</ul>
</li>
<li><code>行内元素（inline）</code>：行内元素通常用于添加文本样式或为文本中的一部分应用样式。它们可以在文本中插入小的元素，例如超链接、强调文本等。<ul>
<li>行内元素通常在同一行内呈现，不会独占一行。</li>
<li>它们只占据其内容所需的宽度，而不是整行的宽度。</li>
<li>行内元素不能包含块级元素，但可以包含其他行内元素。</li>
<li>常见的行内元素包括 <code>&lt;span&gt;</code>, <code>&lt;a&gt;</code>, <code>&lt;strong&gt;</code>, <code>&lt;em&gt;</code>, <code>&lt;img&gt;</code>, <code>&lt;br&gt;</code>, <code>&lt;input&gt;</code> 等。</li>
</ul>
</li>
</ol>
<p>示例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>这是一个块级元素，通常就用于创建一个可以包含其他HTML元素的容器快，它通常没有任何语义，仅用于组织内容。通常用于创建页面的布局结构<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>这也是一个块级元素，通常用于段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://docs.geeksman.com&quot;</span>&gt;</span>这是一个行内元素，它嵌套在段落中。<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>行内元素，span标签相当于没有任何内容的a标签和img标签，主要作用就是将一小块文本给它包装起来，以便于对它们使用样式、CSS或者使用JS行为。因为是行内元素，不会独占一行，只会占用内容所需长度<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>总结：<div>标签通常用于创建块级容器，以便于组织页面的结构和布局，而<span>标签用于内联样式化文本，给文本的一部应用样式或者标记，使用这两个标签时通常是与CSS和JS一起使用。</span></div></p>
<h4 id="表单form标签"><a href="#表单form标签" class="headerlink" title="表单form标签"></a>表单form标签</h4><p>HTML 表单（form）是一种重要的元素， 用于收集和提交用户输入的数据。表单允许用户输入文本、选择选项、上传文件等，然后将这些数据提交到服务器进行处理。一个基本的HTML表单由以下几个主要部分组成：</p>
<ol>
<li><code>&lt;form&gt;</code> 元素：表单元素是表单的容器，创建一个表单，就和创建一个表格差不多，如果想要制作表单，需要将表单中的所有元素必须包含在form标签内部即可。它定义了数据提交到哪里以及使用哪种 HTTP 方法（通常是 GET 或 POST ）来提交数据。它可以包含输入字段、按钮等元素。</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/submit&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 表单元素 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>输入字段</code>：<code>&lt;input&gt;</code> 标签是 HTML 中用于创建表单元素的**<u>最常见标签</u>**之一。它允许用户输入文本、选择选项、上传文件等等。<code>&lt;input&gt;</code> 元素有多个属性，用于指定不同类型的输入和控制输入的方式。以下是一些常见的 <code>&lt;input&gt;</code> 标签的属性和它们的详细说明：</p>
<p><code>type</code> 属性：指定input元素的类型，它可以有以下不同的值：</p>
<ul>
<li><code>text</code>：创建文本输入框，用于用户输入文本。</li>
<li><code>password</code>：创建密码输入框，输入内容会被隐藏。</li>
<li><code>radio</code>：创建单选按钮，用户只能选择一个选项。</li>
<li><code>checkbox</code>：创建复选框，用户可以选择多个选项。</li>
<li><code>number</code>：创建数字输入框，允许用户输入数字。</li>
<li><code>email</code>：创建用于输入电子邮件地址的输入框。</li>
<li><code>file</code>：创建文件上传字段，用户可以上传文件。</li>
<li><code>submit</code>：创建提交按钮，用于提交表单数据。</li>
<li><code>reset</code>：创建重置按钮，用于重置表单数据。</li>
<li><code>button</code>：创建自定义按钮，通常与 JavaScript 一起使用。</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;#&quot;</span>&gt;</span>   </span><br><span class="line">    <span class="comment">&lt;!-- placeholder 文本框里默认显示的内容 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;username&quot;</span>&gt;</span>用户名<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;username&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;请输入你的用户名&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 在html当中有专门为input元素做标记的标签label </span></span><br><span class="line"><span class="comment">        仅限于和input对应使用 使用for与input标签中的id进行对应</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;password&quot;</span>&gt;</span> 密码： <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">id</span>=<span class="string">&quot;password&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;密码&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- radio 要想实现单选框的效果</span></span><br><span class="line"><span class="comment">    需要在多个radio 的name为同一个值--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">value</span>=<span class="string">&quot;male&quot;</span>&gt;</span> 男</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">value</span>=<span class="string">&quot;female&quot;</span>&gt;</span> 女</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">value</span>=<span class="string">&quot;其他&quot;</span>&gt;</span> 其他</span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 多选 checkbox--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span>&gt;</span>爱好：<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hobby&quot;</span> <span class="attr">value</span>=<span class="string">&quot;yes&quot;</span>&gt;</span> 篮球</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hobby&quot;</span> <span class="attr">value</span>=<span class="string">&quot;yes&quot;</span>&gt;</span> 唱</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hobby&quot;</span> <span class="attr">value</span>=<span class="string">&quot;yes&quot;</span>&gt;</span> 跳</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hobby&quot;</span> <span class="attr">value</span>=<span class="string">&quot;yes&quot;</span>&gt;</span> rap</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hobby&quot;</span> <span class="attr">value</span>=<span class="string">&quot;yes&quot;</span>&gt;</span> 用java搞科研</span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">&quot;country&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;zh&quot;</span>&gt;</span>中国<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;us&quot;</span>&gt;</span>美国<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 其他选项 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- submit 将form表单中填写的数据 给提交到一个地方</span></span><br><span class="line"><span class="comment">    具体是哪个地方，就是form标签的属性action：表示向何处发送我们的数据</span></span><br><span class="line"><span class="comment">    所以action的属性值也就是一个URL</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>表单元素可以包含一些属性，以指定表单的行为和样式。常见的表单属性包括：</p>
<table>
<thead>
<tr>
<th align="center">属性</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">action</td>
<td align="center">指定表单数据提交到服务器的 URL。</td>
</tr>
<tr>
<td align="center">method</td>
<td align="center">指定用于提交数据的 HTTP 方法，通常为 <code>get</code> 或 <code>post</code>。</td>
</tr>
<tr>
<td align="center">name</td>
<td align="center">为表单命名，以便在 JavaScript 中引用。</td>
</tr>
<tr>
<td align="center">target</td>
<td align="center">指定表单提交后的目标窗口或框架。</td>
</tr>
</tbody></table>
<p>表单提交方式的区别</p>
<p><code>get</code>：默认值，主动地获取方式，参数放在 URL 上，数据的容量有限，安全性差，有缓存；</p>
<p><code>post</code>：数据存放在请求体中，数据量理论上没有限制，相对安全，没有缓存。</p>
<p>最后，我们使用表单来写一个用户注册的页面，代码如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>用户注册<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/submit&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;username&quot;</span>&gt;</span>用户名：<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;password&quot;</span>&gt;</span>密码：<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;email&quot;</span>&gt;</span>电子邮件地址：<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;age&quot;</span>&gt;</span>年龄：<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;number&quot;</span> <span class="attr">width</span>=<span class="string">&quot;5&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span>&gt;</span>性别：<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">value</span>=<span class="string">&quot;male&quot;</span>&gt;</span> 男</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">value</span>=<span class="string">&quot;female&quot;</span>&gt;</span> 女<span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span>&gt;</span>喜欢的编程语言：<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;languages&quot;</span> <span class="attr">value</span>=<span class="string">&quot;python&quot;</span>&gt;</span> Python</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;languages&quot;</span> <span class="attr">value</span>=<span class="string">&quot;javascript&quot;</span>&gt;</span> JavaScript</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;languages&quot;</span> <span class="attr">value</span>=<span class="string">&quot;java&quot;</span>&gt;</span> Java</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;languages&quot;</span> <span class="attr">value</span>=<span class="string">&quot;cpp&quot;</span>&gt;</span> C++<span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><p>CSS的全称：Cascading Style Sheets 中文名：层叠样式表</p>
<p>用于定义网页样式和布局的样式表语言，一般是与HTML一起用于构建web页面的，HTML负责定义页面的结构和内容，而CSS负责控制页面的外观和样式。</p>
<p>通过CSS，你可以指定页面各个元素的颜色、字体、大小、间距、边框、背景等样式，从而实现更精确的页面设计。</p>
<p><img src="Users\SZA\AppData\Roaming\Typora\typora-user-images\image-20241021145738590.png" alt="image-20241021145738590"></p>
<p>CSS语法：</p>
<p>CSS通常由选择器、属性和属性值组成，多个规则可以组合在一起，以便同时应用多个样式。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">选择器 &#123;</span><br><span class="line">    属性<span class="number">1</span>: 属性值<span class="number">1</span>;</span><br><span class="line">    属性<span class="number">2</span>: 属性值<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意事项</p>
<ol>
<li>声明的每一行属性，都需要以英文分号结尾；</li>
<li>声明中的所有属性和值都是以键值对这种形式出现的；</li>
<li>选择器的声明中可以写无数条属性</li>
</ol>
<p>这个选择器就是要选择要应用样式的这个HTML元素&#x2F;标签，它可以是选择所有元素或者特定元素或者特定类或者特定id</p>
<h4 id="CSS导入方式"><a href="#CSS导入方式" class="headerlink" title="CSS导入方式"></a>CSS导入方式</h4><p>在 CSS 中，你可以使用不同的方式来导入样式表，以便将样式应用到 HTML 文档。下面是三种常见的 CSS 导入方式：</p>
<ol>
<li><code>内联样式（Inline Styles）</code>：内联样式是将 CSS 样式直接嵌入到 HTML 元素中的一种方式。你可以在 HTML 标签的 style 属性中定义样式规则。这些样式仅适用于特定元素，优先级较高。</li>
</ol>
<p>示例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">style</span>=<span class="string">&quot;color: blue; font-size: 30px;&quot;</span>&gt;</span>这是一段内联样式文本。<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol>
<li><code>内部样式表（Internal Stylesheet）</code>：内部样式表是将 CSS 样式放置在 HTML 文档的 <code>&lt;head&gt;</code> 部分的 <code>&lt;style&gt;</code> 标签内。这些样式将应用于整个文档，但仍具有较高的优先级。</li>
</ol>
<p>示例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">h2</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">color</span>: red;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">font-size</span>: <span class="number">16px</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>这是一段内部样式表控制文本。<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol>
<li><code>外部样式表（External Stylesheet）</code>：外部样式表是将 CSS 样式定义在一个单独的 .css 文件中，并使用 <code>&lt;link&gt;</code> 元素将其链接到 HTML 文档中。这是一种最常用的方式，允许你在多个页面上重用相同的样式。外部样式表具有较低的优先级。</li>
</ol>
<p>示例：</p>
<p>在该 HTML 文件目录下创建名为 <code>css</code> 的目录，并创建 <code>style.css</code> 的外部样式表文件，在其中加入以下代码：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: purple;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 HTML 文档中链接外部样式表：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> <span class="attr">href</span>=<span class="string">&quot;./css/style.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>这是一段外部样式表控制文本。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>使用外部样式表的优势在于它可以帮助你更好地维护和管理样式，使样式与内容分离，提高代码的可维护性。根据需要，你可以选择其中一种或多种导入方式，具体取决于项目的要求和结构。</p>
<p>三种导入方式的优先级</p>
<p>不同的导入方式（内联样式、内部样式表、外部样式表）具有不同的优先级，优先级高的会覆盖掉优先级低的样式：<code>内联样式</code> &gt; <code>内部样式表</code> &gt; <code>外部样式表</code>。</p>
<h4 id="选择器（Selectors）"><a href="#选择器（Selectors）" class="headerlink" title="选择器（Selectors）"></a>选择器（Selectors）</h4><p>选择器用于选择要应用样式的 HTML 元素。可以选择所有的元素、特定元素、特定类或 ID 的元素，甚至更多。选择器位于规则的开头。</p>
<ul>
<li>元素选择器：选择特定类型的 HTML 元素（例如，<code>p</code> 选择所有段落）。</li>
<li>类选择器：选择具有特定类的元素（例如，<code>.highlight</code> 选择具有 highlight 类的元素）。</li>
<li>ID 选择器：选择具有特定 ID 的元素（例如，<code>#header</code> 选择 ID 为 header 的元素）。</li>
<li>通用选择器 *：选择页面上所有的元素。</li>
<li>子元素选择器：选择直接位于父元素内部的子元素。语法：<code>父元素 &gt; 子元素</code>，例如，<code>ul &gt; li</code> 选择了 <code>&lt;ul&gt;</code> 元素内直接包含的 <code>&lt;li&gt;</code> 元素。</li>
<li>后代选择器（包含选择器）：选择元素的后代元素。语法：<code>元素名 元素名</code>，例如，<code>ul li</code> 选择了所有在 <code>&lt;ul&gt;</code> 元素内部的 <code>&lt;li&gt;</code> 元素。</li>
<li>相邻兄弟选择器：选择紧邻在另一个元素后面的兄弟元素。<code>元素名 + 元素名</code>，例如，<code>h2 + p</code> 选择了与 <code>&lt;h2&gt;</code> 相邻的 <code>&lt;p&gt;</code> 元素。</li>
<li>伪类选择器：选择 HTML 文档中的元素的特定状态或位置，而不仅仅是元素自身的属性。伪类选择器以冒号（:）开头，通常用于为用户交互、文档结构或其他条件下的元素应用样式。这些条件可以包括鼠标悬停（<code>:hover</code> ）、链接状态（<code>:active</code>）、第一个子元素（<code>:first-child</code>）等。</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>CSS 选择器<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="comment">/* 元素选择器 */</span></span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">h2</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">color</span>: aqua;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="comment">/* 类选择器 */</span></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.highlight</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: yellow;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="comment">/* ID选择器 */</span></span></span><br><span class="line"><span class="language-css">        <span class="selector-id">#header</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">font-size</span>: <span class="number">35px</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="comment">/* 子元素选择器 */</span></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.box</span> &gt; <span class="selector-class">.element</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">color</span>: yellowgreen;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="comment">/* 后代选择器 */</span></span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">div</span> <span class="selector-class">.element</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">font-size</span>: x-large;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">color</span>: brown;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="comment">/* 相邻兄弟选择器 */</span></span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">h3</span> + <span class="selector-tag">p</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">color</span>: red;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="comment">/* 通用兄弟选择器 */</span></span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">h4</span> ~ <span class="selector-tag">p</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: <span class="number">#1b91ff</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="comment">/* 伪类选择器 */</span></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.hover</span><span class="selector-pseudo">:hover</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: blueviolet;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="comment">/* 通用选择器 */</span></span></span><br><span class="line"><span class="language-css">        * &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">font-family</span>: <span class="string">&#x27;KaiTi&#x27;</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">font-weight</span>: bold;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>不同类型的CSS选择器示例<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>这是一个元素选择器示例<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span> <span class="attr">class</span>=<span class="string">&quot;highlight&quot;</span>&gt;</span>这是一个类选择器示例<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h4</span> <span class="attr">id</span>=<span class="string">&quot;header&quot;</span>&gt;</span>这是一个ID选择器示例<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;element&quot;</span>&gt;</span>这是一个子元素选择器示例<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;element&quot;</span>&gt;</span>这是一个后代选择器示例<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>选中标签之前的 p 标签<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>这是相邻兄弟选择器示例<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>相邻兄弟元素示例<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h4</span>&gt;</span>这是通用兄弟元素选择器示例<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>通用兄弟元素示例<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span> <span class="attr">class</span>=<span class="string">&quot;hover&quot;</span>&gt;</span>这是一个 hover 伪类选择器示例<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>选择器的优先级</p>
<p>CSS 中，样式的优先级顺序为：<code>内联样式 &gt; ID选择器 &gt; 类选择器、属性选择器、伪类选择器 &gt; 元素选择器 &gt; 伪元素选择器 &gt; 通用选择器</code>，且在样式表链接时后链接的规则覆盖先链接的规则，而! important标志可覆盖所有其他规则。</p>
<h4 id="CSS-常用属性"><a href="#CSS-常用属性" class="headerlink" title="CSS 常用属性"></a>CSS 常用属性</h4><p>块、行内、行内块元素’</p>
<p>块元素（block）：</p>
<ul>
<li>块级元素通常会从新行开始，并且占据整行的宽度</li>
<li>可以包含其他块级元素和行内元素</li>
</ul>
<p>行内元素（inline）：</p>
<ul>
<li>行内元素通常只在一行内呈现，不会独占一行</li>
<li>他们只占据其内容所需的宽度，而不是整行的宽度</li>
<li>行内元素不能包含块级元素，但是可以包含其他行内元素</li>
</ul>
<p>行内块元素（inline-block）：</p>
<ul>
<li>水平方向上排列，但可以设置宽度、高度、内外边距等块级元素的属性</li>
<li>行内块元素可以包含其他行内元素或者块级元素</li>
</ul>
<table>
<thead>
<tr>
<th align="center">属性名</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>font-family</code></td>
<td align="center">用于设置文本的字体。示例：<code>font-family: Arial, sans-serif;</code></td>
</tr>
<tr>
<td align="center"><code>font-size</code></td>
<td align="center">用于设置文本的字号大小。示例：<code>font-size: 16px;</code></td>
</tr>
<tr>
<td align="center"><code>color</code></td>
<td align="center">用于设置文本的颜色。示例：<code>color: #333;</code></td>
</tr>
<tr>
<td align="center"><code>font-weight</code></td>
<td align="center">用于设置文本的粗细，可以是 normal、bold 等。示例：<code>font-weight: bold;</code></td>
</tr>
<tr>
<td align="center"><code>line-height</code></td>
<td align="center">用于设置文本的行高。示例：<code>line-height: 1.5;</code></td>
</tr>
<tr>
<td align="center"><code>text-align</code></td>
<td align="center">用于设置文本的对齐方式，可以是 left、right、center 等。示例：<code>text-align: center;</code></td>
</tr>
<tr>
<td align="center"><code>text-decoration</code></td>
<td align="center">用于添加文本装饰效果，如下划线、删除线。示例：<code>text-decoration: underline;</code></td>
</tr>
<tr>
<td align="center"><code>background-color</code></td>
<td align="center">设置或检索对象的背景颜色。</td>
</tr>
<tr>
<td align="center"><code>height</code></td>
<td align="center">设置元素的高度</td>
</tr>
<tr>
<td align="center"><code>width</code></td>
<td align="center">设置元素的宽度</td>
</tr>
</tbody></table>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE <span class="selector-tag">html</span>&gt;</span><br><span class="line">&lt;<span class="selector-tag">html</span> lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-<span class="number">8</span>&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; <span class="attribute">content</span>=&quot;<span class="attribute">width</span>=device-<span class="attribute">width</span>, initial-<span class="attribute">scale</span>=<span class="number">1.0</span>&quot;&gt;</span><br><span class="line">    &lt;title&gt;CSS块、行内、行内块元素转换&lt;/title&gt;</span><br><span class="line"></span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        <span class="selector-class">.span1</span>&#123;</span><br><span class="line">            <span class="attribute">background-color</span>: red;</span><br><span class="line">            <span class="attribute">display</span>: block;</span><br><span class="line">            <span class="attribute">height</span>: <span class="number">250px</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;<span class="selector-tag">body</span>&gt;</span><br><span class="line">    &lt;!-- <span class="selector-tag">div</span> 块级元素 可以修改 宽高 --&gt;</span><br><span class="line">    &lt;!-- 通过<span class="attribute">display</span>转换成inline 那么宽高就由内容所决定 --&gt;</span><br><span class="line">    &lt;<span class="selector-tag">div</span> style=&quot;<span class="attribute">display</span>: inline; <span class="attribute">background-color</span>: aqua;<span class="attribute">width</span>: <span class="number">150px</span>;&quot;&gt;block ——&gt; inline &lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">    &lt;br&gt;</span><br><span class="line">    &lt;!-- <span class="selector-tag">span</span> 行内元素 宽和高 由包含的内容有关 不可 通过<span class="attribute">width</span>和<span class="attribute">height</span>修改 --&gt;</span><br><span class="line">    &lt;!-- 通过内部样式表 将 行内元素 转换成 块级元素 便可以进行<span class="attribute">width</span>和<span class="attribute">height</span> 修改--&gt;</span><br><span class="line">    &lt;<span class="selector-tag">span</span> class=&quot;span1&quot;&gt; inline -&gt; block &lt;/<span class="selector-tag">span</span>&gt;</span><br><span class="line">    &lt;!-- 行内块元素 可以 在水平 进行排列 并且可以 进行<span class="attribute">width</span>和<span class="attribute">height</span>修改--&gt;</span><br><span class="line">    &lt;dir style=&quot;<span class="attribute">display</span>: inline-block;<span class="attribute">background-color</span>: aquamarine;&quot;&gt; 行内块元素<span class="number">1</span>&lt;/dir&gt;</span><br><span class="line">    &lt;dir style=&quot;<span class="attribute">display</span>: inline-block;<span class="attribute">background-color</span>: aquamarine;&quot;&gt; 行内块元素<span class="number">2</span>&lt;/dir&gt;</span><br><span class="line">    &lt;dir style=&quot;<span class="attribute">display</span>: inline-block;<span class="attribute">background-color</span>: aquamarine;&quot;&gt; 行内块元素<span class="number">3</span>&lt;/dir&gt;</span><br><span class="line">    &lt;dir style=&quot;<span class="attribute">display</span>: inline-block;<span class="attribute">background-color</span>: aquamarine;&quot;&gt; 行内块元素<span class="number">5</span>&lt;/dir&gt;</span><br><span class="line">&lt;/<span class="selector-tag">body</span>&gt;</span><br><span class="line">&lt;/<span class="selector-tag">html</span>&gt;</span><br></pre></td></tr></table></figure>

<p><img src="Users\SZA\AppData\Roaming\Typora\typora-user-images\image-20241021170603551.png" alt="image-20241021170603551"></p>
<h4 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h4><p>盒子模型是 CSS 中一种用于布局的基本概念，它描述了文档中的每个元素都被看作是一个矩形的盒子，这个盒子包含了内容、内边距、边框和外边距。</p>
<p><img src="Users\SZA\AppData\Roaming\Typora\typora-user-images\image-20241021171813437.png" alt="image-20241021171813437"></p>
<p>其中，从内到外分别是：</p>
<table>
<thead>
<tr>
<th align="center">属性名</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>内容（Content）</code></td>
<td align="center">盒子包含的实际内容，比如文本、图片等。</td>
</tr>
<tr>
<td align="center"><code>内边距（Padding）</code></td>
<td align="center">围绕在内容的内部，是内容与边框之间的空间。可以使用 <code>padding</code> 属性来设置。</td>
</tr>
<tr>
<td align="center"><code>边框（Border）</code></td>
<td align="center">围绕在内边距的外部，是盒子的边界。可以使用 <code>border</code> 属性来设置。</td>
</tr>
<tr>
<td align="center"><code>外边距（Margin）</code></td>
<td align="center">围绕在边框的外部，是盒子与其他元素之间的空间。可以使用 <code>margin</code> 属性来设置。</td>
</tr>
</tbody></table>
<hr>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>CSS盒子模型<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.demo</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: aqua;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">display</span>: inline-block;</span></span><br><span class="line"><span class="language-css">            <span class="comment">/** 这里的border是复合属性 分别设置了 **/</span></span></span><br><span class="line"><span class="language-css">            <span class="attribute">border</span>:  black <span class="number">5px</span> solid; </span></span><br><span class="line"><span class="language-css">            </span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.border-demo</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">500px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: aqua;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">border-style</span>: solid dashed dotted double;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">border-width</span>: <span class="number">5px</span> <span class="number">10px</span> <span class="number">15px</span> <span class="number">20px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">border-color</span>: palegreen purple red pink;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">padding-left</span>: <span class="number">20%</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">margin</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;demo&quot;</span>&gt;</span>JavaKeYanMaster<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;border-demo&quot;</span>&gt;</span>PythonKaiFaMaster<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="Users\SZA\AppData\Roaming\Typora\typora-user-images\image-20241021173441515.png" alt="image-20241021173441515"></p>
<h4 id="浮动"><a href="#浮动" class="headerlink" title="浮动"></a>浮动</h4><p>在学习浮动之前，我们需要先了解传统的网页布局方式，网页布局的本质其实就是通过块元素来放置盒子，把盒子放在相应的位置。</p>
<p>传统的网页布局方式有 <code>标准流（普通流、文档流）</code>、<code>浮动</code> 和 <code>定位</code>。这三种传统布局方式都是用来摆放盒子的，盒子摆放到合适位置，布局自然完成了。多个块级元素纵向排列用 <code>标准流</code>，多个块级元素横向排列用 <code>浮动</code>。</p>
<p><code>标准流</code> 是最基本的布局方式，就是由块级元素和行内元素按照默认规定的方式来排列，块级就是占一行，行内元素一行放好多个元素。但是标准流只能按照标签规定好的默认方式进行排列布局，面对特殊的场景，此时就需要 <code>浮动</code> ，因为浮动可以改变元素的默认排列方式，这使得网页布局更加灵活多变。浮动最典型的应用就是可以让多个块级元素一行内排列显示。</p>
<p>而 <code>浮动</code> 属性用于创建浮动框，将其移动到一边，直到左边缘或右边缘触及包含块或另一个浮动框的边缘，这样即可使得元素进行浮动。</p>
<p>学习浮动要先了解浮动的三大特性：</p>
<ol>
<li><code>脱标</code>：顾名思义就是脱离标准流。当元素设置了浮动后，该元素将会脱离标准流（普通流）的控制，移动到指定位置，浮动的盒子不再保留原来所占有的位置，就像飘浮在空中一样，脱离了原来的地面。</li>
<li><code>一行显示，顶部对齐</code>：如果多个盒子都设置了浮动，则它们会按照属性值 一行内显示并且顶端对齐排列。</li>
<li><code>具备行内块元素特性</code>：不管原先是什么模式的元素，添加浮动之后具有 行内块元素 相似的特性。</li>
</ol>
<p>注意</p>
<p>浮动的元素是互相贴靠在一起的（不会有缝隙），如果父级宽度装不下这些浮动的盒子，多出的盒子会另起一行对齐。</p>
<p>而如果使用元素模式转换，让块级元素转换成行内块元素，彼此之间是有空隙的。</p>
<p>用到的属性就是 <code>float: 属性值</code>，属性值可以是：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>浮动演示<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.left</span>, <span class="selector-class">.right</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="comment">/* 添加浮动，元素统一向左浮动，向右同理 float:right*/</span></span></span><br><span class="line"><span class="language-css">            <span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: blue;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="comment">/* 可以利用层叠性将右盒子向右浮动，覆盖掉上面统一声明的向左浮动 */</span></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.right</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">float</span>: right;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: pink;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span></span><br><span class="line">    左盒子</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>&gt;</span></span><br><span class="line">    右盒子</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>了解了 <code>浮动</code> 之后，我们还需要学习如何 <code>清除浮动</code></p>
<p>为什么要清除浮动？</p>
<p>由于父级盒子很多情况下，不方便给高度，但是子盒子浮动又不占有位置 ，最后父级盒子高度为 0 时，就会影响下面的标准流盒子，从而对整个网页元素的排版产生不良影响。</p>
<p>清除浮动是为了解决浮动元素可能引起的布局问题，特别是在包含浮动元素的容器的高度无法自动适应内部浮动元素的情况下。常见的清除浮动的方法包括以下几种：</p>
<ol>
<li><code>空的块级元素 + clear 属性</code>： 这是最经典的清除浮动方法之一，通过在浮动元素后添加一个空的块级元素，并设置其 clear 属性，使其不允许浮动元素在其左侧或右侧浮动。</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.clearfix</span><span class="selector-pseudo">::after</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">content</span>: <span class="string">&quot;&quot;</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">display</span>: table;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">clear</span>: both;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;clearfix&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 浮动元素放在这里 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol>
<li>伪元素清除浮动： 类似于上述方法，但使用伪元素来创建清除浮动的元素，而不需要在 HTML 中添加额外的空元素。</li>
</ol>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="attribute">display</span>: table;</span><br><span class="line">    <span class="attribute">clear</span>: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>使用 overflow 属性： 将包含浮动元素的容器设置为 <code>overflow: hidden;</code>，可以触发 BFC（块级格式上下文），从而清除浮动。</li>
</ol>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span> &#123;</span><br><span class="line">    <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h4><p>CSS 定位是一种用于控制元素在网页上的位置的布局技术。通过定位，可以将元素放置在页面的特定位置，而不受文档流的约束。CSS 提供了几种定位属性，包括相对定位、绝对定位和固定定位。</p>
<ol>
<li>相对定位（Relative Positioning）： 相对定位是相对于元素在正常文档流中的位置进行定位的。通过使用 <code>position: relative;</code> 属性，可以在不脱离文档流的情况下调整元素的位置。</li>
</ol>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.relative-box</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>绝对定位（Absolute Positioning）： 绝对定位是相对于元素的最近的已定位（非 static）祖先元素进行定位的。如果没有已定位的祖先元素，那么它将相对于初始包含块进行定位。通过使用 <code>position: absolute;</code> 属性，可以自由地调整元素的位置。</li>
</ol>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.absolute-box</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>固定定位（Fixed Positioning）： 固定定位是相对于浏览器窗口进行定位的，即使页面滚动，元素也会保持在窗口的相同位置。通过使用 <code>position: fixed;</code> 属性，可以创建固定定位的元素。</li>
</ol>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.fixed-box</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: fixed;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>选择使用哪种定位方式取决于具体的设计需求。通常，相对定位用于微调元素的位置，而绝对、固定定位用于创建更复杂的布局。</p>
<h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><p>JavaScript引入方式：</p>
<ul>
<li><p>内部脚本：将JS代码定义在HTML页面当中</p>
<ul>
<li>JavaScript代码必须位于<script></script>标签当中</li>
<li>在HTML文档中，可以在任意地方，放置任意数量的<script></li>
<li>一般会把脚本至于<body>元素的底部，可改善显示速度</li>
</ul>
</li>
<li><p>外部脚本：将JS代码定义在外部JS文件中，然后引入到HTML页面中</p>
<ul>
<li><p>外部JS文件，只包含JS代码，不包含<script>标签</p>
</li>
<li><script>标签不能自闭和    
  例如  ：

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;js/demo.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 不能写成--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">scr</span>=<span class="string">&quot;js/demo.js&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="JS基础语法"><a href="#JS基础语法" class="headerlink" title="JS基础语法"></a>JS基础语法</h2><ul>
<li><p>区分大小写：和Java一样，变量名、函数名以及其他一切东西都是区分、</p>
</li>
<li><p>输出语句的三种形式：</p>
<ul>
<li>使用window.alert()写入警告框</li>
<li>使用document.write()写入HTML输出</li>
<li>使用console.log()写入浏览器控制台</li>
</ul>
</li>
<li><p>变量</p>
<ul>
<li><p>JavaScript中用var关键字(variable)来声明变量</p>
</li>
<li><p>JavaScript是一门弱类型语言，<font color=red>变量可以存放不同类型的值</font></p>
<ul>
<li><pre><code class="javascript">var a = 20;
a = &quot;zhangsan&quot;;
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  - var 特点：</span><br><span class="line"></span><br><span class="line">    - var的作用域比较大，全局变量</span><br><span class="line">    - 可以重复定义</span><br><span class="line"></span><br><span class="line">  - ECMAScript6新增了 let关键字定义变量，它的用法类似于var，但是所声明的变量，只在let关键字所在的代码块内有效，且不允许重复声明</span><br><span class="line"></span><br><span class="line">  - ECMAScript6新增了const关键字，用来声明一个只读的常量，一旦声明，常量的值就不能改变</span><br><span class="line"></span><br><span class="line">- JavaScript中分为原始类型和引用类型</span><br><span class="line"></span><br><span class="line">  - 原始类型：</span><br><span class="line"></span><br><span class="line">    - number：数字（整数，小数，NaN not a number）</span><br><span class="line"></span><br><span class="line">    - string：字符串，单双引均可</span><br><span class="line"></span><br><span class="line">    - boolean：布尔，true，false均可</span><br><span class="line"></span><br><span class="line">    - null：对象为空</span><br><span class="line"></span><br><span class="line">      - typeof(null)返回为object，这实际上时JavaScript最初实现的一个错误，然后呗ECMAScript沿用了，现在null依然是对象的占位符</span><br><span class="line"></span><br><span class="line">    - undefined：当声明的对象未初始化时，该变量的默认值时undefined</span><br><span class="line"></span><br><span class="line">    - 使用typeof运算符可以获取数据类型</span><br><span class="line"></span><br><span class="line">    - 运算符与java基本一致：</span><br><span class="line"></span><br><span class="line">      ![image-20241102150714034](./前端入门/image-20241102150714034.png)</span><br><span class="line"></span><br><span class="line">    - == 与 ===区别</span><br><span class="line"></span><br><span class="line">      == 会进行类型转换，===不会进行类型转换</span><br><span class="line"></span><br><span class="line">      ```javascript</span><br><span class="line">      var a = 10;</span><br><span class="line">      alert(a == &quot;10&quot;);//true</span><br><span class="line">      alert(a === &quot;10&quot;);//false</span><br><span class="line">      alert(a === 10);//true</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
<li><p>类型转换</p>
<ul>
<li><p>字符串类型转为数字：</p>
<p>将字符串字面值转为数字，如果字面值不是数字，则转为NaN</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">alert</span>(<span class="built_in">parseInt</span>(<span class="string">&quot;123&quot;</span>)); <span class="comment">// 123</span></span><br><span class="line"><span class="comment">// 把不是数字的前的仍会转为数字</span></span><br><span class="line"><span class="title function_">alert</span>(<span class="built_in">parseInt</span>(<span class="string">&quot;123a&quot;</span>)); <span class="comment">// 123</span></span><br><span class="line"><span class="title function_">alert</span>(<span class="built_in">parseInt</span>(<span class="string">&quot;98snj&quot;</span>)); <span class="comment">// 98</span></span><br><span class="line"><span class="title function_">alert</span>(<span class="built_in">parseInt</span>(<span class="string">&quot;a123&quot;</span>)); <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>


</li>
<li><p>其他类型转为boolean</p>
<p>number： 0 和NaN转为false，其他转为true</p>
<p>string 空字符串""为false，其他转为true</p>
<p>Null和undefined均转为false</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>JS函数：</p>
<ul>
<li><p>定义（方法一）：JS函数通过function关键字进行定义，语法为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">functionName</span>(<span class="params">参数<span class="number">1</span>, 参数<span class="number">2</span></span>)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意形式参数不需要类型，因为JS是弱语言类型</p>
<p>返回值也不需要定义类型，可以在函数内部直接使用return返回即可</p>
</li>
<li><p>定义（方法二）：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> add = <span class="keyword">function</span>(<span class="params">a,b</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">alert</span>(<span class="title function_">add</span>(<span class="number">10</span>,<span class="number">20</span>));</span><br></pre></td></tr></table></figure>
</li>
<li><p>调用，functionName(实际参数列表)</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a , b</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> result = <span class="title function_">add</span>(<span class="number">10</span>,<span class="number">20</span>);</span><br><span class="line"><span class="title function_">alert</span>(result);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>JS对象</p>
<ul>
<li><p>Array：定义数组</p>
<ul>
<li><p>定义</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> array1 = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>); <span class="comment">// 方式1</span></span><br><span class="line"><span class="keyword">var</span> array2 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]; <span class="comment">// 方式2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问</span></span><br><span class="line">array1[<span class="number">1</span>];</span><br></pre></td></tr></table></figure>
</li>
<li><p>特点：长度可变，类型可变</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> array1 = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>); <span class="comment">// 方式1</span></span><br><span class="line"><span class="keyword">var</span> array2 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]; <span class="comment">// 方式2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问</span></span><br><span class="line">array1[<span class="number">10</span>] = <span class="number">100</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(array1[<span class="number">10</span>]); <span class="comment">// 100</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(array1[<span class="number">9</span>]);<span class="comment">//undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(array1[<span class="number">8</span>]);<span class="comment">//undefined</span></span><br><span class="line">      </span><br><span class="line">array1[<span class="number">9</span>] = <span class="string">&quot;A&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(array1); </span><br><span class="line"><span class="comment">//         [</span></span><br><span class="line"><span class="comment">//     1,</span></span><br><span class="line"><span class="comment">//     2,</span></span><br><span class="line"><span class="comment">//     3,</span></span><br><span class="line"><span class="comment">//     4,</span></span><br><span class="line"><span class="comment">//     null,</span></span><br><span class="line"><span class="comment">//     null,</span></span><br><span class="line"><span class="comment">//     null,</span></span><br><span class="line"><span class="comment">//     null,</span></span><br><span class="line"><span class="comment">//     null,</span></span><br><span class="line"><span class="comment">//     &quot;A&quot;,</span></span><br><span class="line"><span class="comment">//     100</span></span><br><span class="line"><span class="comment">// ]</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong><font color=red>JS中的数组相当于Java中的集合，数组的长度是可变的，而JS是弱类型，所以可以存储任意类型的数据</font></strong></p>
<ul>
<li><p>常见的属性和方法</p>
<ul>
<li><p>属性:</p>
<p>length：设置或者返回数组中元素的数量</p>
</li>
<li><p>方法：</p>
<p>forEach()：遍历数组中的每个有值的元素，并调用一次传入的函数</p>
<p>push()：将新元素添加到数组的末尾，并返回新的长度</p>
<p>splice()：从数组中删除元素</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>String</p>
<p>  String字符串对象创建方式有两种</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方式1</span></span><br><span class="line"><span class="type">var</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello string&quot;</span>);</span><br><span class="line"><span class="comment">// 方式2</span></span><br><span class="line"><span class="type">var</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;hello string&quot;</span>;</span><br><span class="line"><span class="type">var</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&#x27;hello string&#x27;</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>属性：length字符串的长度</p>
</li>
<li><p>方法</p>
<p>charAt()：返回在指定位置的字符</p>
<p>indexOf：检索字符串</p>
<p>trim()：去除字符串两边的空格</p>
<p>substring()：提取字符串中两个置顶的索引号之间的字符</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="type">var</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello string  &quot;</span>);</span><br><span class="line">    <span class="type">var</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;hello string&quot;</span>;</span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line">    <span class="type">var</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&#x27;hello string&#x27;</span>;</span><br><span class="line">    </span><br><span class="line">    console.log(str.charAt(<span class="number">1</span>));<span class="comment">//e</span></span><br><span class="line">    console.log(str.indexOf(<span class="string">&#x27;l&#x27;</span>));<span class="comment">//2</span></span><br><span class="line">    console.log(str.trim().length);<span class="comment">//12</span></span><br><span class="line"><span class="comment">// 含头不含尾</span></span><br><span class="line">    console.log(str.substring(<span class="number">0</span>,<span class="number">2</span>));<span class="comment">//he</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>JSON</p>
<ul>
<li>JS自定义对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义格式</span></span><br><span class="line"><span class="type">var</span> <span class="variable">user</span> <span class="operator">=</span>  &#123;</span><br><span class="line">    name:<span class="string">&quot;tom&quot;</span>,</span><br><span class="line">    age:<span class="number">20</span>,</span><br><span class="line">    gender:<span class="string">&quot;male&quot;</span>,</span><br><span class="line">    <span class="comment">// eat:function()&#123;</span></span><br><span class="line">    <span class="comment">//     console.log(&quot;用饭&quot;);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// 简化</span></span><br><span class="line">    eat()&#123;</span><br><span class="line">        console.log(<span class="string">&quot;用饭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//调用格式</span></span><br><span class="line">console.log(user.age);</span><br><span class="line">    </span><br><span class="line">user.eat();</span><br></pre></td></tr></table></figure>

<ul>
<li><p>JSON：JavaScript Object Notation，JS对象标记法 ，JSON是通过<font color=red>JavaScript对象标记法</font>书写的文本，由于其语法简单，层次结构鲜明，现多用于作为数据载体，在网络中进行数据传输。  </p>
<p>JSON也是一对对键值对构成</p>
<p>value的数据类型为：</p>
<ol>
<li>数字（整数/浮点数）</li>
<li>字符串（在双引号当中）</li>
<li>逻辑值（true/false）</li>
<li>数组（在方括号当中）</li>
<li>对象（在花括号当中）</li>
<li>null</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义JSON字符串</span></span><br><span class="line"><span class="type">var</span> <span class="variable">userStr</span> <span class="operator">=</span> <span class="string">&#x27;&#123;&quot;name&quot;:&quot;jerry&quot;,&quot;age&quot;:18,&quot;addr&quot;:[&quot;beijing&quot;,&quot;shanghai&quot;,&quot;xian&quot;]&#125;&#x27;</span>; </span><br><span class="line">      </span><br><span class="line"><span class="comment">// JSON字符串转为JS对象</span></span><br><span class="line"><span class="type">var</span> <span class="variable">jsObject</span> <span class="operator">=</span> JSON.parse(userStr);</span><br><span class="line">      </span><br><span class="line"><span class="comment">// JSON对象转为JSON字符串</span></span><br><span class="line"><span class="type">var</span> <span class="variable">jsonStr</span> <span class="operator">=</span> JSON.stringify(jsObject);</span><br><span class="line">      </span><br><span class="line">console.log(jsObject.name);</span><br><span class="line">console.log(jsonStr);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>BOM</p>
<p>Browser Object Model 浏览器对象模型，允许JavaScript与浏览器对话，JavaScript将浏览器的各个组成部分封装成对象</p>
<p>浏览器组成：</p>
<ul>
<li><p>Window:浏览器窗口对象 </p>
<ul>
<li><p>直接使用window，其中window可以省略</p>
</li>
<li><pre><code class="javascript">window.alert(&quot;  &quot;);
alert(&quot;&quot;);
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  </span><br><span class="line">- 属性：</span><br><span class="line">  </span><br><span class="line">  history：对History对象的只读引用</span><br><span class="line">  </span><br><span class="line">  location：用于窗口或框架的Location对象</span><br><span class="line">  </span><br><span class="line">  navigator：对Navigator对象的只读引用</span><br><span class="line">  </span><br><span class="line">- 方法</span><br><span class="line">  </span><br><span class="line">  alert()：显示带有一段消息和一个确认按钮的警告框</span><br><span class="line">  </span><br><span class="line">  confirm()：显示带有一段消息以及确认按钮和取消按钮的对话框</span><br><span class="line">  </span><br><span class="line">  setInterval()：按照指定的周期（以毫秒计）来调用函数或者计算表达式 </span><br><span class="line">  </span><br><span class="line">  ```java</span><br><span class="line">          // 定时器 周期性地执行某一个函数 毫秒</span><br><span class="line">          setInterval(function()&#123;</span><br><span class="line">              console.log(&quot;test&quot;);</span><br><span class="line">          &#125;,2000);</span><br></pre></td></tr></table></figure>

setTimeout()：在指定的毫秒数后调用函数或者计算表达式
</code></pre>
</li>
</ul>
</li>
<li><p>Navigator:浏览器对象</p>
</li>
<li><p>Screen:屏幕对象</p>
</li>
<li><p>History:历史记录对象</p>
</li>
<li><p>Location:地址栏对象</p>
<p>获取，可以直接使用window.location，其中window.可以省略</p>
<p>属性：</p>
<p>href：设置或者返回完整URL</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(location.<span class="property">href</span>);</span><br><span class="line">      </span><br><span class="line">location.<span class="property">href</span> = <span class="string">&quot;https://www.baidu.com&quot;</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>DOM</p>
<p>Document Object Model，文档对象模型</p>
<p>将标记语言（HTML）的各个组成部分封装成对应的对象</p>
<ul>
<li>Document：整个文档对象</li>
<li>Element：元素对象 // 每一个元素标签 </li>
<li>Attribute：属性对象 // 标签当中的属性</li>
<li>Text：文本对象</li>
<li>Comment：注释对象</li>
</ul>
<img src="/%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A8/image-20241104143646857.png" class="" title="image-20241104143646857">

<p>HTML中的Element对象可以通过Document对象获取，而Document对象是通过window对象获取</p>
<p>Document对象中提供了以下获取Element元素对象的函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!<span class="variable constant_">DOCTYPE</span> html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;img id=&quot;img1&quot; src=&quot;../笔记/./前端入门/image-20241030195107388.png&quot;&gt; &lt;br&gt;</span><br><span class="line"></span><br><span class="line">    &lt;div class=&quot;cls1&quot;&gt;xxxx1&lt;/div&gt; &lt;br&gt;</span><br><span class="line">    &lt;div class=&quot;cls1&quot;&gt;xxxx2&lt;/div&gt; &lt;br&gt;</span><br><span class="line"></span><br><span class="line">    &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot;&gt; 电影</span><br><span class="line">    &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot;&gt; 旅游</span><br><span class="line">    &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot;&gt; 游戏</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        // 获取Element元素</span><br><span class="line"></span><br><span class="line">        // 1.1 获取元素，根据ID获取</span><br><span class="line">        var img = document.getElementById(&#x27;img1&#x27;);</span><br><span class="line">        console.log(img);</span><br><span class="line"></span><br><span class="line">        // 1.2 根据标签获取</span><br><span class="line">        var divS = document.getElementsByTagName(&#x27;div&#x27;);</span><br><span class="line">        for (let i = 0; i&lt; divS.length;i++)&#123;</span><br><span class="line">            console.log(divS[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 1.3 根据name属性获取</span><br><span class="line">        var checkboxS = document.getElementsByName(&#x27;hobby&#x27;);</span><br><span class="line">        for (let i = 0; i &lt; checkboxS.length ; i++)&#123;</span><br><span class="line">            console.log(checkboxS[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 1.4 根据class属性获取</span><br><span class="line"></span><br><span class="line">        var clsS = document.getElementsByClassName(&quot;cls1&quot;);</span><br><span class="line">        for (let i = 0; i &lt; clsS.length ; i++)&#123;</span><br><span class="line">            console.log(clsS[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p><font color=red> HTML DOM html文档的标准模型为每个标签都封装成了一个单独的html对象</font></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> divS = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line"><span class="comment">// innerHTML设置或者返回元素的对象</span></span><br><span class="line">divS[<span class="number">0</span>].<span class="property">innerHTML</span> = <span class="string">&quot;learning note bro&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>练习：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.2 根据标签获取</span></span><br><span class="line"><span class="keyword">var</span> divS = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line"><span class="comment">// innerHTML设置或者返回元素的对象</span></span><br><span class="line">divS[<span class="number">0</span>].<span class="property">innerHTML</span> = <span class="string">&quot;learning note bro&quot;</span>;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 为所有div标签的内容后面加入 author:sza(红色字体)</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; divS.<span class="property">length</span> ; i++)&#123;</span><br><span class="line">    <span class="comment">// innerHTML是可以识别html标签的  </span></span><br><span class="line">    divS[i].<span class="property">innerHTML</span> += <span class="string">&quot;&lt;font color=red&gt;author:sza &lt; /font&gt;&quot;</span>;  </span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 1.3 根据name属性获取</span></span><br><span class="line"><span class="keyword">var</span> checkboxS = <span class="variable language_">document</span>.<span class="title function_">getElementsByName</span>(<span class="string">&#x27;hobby&#x27;</span>);</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 使所有的复选框呈现选中状态</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; checkboxS.<span class="property">length</span> ; i++)&#123;</span><br><span class="line">    checkboxS[i].<span class="property">checked</span> = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="JS事件监听"><a href="#JS事件监听" class="headerlink" title="JS事件监听"></a>JS事件监听</h2><p> 事件：HTML事件是发生在HTML元素上的事情，例如</p>
<ol>
<li>按钮被点击</li>
<li>鼠标移动到元素上</li>
</ol>
<img src="/%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A8/image-20241104152835114.png" class="" title="image-20241104152835114">

<p>事件监听：JavaScript可以在事件被侦测到时执行代码</p>
<p>事件绑定：</p>
<p>方式一：通过HTML标签中的事件属性进行绑定</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!-- 通过html标签中的事件属性进行绑定 --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;on()&quot;</span> <span class="attr">value</span>=<span class="string">&quot;按钮1&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">function</span> <span class="title function_">on</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="title function_">alert</span>(<span class="string">&quot;按钮1被点击了&quot;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>方式二：通过DOM元素绑定</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!-- 通过<span class="variable constant_">DOM</span>属性绑定 --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">id</span>=<span class="string">&quot;button2&quot;</span> <span class="attr">value</span>=<span class="string">&quot;按钮2&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">var</span> button2 = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;button2&quot;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    button2.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="title function_">alert</span>(<span class="string">&quot;按钮2被点击&quot;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<h2 id="同步异步"><a href="#同步异步" class="headerlink" title="同步异步"></a>同步异步</h2><p>同步就是后一个任务等待前一个任务执行完毕后，再执行，执行顺序和任务的排列顺序一致</p>
<p>异步是非阻塞的，异步逻辑与主逻辑相互独立，主逻辑不需要等待异步逻辑完成，而是可以立刻执行下去</p>
<img src="/%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A8/image-20241109144852182.png" class="" title="image-20241109144852182">

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;a&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;b&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;c&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;我饭卡拿到了&quot;</span>) &#125;, <span class="number">2000</span>)<span class="comment">// 异步操作</span></span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;d&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;e&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<img src="/%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A8/image-20241109150004787.png" class="" title="image-20241109150004787">

<p>异步操作并不会阻塞主逻辑的运行，<font color=yellow>setTimeout()</font>会让出位置，让后面的逻辑先执行</p>
<h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><p>异步编程的一种解决方案，比传统的解决方案----回调函数和事件----更合理且更强大</p>
<blockquote>
<p>回调函数："I will call back later!" 回调 (callback) 是作为参数传递给另一个函数的函数，这种技术允许函数调用另一个函数，回调函数可以在另一个函数完成后运行。</p>
<p>回调是作为参数传递给另一个函数的函数。</p>
<p>使用回调，您可以通过回调调用计算器函数（<code>myCalculator</code>），并在计算完成后让计算器函数运行回调</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myDisplayer</span>(<span class="params">some</span>) &#123;</span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;demo&quot;</span>).<span class="property">innerHTML</span> = some;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">myCalculator</span>(<span class="params">num1, num2, myCallback</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> sum = num1 + num2;</span><br><span class="line">  <span class="title function_">myCallback</span>(sum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">myCalculator</span>(<span class="number">5</span>, <span class="number">5</span>, myDisplayer);</span><br></pre></td></tr></table></figure>

<p>promise有三个状态：</p>
<ul>
<li><code>pending</code> [待定] 初始状态</li>
<li><code>fulfilled</code> [实现] 操作成功</li>
<li><code>rejected</code> [拒绝] 操作失败</li>
</ul>
<p>实例化<code>promise</code>需要传入一个函数执行异步代码，该函数需要两个参数<code>reslove</code>和<code>reject</code>，两个参数均为回调函数，用于异步代码执行完后进行回调。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 匿名函数</span></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 编写异步代码逻辑</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">test1</span>(<span class="params">resolve,reject</span>)&#123;</span><br><span class="line">    <span class="comment">// 编写异步代码逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(test1)</span><br></pre></td></tr></table></figure>

<p><code>Promise</code>实例 就标记了我们在new Promise中所设计的异步任务最终的一个<strong>处理结果</strong>，他会通过回调方式（<code>resolve / reject</code>静态方法）返还到p1的这个位置上。 </p>
<p><code>resolve(xxx)</code>方法用于将Promise对象的状态从<code>pending</code>变为<code>fulfilled</code>，操作成功的返回值xxx作为参数传递给<code>then()</code>方法</p>
<p><code>reject(xxx)</code>方法用于将Promise对象的状态从<code>pending</code>变为<code>rejected</code>，并将操作失败的原因xxx作为参数传递给<code>catch()</code>方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1)</span><br></pre></td></tr></table></figure>

<img src="/%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A8/image-20241109161557618.png" class="" title="image-20241109161557618">
<p>在匿名函数中我们没有编写任何的异步代码，也没有对异步代码执行完后的结果选择回调函数，因此<code>PromiseState</code>的一直都是<code>pending</code>。</p>
<p>我们可以手动地调用回调函数<code>resolve()/reject()</code>对<code>PromiseState</code>的值进行修改，并为回调函数添加参数，以便于后续对异步任务处理结果进行进一步的处理。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="title function_">reject</span>(<span class="string">&#x27;异步处理失败&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1)</span><br></pre></td></tr></table></figure>

<img src="/%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A8/image-20241109163106933.png" class="" title="image-20241109163106933">
<p>我们可以发现<code>PromiseState</code>的值为<code>rejected</code>，<code>PromiseResult</code>的值为<code>reject</code>函数传入的参数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// reject(&#x27;异步处理失败&#x27;)</span></span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&#x27;异步处理成功&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1)</span><br></pre></td></tr></table></figure>

<img src="/%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A8/image-20241109163401173.png" class="" title="image-20241109163401173">

<p>对于后续的p1处理，你可以使用<code>then(successCallback, failureCallback)</code>方法同时处理<code>rejected</code>和<code>fulfilled</code>。</p>
<p>第一个参数是状态变为成功后应该执行的回调函数，第二个参数是状态变为失败后应该执行的回调函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="title function_">reject</span>(<span class="string">&#x27;异步处理失败&#x27;</span>)</span><br><span class="line">    <span class="comment">// resolve(&#x27;异步处理成功&#x27;)</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p1.<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> &#123; <span class="comment">// 处理fulfilled</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(result)</span><br><span class="line">&#125;,<span class="function"><span class="params">result</span>=&gt;</span>&#123; <span class="comment">// 处理rejected</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(result)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>也分别用<code>then()</code>和<code>catch()</code>方法分别处理<code>rejected</code>和<code>fulfilled</code>。</p>
<img src="/%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A8/image-20241109165911635.png" class="" title="image-20241109165911635">

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">p1.<span class="title function_">then</span>(<span class="function"><span class="params">successRes</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(successRes)</span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">errorRes</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(errorRes)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>Promise还可以做更多的事情，比如，有若干个异步任务，需要先做任务1，如果成功后再做任务2，任何任务失败则不再继续并执行错误处理函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">job1</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> timeOut = <span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">2</span></span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (timeOut &lt; <span class="number">1</span>) &#123;<span class="comment">// 这里我们假定timeOut &lt; 1 认为是异步处理成功</span></span><br><span class="line">                <span class="title function_">resolve</span>(timeOut + <span class="string">&#x27;success&#x27;</span>)</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123; <span class="comment">// 反之 认为是异步处理失败</span></span><br><span class="line">                <span class="title function_">reject</span>(timeOut + <span class="string">&#x27;fail&#x27;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, timeOut * <span class="number">1000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">job2</span>(<span class="params">successRes</span>)&#123;</span><br><span class="line">    <span class="comment">// 返回的必须是Promise的实例</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> timeOut = <span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">2</span></span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (timeOut &lt; <span class="number">1</span>) &#123;<span class="comment">// 这里我们假定timeOut &lt; 1 认为是异步处理成功</span></span><br><span class="line">                <span class="title function_">resolve</span>(timeOut + <span class="string">&#x27;success&#x27;</span>)</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123; <span class="comment">// 反之 认为是异步处理失败</span></span><br><span class="line">                <span class="title function_">reject</span>(timeOut + <span class="string">&#x27;fail&#x27;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, timeOut * <span class="number">1000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">job3</span>(<span class="params">successRes</span>)&#123;</span><br><span class="line">    <span class="comment">// 返回的必须是Promise的实例</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> timeOut = <span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">2</span></span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (timeOut &lt; <span class="number">1</span>) &#123;<span class="comment">// 这里我们假定timeOut &lt; 1 认为是异步处理成功</span></span><br><span class="line">                <span class="title function_">resolve</span>(timeOut + <span class="string">&#x27;success&#x27;</span>)</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123; <span class="comment">// 反之 认为是异步处理失败</span></span><br><span class="line">                <span class="title function_">reject</span>(timeOut + <span class="string">&#x27;fail&#x27;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, timeOut * <span class="number">1000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">job1</span>().<span class="title function_">then</span>(job2).<span class="title function_">then</span>(job3).<span class="title function_">then</span>(<span class="function"><span class="params">successRes</span>=&gt;</span>&#123;<span class="comment">//处理最后任务3的操作成功</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(successRes)</span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">errorRes</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(errorRes)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>当然你也可以为不通过的异步操作失败设置不同的方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">job1</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> timeOut = <span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">2</span></span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (timeOut &lt; <span class="number">1</span>) &#123;<span class="comment">// 这里我们假定timeOut &lt; 1 认为是异步处理成功</span></span><br><span class="line">                <span class="title function_">resolve</span>(timeOut + <span class="string">&#x27;success&#x27;</span>)</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123; <span class="comment">// 反之 认为是异步处理失败</span></span><br><span class="line">                <span class="title function_">reject</span>(timeOut + <span class="string">&#x27;fail&#x27;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, timeOut * <span class="number">1000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">job2</span>(<span class="params">successRes</span>)&#123;</span><br><span class="line">    <span class="comment">// 返回的必须是Promise的实例</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> timeOut = <span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">2</span></span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (timeOut &lt; <span class="number">1</span>) &#123;<span class="comment">// 这里我们假定timeOut &lt; 1 认为是异步处理成功</span></span><br><span class="line">                <span class="title function_">resolve</span>(timeOut + <span class="string">&#x27;success&#x27;</span>)</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123; <span class="comment">// 反之 认为是异步处理失败</span></span><br><span class="line">                <span class="title function_">reject</span>(timeOut + <span class="string">&#x27;fail&#x27;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, timeOut * <span class="number">1000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">job3</span>(<span class="params">successRes</span>)&#123;</span><br><span class="line">    <span class="comment">// 返回的必须是Promise的实例</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> timeOut = <span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">2</span></span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (timeOut &lt; <span class="number">1</span>) &#123;<span class="comment">// 这里我们假定timeOut &lt; 1 认为是异步处理成功</span></span><br><span class="line">                <span class="title function_">resolve</span>(timeOut + <span class="string">&#x27;success&#x27;</span>)</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123; <span class="comment">// 反之 认为是异步处理失败</span></span><br><span class="line">                <span class="title function_">reject</span>(timeOut + <span class="string">&#x27;fail&#x27;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, timeOut * <span class="number">1000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">handleError1</span>(<span class="params">errorRes</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(errorRes + <span class="string">&#x27;Error1&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">handleError2</span>(<span class="params">errorRes</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(errorRes + <span class="string">&#x27;Error2&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">handleError3</span>(<span class="params">errorRes</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(errorRes + <span class="string">&#x27;Error3&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="title function_">job1</span>().<span class="title function_">then</span>(job2,handleError1).<span class="title function_">then</span>(job3,handleError2).<span class="title function_">then</span>(<span class="function"><span class="params">successRes</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(successRes)<span class="comment">// 处理最后任务3的操作成功</span></span><br><span class="line">&#125;,handleError3)</span><br></pre></td></tr></table></figure>

<h2 id="Async"><a href="#Async" class="headerlink" title="Async"></a>Async</h2><p>步骤1:准备一个返回<code>promise</code>对象的函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">asyncTask</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="comment">// 假装一些核心代码</span></span><br><span class="line">        <span class="keyword">const</span> isSuccess = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">if</span> (isSuccess)&#123;</span><br><span class="line">            <span class="title function_">resolve</span>(<span class="string">&#x27;操作成功&#x27;</span>)</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="title function_">reject</span>(<span class="string">&#x27;操作失败&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>步骤2:为使用<code>await</code>的函数添加<code>async</code></p>
<p><code>async</code>关键字对于函数并没有本质上一些功能的影响，唯一的作用是可以在内部执行<code>await</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为异步函数添加<code>await</code>的好处就是异步函数会像同步代码一样执行：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">    <span class="keyword">const</span> data = <span class="keyword">await</span> <span class="title function_">asyncTask</span>()</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;c&#x27;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;d&#x27;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;e&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">main</span>()</span><br></pre></td></tr></table></figure>

<img src="/%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A8/image-20241109201029827.png" class="" title="image-20241109201029827">

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">    <span class="title function_">asyncTask</span>().<span class="title function_">then</span>(<span class="function"><span class="params">data</span>=&gt;</span><span class="variable language_">console</span>.<span class="title function_">log</span>(data))</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;c&#x27;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;d&#x27;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;e&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">main</span>()</span><br></pre></td></tr></table></figure>

<img src="/%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A8/image-20241109201009862.png" class="" title="image-20241109201009862">

<h2 id="this-关键字"><a href="#this-关键字" class="headerlink" title="this 关键字"></a>this 关键字</h2><p><code>this</code>的值是动态决定</p>
<p><code>this</code>的值取决于它出现的上下文：函数、类或全局</p>
<h3 id="全局上下文中的this"><a href="#全局上下文中的this" class="headerlink" title="全局上下文中的this"></a>全局上下文中的this</h3><p>在全局上下文中，<code>this</code>指向全局对象。在浏览器环境中，这个全局对象是<code>window</code>对象。在Node.js环境中，这个全局对象是<code>global</code>对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!<span class="variable constant_">DOCTYPE</span> html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line"></span><br><span class="line">    console.log(this === window); // 输出：true</span><br><span class="line">   </span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<h3 id="函数上下文中的this"><a href="#函数上下文中的this" class="headerlink" title="函数上下文中的this"></a>函数上下文中的this</h3><p>函数中的<code>this</code>是在被调用的当下才决定的，<code>this</code>就是调用这个方法的object。</p>
<p>对于典型的函数，<code>this</code> 的值<font color=yellow>取决于函数的调用者</font>。换句话说，如果函数调用的形式是 <code>obj.f()</code>，那么 <code>this</code> 就指向 <code>obj</code>。例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getThis</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> obj1 = &#123; <span class="attr">name</span>: <span class="string">&quot;obj1&quot;</span> &#125;;</span><br><span class="line">  <span class="keyword">const</span> obj2 = &#123; <span class="attr">name</span>: <span class="string">&quot;obj2&quot;</span> &#125;;</span><br><span class="line">  </span><br><span class="line">  obj1.<span class="property">getThis</span> = getThis;</span><br><span class="line">  obj2.<span class="property">getThis</span> = getThis;</span><br><span class="line">  </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(obj1.<span class="title function_">getThis</span>()); <span class="comment">// &#123; name: &#x27;obj1&#x27;, getThis: [Function: getThis] &#125;</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(obj2.<span class="title function_">getThis</span>()); <span class="comment">// &#123; name: &#x27;obj2&#x27;, getThis: [Function: getThis] &#125;</span></span><br></pre></td></tr></table></figure>

<p>虽然函数是相同的，但是其调用的对象不同，<code>this</code>的值是不同的。并且<code>this</code>的值总是根据调用函数的对象而决定。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj4 = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;obj4&quot;</span>,</span><br><span class="line">  <span class="title function_">getThis</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj5 = &#123; <span class="attr">name</span>: <span class="string">&quot;obj5&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line">obj5.<span class="property">getThis</span> = obj4.<span class="property">getThis</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj5.<span class="title function_">getThis</span>()); <span class="comment">// &#123; name: &#x27;obj5&#x27;, getThis: [Function: getThis] &#125;</span></span><br></pre></td></tr></table></figure>

<p>如果函数在<font color=yellow>没有被任何东西调用的情况下被调用如下</font>，<code>this</code> 将是 <code>undefined</code>（函数处于严格模式下），但是在非严格模式下将会指向window（浏览器环境下）或者global对象（在Node.js环境下）：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 非严格模式 </span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">display</span>(<span class="params"></span>)&#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>); <span class="comment">// &#x27;this&#x27; 将指向全局变量</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"> <span class="title function_">display</span>(); <span class="comment">// 相当于是全局对象调用</span></span><br></pre></td></tr></table></figure>

<p>非严格模式下指向global对象：</p>
<img src="/%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A8/image-20241110172327237.png" class="" title="image-20241110172327237">

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 严格模式</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">display</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="string">&quot;use strict&quot;</span>; <span class="comment">// 进入严格模式</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>); </span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line"><span class="title function_">display</span>(); </span><br></pre></td></tr></table></figure>

<img src="/%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A8/image-20241110172510351.png" class="" title="image-20241110172510351">

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Saurabh&#x27;</span>,</span><br><span class="line">    <span class="attr">display</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>); <span class="comment">// &#x27;this&#x27; 指向 obj 所以会在obj对象实例中找name</span></span><br><span class="line">     &#125;</span><br><span class="line">   &#125;;</span><br><span class="line">   </span><br><span class="line">obj.<span class="title function_">display</span>(); <span class="comment">// Saurabh </span></span><br></pre></td></tr></table></figure>

<p>当我们以一个 obj 对象来调用这个函数时，<code>display()</code> 方法内部的 <code>this</code> 指向 <code>obj</code>。</p>
<p>但是，当我们将这个函数引用赋值给某个其他变量并使用这个新的函数引用去调用该函数时，我们在 <code>display()</code> 中获得了不同的<code>this</code>值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!<span class="variable constant_">DOCTYPE</span> html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">    var name = &quot;uh oh! global&quot;;</span><br><span class="line">    var obj = &#123;</span><br><span class="line">        name: &#x27;Saurabh&#x27;,</span><br><span class="line">        display: function()&#123;</span><br><span class="line">            console.log(this.name); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">		var outerDisplay = obj.display;</span><br><span class="line">		outerDisplay(); // uh oh! global</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>因为<code>outerDisplay()</code>的调用对象为window（在浏览器环境下），window在上下文中找到了<code>var name = &quot;uh oh! global&quot;;</code>因此输出为uh oh! global。</p>
<h4 id="箭头函数中的this"><a href="#箭头函数中的this" class="headerlink" title="箭头函数中的this"></a>箭头函数中的this</h4><p>箭头函数没有自己的<code>this</code>，与普通函数不同，箭头函数不会创建自己的<code>this</code>上下文，相反会继承外部作用域中的<code>this</code>值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> user = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Shubo&#x27;</span>,</span><br><span class="line">    <span class="title function_">speak</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> <span class="title function_">arrow</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello world, my name is &#x27;</span> + <span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="title function_">arrow</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  user.<span class="title function_">speak</span>();</span><br></pre></td></tr></table></figure>

<p><code>arrow()</code> 箭头函数在<code>speak()</code>方法內被宣告，所以<code>arrow()</code>的环境就是<code>speak()</code>，因此<code>arrow()</code>的<code>this</code>就是<code>speak()</code>的<code>this</code>，也就是user对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">arrow1</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello world, my name is &#x27;</span> + <span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"><span class="title function_">arrow1</span>(); <span class="comment">// (1) 输出 Hello world, my name is undefined</span></span><br><span class="line"><span class="comment">// arrow1()的继承的外部环境是global context</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">const</span> user = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Shubo&#x27;</span>,</span><br><span class="line">    <span class="attr">arrow</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello world, my name is &#x27;</span> + <span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">speak</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="title function_">arrow1</span>(); </span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">  </span><br><span class="line">user.<span class="title function_">arrow</span>(); <span class="comment">// (2) Hello world, my name is undefined</span></span><br><span class="line"></span><br><span class="line">user.<span class="title function_">speak</span>(); <span class="comment">// (3) Hello world, my name is undefined</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>arrow</code>是一个箭头函数，这个箭头函数在user对象内部定义，但是它的this值并不是由user对象来决定的。它会继承<font color=yellow>定义它时所处的外层作用域</font>（也就是全局作用域）的this。</p>
<p><code>arrow1</code>虽然外层作用域是<code>speak</code>，理应该是函数的调用者user作为this，但是箭头函数是继承定义时所处的外层作用域。所以还是global context。</p>
<h3 id="类上下文中的this"><a href="#类上下文中的this" class="headerlink" title="类上下文中的this"></a>类上下文中的this</h3><p>使用 <code>new</code> 关键字调用构造函数时，<code>this</code> 指向新创建的对象实例</p>
<h4 id="1-构造函数中的this"><a href="#1-构造函数中的this" class="headerlink" title="1.构造函数中的this"></a>1.构造函数中的this</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;Alice&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">name</span>); <span class="comment">// 输出 &#x27;Alice&#x27;，这里的this在构造函数中用于初始化实例的属性，它指向person这个实例</span></span><br></pre></td></tr></table></figure>

<h4 id="2-类方法中的this"><a href="#2-类方法中的this" class="headerlink" title="2.类方法中的this"></a>2.类方法中的this</h4><ul>
<li>对于类中的普通方法，<code>this</code>同样指向类实例。假设在<code>Person</code>类中添加一个方法：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">sayHello</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, my name is <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;Bob&#x27;</span>);</span><br><span class="line">person.<span class="title function_">sayHello</span>(); <span class="comment">// 输出 &#x27;Hello, my name is Bob&#x27;，这里的this在sayHello方法中指向person这个实例</span></span><br></pre></td></tr></table></figure>

<ul>
<li>静态方法中的<code>this</code>，静态方法是与类本身相关联，而不是与类的实例相关联的方法。在静态方法中，<code>this</code>指向类本身。例如：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MathUtils</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="title function_">add</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>); <span class="comment">// 指向MathUtils类</span></span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">MathUtils</span>.<span class="title function_">add</span>(<span class="number">2</span>, <span class="number">3</span>)); <span class="comment">// 输出[class MathUtils] 5，在静态方法add中，this指向MathUtils类</span></span><br></pre></td></tr></table></figure>

<h3 id="DOM-事件处理器中的-this"><a href="#DOM-事件处理器中的-this" class="headerlink" title="DOM 事件处理器中的 this"></a>DOM 事件处理器中的 this</h3><h4 id="内联事件处理器中的this"><a href="#内联事件处理器中的this" class="headerlink" title="内联事件处理器中的this"></a>内联事件处理器中的this</h4><ul>
<li><p>当使用内联事件处理器（如<code>onclick=&quot;someFunction()&quot;</code>这种直接在 HTML 标签中的属性）时，<code>this</code>通常指向触发事件的 DOM 元素。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;console.log(this.textContent)&quot;</span>&gt;</span>Click me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在这个例子中，当按钮被点击时，<code>this</code>指向<code>&lt;button&gt;</code>元素本身，所以<code>this.textContent</code>会输出按钮的文本内容，即<code>Click me</code>。</li>
</ul>
</li>
<li><p>**通过 JavaScript 属性添加事件处理器中的<code>this</code>，如果通过 JavaScript 为 DOM 元素添加事件处理器，如<code>element.onclick = function() &#123;... &#125;</code>，在普通函数中<code>this</code>也指向触发事件的 DOM 元素。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> button = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;button&#x27;</span>);</span><br><span class="line">button.<span class="property">textContent</span> = <span class="string">&#x27;Click me&#x27;</span>;</span><br><span class="line">button.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">textContent</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(button);</span><br></pre></td></tr></table></figure>

<p>这里创建了一个按钮，当点击按钮时，<code>this</code>指向按钮元素，会输出按钮的文本内容<code>Click me</code></p>
</li>
</ul>
<h3 id="设置绑定函数执行时的this值"><a href="#设置绑定函数执行时的this值" class="headerlink" title="设置绑定函数执行时的this值"></a>设置绑定函数执行时的this值</h3><h4 id="bind"><a href="#bind" class="headerlink" title="bind()"></a>bind()</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable language_">module</span> = &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="number">42</span>,</span><br><span class="line">  <span class="attr">getX</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">x</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> unboundGetX = <span class="variable language_">module</span>.<span class="property">getX</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">unboundGetX</span>()); <span class="comment">// The function gets invoked at the global scope</span></span><br><span class="line"><span class="comment">// Expected output: undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> boundGetX = unboundGetX.<span class="title function_">bind</span>(<span class="variable language_">module</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">boundGetX</span>());</span><br><span class="line"><span class="comment">// Expected output: 42</span></span><br></pre></td></tr></table></figure>

<p><code>const boundGetX = unboundGetX.bind(module);</code>这一行代码使用<code>bind()</code>方法将<code>unboundGetX</code>函数的<code>this</code>值绑定到<code>module</code>对象。现在，<code>boundGetX</code>是一个新的函数，它的<code>this</code>已经被强制绑定到<code>module</code>。当调用<code>boundGetX()</code>时，函数内部的<code>this</code>就会正确地指向<code>module</code>对象，因此可以访问<code>module.x</code>，输出<code>42</code>。</p>
<h2 id="React中this-handleClick-this-handleClick-bind-this-中的this指向问题"><a href="#React中this-handleClick-this-handleClick-bind-this-中的this指向问题" class="headerlink" title="React中this.handleClick = this.handleClick.bind(this)中的this指向问题"></a>React中this.handleClick = this.handleClick.bind(this)中的this指向问题</h2><p>普通函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;lili&#x27;</span>,age = <span class="number">15</span>;</span><br><span class="line"><span class="keyword">var</span> obj=&#123;</span><br><span class="line">    name : <span class="string">&#x27;Bob&#x27;</span>,</span><br><span class="line">    objage : <span class="variable language_">this</span>.<span class="property">age</span>,</span><br><span class="line">    fun : <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>+<span class="string">&#x27;&#x27;</span>+<span class="variable language_">this</span>.<span class="property">age</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">objage</span>);</span><br><span class="line">obj.<span class="title function_">fun</span>();</span><br></pre></td></tr></table></figure>

<p>var只是定义了变量，不会自己去调用，我们调用obj.objage，obj是一个对象，obj.objage就等于this.age，那这个this指代什么，我们刚刚说了普通函数中this是执行时的上下文，这个obj在哪里执行的？在整个js代码即全局中执行的，所以this.age=15。<br>调用obj.fun()，fun函数所执行的上下文就是obj这个对象，所以this就指代obj这个对象，this.name=bob，但obj中没有age这个属性，所以是undefined。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;<span class="comment">//定义一个组件类Example</span></span><br><span class="line">    handleClick = <span class="function">() =&gt;</span> &#123;<span class="comment">//定义一个箭头函数</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleClick&#125;</span>&gt;</span>click<span class="tag">&lt;/<span class="name">button</span>&gt;</span>    </span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">Example</span> /&gt;</span></span>,</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;div&quot;</span>)</span><br><span class="line">); </span><br></pre></td></tr></table></figure>

<p>发现他打印的是<code>Example</code>这个类，箭头函数是this定义时的上下文。当我们点击按钮，会调用<code>handleClick</code>方法来处理事件，handleClick是在Example类中定义的，所以<code>this指代Example</code>这个类。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;<span class="comment">//定义一个组件类Example</span></span><br><span class="line">    <span class="title function_">handleClick</span>(<span class="params"></span>)&#123;<span class="comment">//定义一个普通函数</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleClick&#125;</span>&gt;</span>click<span class="tag">&lt;/<span class="name">button</span>&gt;</span>    </span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">Example</span> /&gt;</span></span>,</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;div&quot;</span>)</span><br><span class="line">);   </span><br></pre></td></tr></table></figure>

<p>我们发现是undefined，普通函数是this执行时的上下文，点击按钮，调用handleClick来处理事件，this.handleClick中的this指向的还是这个类。但是{this.handleClick}被赋值给了onClick。</p>
<p>相当于button实例.onclick{this.handleClick}由于是button实例中没有定义handleClick，所以是undefined。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/babel&quot;</span>&gt;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Example</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">        <span class="title function_">handleClick</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> (</span><br><span class="line">                <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleClick.bind(this)&#125;</span>&gt;</span>click<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">Example</span> /&gt;</span></span>,</span><br><span class="line">        <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;root&quot;</span>)</span><br><span class="line">    );</span><br></pre></td></tr></table></figure>

<p>在原来基础上，bind函数是创建一个新函数，称为绑定函数，将调用绑定函数的函数绑定到bind的第一个参数上。再渲染虚假dom树时，this指向Example这个类，相当于Example.handleClick.bind(Example)，把handleClick这个函数绑定到Example类，使得this始终指向Example。</p>
</script></li></ul></li></ul>]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>动态代理</title>
    <url>/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><blockquote>
<p>source from <a href="https://liaoxuefeng.com/books/java/reflection/class/index.html">https://liaoxuefeng.com/books/java/reflection/class/index.html</a></p>
</blockquote>
<h2 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h2><p>除了<code>int</code>等基本类型外，Java的其他类型全部都是<code>class</code>（包括<code>interface</code>）。例如：</p>
<ul>
<li><code>String</code></li>
<li><code>Object</code></li>
<li><code>Runnable</code></li>
<li><code>Exception</code></li>
<li>…</li>
</ul>
<p>仔细思考，我们可以得出结论：<code>class</code>（包括<code>interface</code>）的本质是数据类型（<code>Type</code>）。无继承关系的数据类型无法赋值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Number</span> <span class="variable">n</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Double</span>(<span class="number">123.456</span>); <span class="comment">// OK</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Double</span>(<span class="number">123.456</span>); <span class="comment">// compile error!</span></span><br></pre></td></tr></table></figure>

<p>而<code>class</code>是由JVM在执行过程中动态加载的。JVM在第一次读取到一种<code>class</code>类型时，将其加载进内存。</p>
<p>每加载一种<code>class</code>，JVM就为其创建一个<code>Class</code>类型的实例，并关联起来。注意：这里的<code>Class</code>类型是一个名叫<code>Class</code>的<code>class</code>。它长这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Class</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Class</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以<code>String</code>类为例，当JVM加载<code>String</code>类时，它首先读取<code>String.class</code>文件到内存，然后，为<code>String</code>类创建一个<code>Class</code>实例并关联起来：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Class</span>(String);</span><br></pre></td></tr></table></figure>

<p>这个<code>Class</code>实例是JVM内部创建的，如果我们查看JDK源码，可以发现<code>Class</code>类的构造方法是<code>private</code>，只有JVM能创建<code>Class</code>实例，我们自己的Java程序是无法创建<code>Class</code>实例的。</p>
<p>所以，JVM持有的每个<code>Class</code>实例都指向一个数据类型（<code>class</code>或<code>interface</code>）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">┌───────────────────────────┐</span><br><span class="line">│      Class Instance       │────▶ String</span><br><span class="line">├───────────────────────────┤</span><br><span class="line">│name = &quot;java.lang.String&quot;  │</span><br><span class="line">└───────────────────────────┘</span><br><span class="line">┌───────────────────────────┐</span><br><span class="line">│      Class Instance       │────▶ Random</span><br><span class="line">├───────────────────────────┤</span><br><span class="line">│name = &quot;java.util.Random&quot;  │</span><br><span class="line">└───────────────────────────┘</span><br><span class="line">┌───────────────────────────┐</span><br><span class="line">│      Class Instance       │────▶ Runnable</span><br><span class="line">├───────────────────────────┤</span><br><span class="line">│name = &quot;java.lang.Runnable&quot;│</span><br><span class="line">└───────────────────────────┘</span><br></pre></td></tr></table></figure>

<p>一个<code>Class</code>实例包含了该<code>class</code>的所有完整信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">┌───────────────────────────┐</span><br><span class="line">│      Class Instance       │────▶ String</span><br><span class="line">├───────────────────────────┤</span><br><span class="line">│name = &quot;java.lang.String&quot;  │</span><br><span class="line">├───────────────────────────┤</span><br><span class="line">│package = &quot;java.lang&quot;      │</span><br><span class="line">├───────────────────────────┤</span><br><span class="line">│super = &quot;java.lang.Object&quot; │</span><br><span class="line">├───────────────────────────┤</span><br><span class="line">│interface = CharSequence...│</span><br><span class="line">├───────────────────────────┤</span><br><span class="line">│field = value[],hash,...   │</span><br><span class="line">├───────────────────────────┤</span><br><span class="line">│method = indexOf()...      │</span><br><span class="line">└───────────────────────────┘</span><br></pre></td></tr></table></figure>

<blockquote>
<p>由于JVM为每个加载的<code>class</code>创建了对应的<code>Class</code>实例，并在实例中保存了该<code>class</code>的所有信息，包括类名、包名、父类、实现的接口、所有方法、字段等，因此，如果获取了某个<code>Class</code>实例，我们就可以通过这个<code>Class</code>实例获取到该实例对应的<code>class</code>的所有信息。</p>
</blockquote>
<p>这种通过<code>Class</code>实例获取<code>class</code>信息的方法称为反射（Reflection）。</p>
<p>如何获取一个<code>class</code>的<code>Class</code>实例？有三个方法：</p>
<p>方法一：直接通过一个<code>class</code>的静态变量<code>class</code>获取：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> String.class;</span><br></pre></td></tr></table></figure>

<p>方法二：如果我们有一个实例变量，可以通过该实例变量提供的<code>getClass()</code>方法获取：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> s.getClass();</span><br></pre></td></tr></table></figure>

<p>方法三：如果知道一个<code>class</code>的完整类名，可以通过静态方法<code>Class.forName()</code>获取：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.lang.String&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>因为<code>Class</code>实例在JVM中是唯一的，所以，上述方法获取的<code>Class</code>实例是同一个实例。可以用<code>==</code>比较两个<code>Class</code>实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">cls1</span> <span class="operator">=</span> String.class;</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">Class</span> <span class="variable">cls2</span> <span class="operator">=</span> s.getClass();</span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="variable">sameClass</span> <span class="operator">=</span> cls1 == cls2; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>注意一下<code>Class</code>实例比较和<code>instanceof</code>的差别：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">n</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">123</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="variable">b1</span> <span class="operator">=</span> n <span class="keyword">instanceof</span> Integer; <span class="comment">// true，因为n是Integer类型</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">b2</span> <span class="operator">=</span> n <span class="keyword">instanceof</span> Number; <span class="comment">// true，因为n是Number类型的子类</span></span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="variable">b3</span> <span class="operator">=</span> n.getClass() == Integer.class; <span class="comment">// true，因为n.getClass()返回Integer.class</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">c1</span> <span class="operator">=</span> n.getClass();</span><br><span class="line"><span class="type">Class</span> <span class="variable">c2</span> <span class="operator">=</span> Number.class;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">b4</span> <span class="operator">=</span> c1 == c2; <span class="comment">// false，因为Integer.class != Number.class</span></span><br></pre></td></tr></table></figure>

<p>用<code>instanceof</code>不但匹配指定类型，还匹配指定类型的子类。而用<code>==</code>判断<code>class</code>实例可以精确地判断数据类型，但不能作子类型比较。</p>
<p>通常情况下，我们应该用<code>instanceof</code>判断数据类型，因为面向抽象编程的时候，我们不关心具体的子类型。只有在需要精确判断一个类型是不是某个<code>class</code>的时候，我们才使用<code>==</code>判断<code>class</code>实例。</p>
<p>因为反射的目的是为了获得某个实例的信息。因此，当我们拿到某个<code>Object</code>实例时，我们可以通过反射获取该<code>Object</code>的<code>class</code>信息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">printObjectInfo</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">    <span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> obj.getClass();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要从<code>Class</code>实例获取获取的基本信息，参考下面的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// reflection</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        printClassInfo(<span class="string">&quot;&quot;</span>.getClass());</span><br><span class="line">        printClassInfo(Runnable.class);</span><br><span class="line">        printClassInfo(java.time.Month.class);</span><br><span class="line">        printClassInfo(String[].class);</span><br><span class="line">        printClassInfo(<span class="type">int</span>.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printClassInfo</span><span class="params">(Class cls)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Class name: &quot;</span> + cls.getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;Simple name: &quot;</span> + cls.getSimpleName());</span><br><span class="line">        <span class="keyword">if</span> (cls.getPackage() != <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Package name: &quot;</span> + cls.getPackage().getName());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;is interface: &quot;</span> + cls.isInterface());</span><br><span class="line">        System.out.println(<span class="string">&quot;is enum: &quot;</span> + cls.isEnum());</span><br><span class="line">        System.out.println(<span class="string">&quot;is array: &quot;</span> + cls.isArray());</span><br><span class="line">        System.out.println(<span class="string">&quot;is primitive: &quot;</span> + cls.isPrimitive());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意到数组（例如<code>String[]</code>）也是一种类，而且不同于<code>String.class</code>，它的类名是<code>[Ljava.lang.String;</code>。此外，JVM为每一种基本类型如<code>int</code>也创建了<code>Class</code>实例，通过<code>int.class</code>访问。</p>
<p>如果获取到了一个<code>Class</code>实例，我们就可以通过该<code>Class</code>实例来创建对应类型的实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取String的Class实例:</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> String.class;</span><br><span class="line"><span class="comment">// 创建一个String实例:</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> (String) cls.newInstance();</span><br></pre></td></tr></table></figure>

<p>上述代码相当于<code>new String()</code>。通过<code>Class.newInstance()</code>可以创建类实例，它的局限是：只能调用<code>public</code>的无参数构造方法。带参数的构造方法，或者非<code>public</code>的构造方法都无法通过<code>Class.newInstance()</code>被调用。</p>
<h3 id="动态加载"><a href="#动态加载" class="headerlink" title="动态加载"></a>动态加载</h3><p>JVM在执行Java程序的时候，并不是一次性把所有用到的class全部加载到内存，而是第一次需要用到class时才加载。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Main.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (args.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            create(args[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">create</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当执行<code>Main.java</code>时，由于用到了<code>Main</code>，因此，JVM首先会把<code>Main.class</code>加载到内存。然而，并不会加载<code>Person.class</code>，除非程序执行到<code>create()</code>方法，JVM发现需要加载<code>Person</code>类时，才会首次加载<code>Person.class</code>。如果没有执行<code>create()</code>方法，那么<code>Person.class</code>根本就不会被加载。</p>
<p>这就是JVM动态加载<code>class</code>的特性。</p>
<p>动态加载<code>class</code>的特性对于Java程序非常重要。利用JVM动态加载<code>class</code>的特性，我们才能在运行期根据条件加载不同的实现类。例如，Commons Logging总是优先使用Log4j，只有当Log4j不存在时，才使用JDK的logging。利用JVM动态加载特性，大致的实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Commons Logging优先使用Log4j:</span></span><br><span class="line"><span class="type">LogFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span> (isClassPresent(<span class="string">&quot;org.apache.logging.log4j.Logger&quot;</span>)) &#123;</span><br><span class="line">    factory = createLog4j();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    factory = createJdkLog();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isClassPresent</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Class.forName(name);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就是为什么我们只需要把Log4j的jar包放到classpath中，Commons Logging就会自动使用Log4j的原因。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>JVM为每个加载的<code>class</code>及<code>interface</code>创建了对应的<code>Class</code>实例来保存<code>class</code>及<code>interface</code>的所有信息；</p>
<p>获取一个<code>class</code>对应的<code>Class</code>实例后，就可以获取该<code>class</code>的所有信息；</p>
<p>通过Class实例获取<code>class</code>信息的方法称为反射（Reflection）；</p>
<p>JVM总是动态加载<code>class</code>，可以在运行期根据条件来控制加载class。</p>
<h2 id="访问字段"><a href="#访问字段" class="headerlink" title="访问字段"></a>访问字段</h2><p>对任意的一个<code>Object</code>实例，只要我们获取了它的<code>Class</code>，就可以获取它的一切信息。</p>
<p>我们先看看如何通过<code>Class</code>实例获取字段信息。<code>Class</code>类提供了以下几个方法来获取字段：</p>
<ul>
<li>Field getField(name)：根据字段名获取某个public的field（包括父类）</li>
<li>Field getDeclaredField(name)：根据字段名获取当前类的某个field（不包括父类）</li>
<li>Field[] getFields()：获取所有public的field（包括父类）</li>
<li>Field[] getDeclaredFields()：获取当前类的所有field（不包括父类）</li>
</ul>
<p>我们来看一下示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// reflection</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">stdClass</span> <span class="operator">=</span> Student.class;</span><br><span class="line">        <span class="comment">// 获取public字段&quot;score&quot;:</span></span><br><span class="line">        System.out.println(stdClass.getField(<span class="string">&quot;score&quot;</span>));</span><br><span class="line">        <span class="comment">// 获取继承的public字段&quot;name&quot;:</span></span><br><span class="line">        System.out.println(stdClass.getField(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">        <span class="comment">// 获取private字段&quot;grade&quot;:</span></span><br><span class="line">        System.out.println(stdClass.getDeclaredField(<span class="string">&quot;grade&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> score;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> grade;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码首先获取<code>Student</code>的<code>Class</code>实例，然后，分别获取<code>public</code>字段、继承的<code>public</code>字段以及<code>private</code>字段，打印出的<code>Field</code>类似：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int Student.score</span><br><span class="line">public java.lang.String Person.name</span><br><span class="line">private int Student.grade</span><br></pre></td></tr></table></figure>

<p>一个<code>Field</code>对象包含了一个字段的所有信息：</p>
<ul>
<li><code>getName()</code>：返回字段名称，例如，<code>&quot;name&quot;</code>；</li>
<li><code>getType()</code>：返回字段类型，也是一个<code>Class</code>实例，例如，<code>String.class</code>；</li>
<li><code>getModifiers()</code>：返回字段的修饰符，它是一个<code>int</code>，不同的bit表示不同的含义。</li>
</ul>
<p>以<code>String</code>类的<code>value</code>字段为例，它的定义是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">byte</span>[] value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们用反射获取该字段的信息，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Field</span> <span class="variable">f</span> <span class="operator">=</span> String.class.getDeclaredField(<span class="string">&quot;value&quot;</span>);</span><br><span class="line">f.getName(); <span class="comment">// &quot;value&quot;</span></span><br><span class="line">f.getType(); <span class="comment">// class [B 表示byte[]类型</span></span><br><span class="line"><span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> f.getModifiers();</span><br><span class="line">Modifier.isFinal(m); <span class="comment">// true</span></span><br><span class="line">Modifier.isPublic(m); <span class="comment">// false</span></span><br><span class="line">Modifier.isProtected(m); <span class="comment">// false</span></span><br><span class="line">Modifier.isPrivate(m); <span class="comment">// true</span></span><br><span class="line">Modifier.isStatic(m); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h3 id="获取字段值"><a href="#获取字段值" class="headerlink" title="获取字段值"></a>获取字段值</h3><p>利用反射拿到字段的一个<code>Field</code>实例只是第一步，我们还可以拿到一个实例对应的该字段的值。</p>
<p>例如，对于一个<code>Person</code>实例，我们可以先拿到<code>name</code>字段对应的<code>Field</code>，再获取这个实例的<code>name</code>字段的值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// reflection</span></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Xiao Ming&quot;</span>);</span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> p.getClass();</span><br><span class="line">        <span class="type">Field</span> <span class="variable">f</span> <span class="operator">=</span> c.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> f.get(p);</span><br><span class="line">        System.out.println(value); <span class="comment">// &quot;Xiao Ming&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码先获取<code>Class</code>实例，再获取<code>Field</code>实例，然后，用<code>Field.get(Object)</code>获取指定实例的指定字段的值。</p>
<p>运行代码，如果不出意外，会得到一个<code>IllegalAccessException</code>，这是因为<code>name</code>被定义为一个<code>private</code>字段，正常情况下，<code>Main</code>类无法访问<code>Person</code>类的<code>private</code>字段。要修复错误，可以将<code>private</code>改为<code>public</code>，或者，在调用<code>Object value = f.get(p);</code>前，先写一句：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">f.setAccessible(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<p>调用<code>Field.setAccessible(true)</code>的意思是，别管这个字段是不是<code>public</code>，一律允许访问。</p>
<p>可以试着加上上述语句，再运行代码，就可以打印出<code>private</code>字段的值。</p>
<p>有童鞋会问：如果使用反射可以获取<code>private</code>字段的值，那么类的封装还有什么意义？</p>
<p>答案是正常情况下，我们总是通过<code>p.name</code>来访问<code>Person</code>的<code>name</code>字段，编译器会根据<code>public</code>、<code>protected</code>和<code>private</code>决定是否允许访问字段，这样就达到了数据封装的目的。</p>
<p>而反射是一种非常规的用法，使用反射，首先代码非常繁琐，其次，它更多地是给工具或者底层框架来使用，目的是在不知道目标实例任何信息的情况下，获取特定字段的值。</p>
<p>此外，<code>setAccessible(true)</code>可能会失败。如果JVM运行期存在<code>SecurityManager</code>，那么它会根据规则进行检查，有可能阻止<code>setAccessible(true)</code>。例如，某个<code>SecurityManager</code>可能不允许对<code>java</code>和<code>javax</code>开头的<code>package</code>的类调用<code>setAccessible(true)</code>，这样可以保证JVM核心库的安全。</p>
<h3 id="设置字段值"><a href="#设置字段值" class="headerlink" title="设置字段值"></a>设置字段值</h3><p>通过Field实例既然可以获取到指定实例的字段值，自然也可以设置字段的值。</p>
<p>设置字段值是通过<code>Field.set(Object, Object)</code>实现的，其中第一个<code>Object</code>参数是指定的实例，第二个<code>Object</code>参数是待修改的值。示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// reflection</span></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Xiao Ming&quot;</span>);</span><br><span class="line">        System.out.println(p.getName()); <span class="comment">// &quot;Xiao Ming&quot;</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> p.getClass();</span><br><span class="line">        <span class="type">Field</span> <span class="variable">f</span> <span class="operator">=</span> c.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        f.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        f.set(p, <span class="string">&quot;Xiao Hong&quot;</span>);</span><br><span class="line">        System.out.println(p.getName()); <span class="comment">// &quot;Xiao Hong&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行上述代码，打印的<code>name</code>字段从<code>Xiao Ming</code>变成了<code>Xiao Hong</code>，说明通过反射可以直接修改字段的值。</p>
<p>同样的，修改非<code>public</code>字段，需要首先调用<code>setAccessible(true)</code>。</p>
<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>Java的反射API提供的<code>Field</code>类封装了字段的所有信息：</p>
<p>通过<code>Class</code>实例的方法可以获取<code>Field</code>实例：<code>getField()</code>，<code>getFields()</code>，<code>getDeclaredField()</code>，<code>getDeclaredFields()</code>；</p>
<p>通过Field实例可以获取字段信息：<code>getName()</code>，<code>getType()</code>，<code>getModifiers()</code>；</p>
<p>通过Field实例可以读取或设置某个对象的字段，如果存在访问限制，要首先调用<code>setAccessible(true)</code>来访问非<code>public</code>字段。</p>
<p>通过反射读写字段是一种非常规方法，它会破坏对象的封装。</p>
<h2 id="调用方法"><a href="#调用方法" class="headerlink" title="调用方法"></a>调用方法</h2><p>我们已经能通过<code>Class</code>实例获取所有<code>Field</code>对象，同样的，可以通过<code>Class</code>实例获取所有<code>Method</code>信息。<code>Class</code>类提供了以下几个方法来获取<code>Method</code>：</p>
<ul>
<li><code>Method getMethod(name, Class...)</code>：获取某个<code>public</code>的<code>Method</code>（包括父类）</li>
<li><code>Method getDeclaredMethod(name, Class...)</code>：获取当前类的某个<code>Method</code>（不包括父类）</li>
<li><code>Method[] getMethods()</code>：获取所有<code>public</code>的<code>Method</code>（包括父类）</li>
<li><code>Method[] getDeclaredMethods()</code>：获取当前类的所有<code>Method</code>（不包括父类）</li>
</ul>
<p>我们来看一下示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// reflection</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">stdClass</span> <span class="operator">=</span> Student.class;</span><br><span class="line">        <span class="comment">// 获取public方法getScore，参数为String:</span></span><br><span class="line">        System.out.println(stdClass.getMethod(<span class="string">&quot;getScore&quot;</span>, String.class));</span><br><span class="line">        <span class="comment">// 获取继承的public方法getName，无参数:</span></span><br><span class="line">        System.out.println(stdClass.getMethod(<span class="string">&quot;getName&quot;</span>));</span><br><span class="line">        <span class="comment">// 获取private方法getGrade，参数为int:</span></span><br><span class="line">        System.out.println(stdClass.getDeclaredMethod(<span class="string">&quot;getGrade&quot;</span>, <span class="type">int</span>.class));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getScore</span><span class="params">(String type)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">99</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getGrade</span><span class="params">(<span class="type">int</span> year)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码首先获取<code>Student</code>的<code>Class</code>实例，然后，分别获取<code>public</code>方法、继承的<code>public</code>方法以及<code>private</code>方法，打印出的<code>Method</code>类似：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int Student.getScore(java.lang.String)</span><br><span class="line">public java.lang.String Person.getName()</span><br><span class="line">private int Student.getGrade(int)</span><br></pre></td></tr></table></figure>

<p>一个<code>Method</code>对象包含一个方法的所有信息：</p>
<ul>
<li><code>getName()</code>：返回方法名称，例如：<code>&quot;getScore&quot;</code>；</li>
<li><code>getReturnType()</code>：返回方法返回值类型，也是一个Class实例，例如：<code>String.class</code>；</li>
<li><code>getParameterTypes()</code>：返回方法的参数类型，是一个Class数组，例如：<code>&#123;String.class, int.class&#125;</code>；</li>
<li><code>getModifiers()</code>：返回方法的修饰符，它是一个<code>int</code>，不同的bit表示不同的含义。</li>
</ul>
<h3 id="调用方法-1"><a href="#调用方法-1" class="headerlink" title="调用方法"></a>调用方法</h3><p>当我们获取到一个<code>Method</code>对象时，就可以对它进行调用。我们以下面的代码为例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;Hello world&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">r</span> <span class="operator">=</span> s.substring(<span class="number">6</span>); <span class="comment">// &quot;world&quot;</span></span><br></pre></td></tr></table></figure>

<p>如果用反射来调用<code>substring</code>方法，需要以下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// reflection</span></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// String对象:</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;Hello world&quot;</span>;</span><br><span class="line">        <span class="comment">// 获取String substring(int)方法，参数为int:</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">m</span> <span class="operator">=</span> String.class.getMethod(<span class="string">&quot;substring&quot;</span>, <span class="type">int</span>.class);</span><br><span class="line">        <span class="comment">// 在s对象上调用该方法并获取结果:</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">r</span> <span class="operator">=</span> (String) m.invoke(s, <span class="number">6</span>);</span><br><span class="line">        <span class="comment">// 打印调用结果:</span></span><br><span class="line">        System.out.println(r); <span class="comment">// &quot;world&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意到<code>substring()</code>有两个重载方法，我们获取的是<code>String substring(int)</code>这个方法。思考一下如何获取<code>String substring(int, int)</code>方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取 substring(int, int) 方法</span></span><br><span class="line">            <span class="type">Method</span> <span class="variable">substringMethod</span> <span class="operator">=</span> stringClass.getMethod(<span class="string">&quot;substring&quot;</span>, <span class="type">int</span>.class, <span class="type">int</span>.class);</span><br></pre></td></tr></table></figure>

<p>对<code>Method</code>实例调用<code>invoke</code>就相当于调用该方法，<code>invoke</code>的第一个参数是对象实例，即在哪个实例上调用该方法，后面的可变参数要与方法参数一致，否则将报错。</p>
<h3 id="调用静态方法"><a href="#调用静态方法" class="headerlink" title="调用静态方法"></a>调用静态方法</h3><p>如果获取到的Method表示一个静态方法，调用静态方法时，由于无需指定实例对象，所以<code>invoke</code>方法传入的第一个参数永远为<code>null</code>。我们以<code>Integer.parseInt(String)</code>为例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// reflection</span></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 获取Integer.parseInt(String)方法，参数为String:</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">m</span> <span class="operator">=</span> Integer.class.getMethod(<span class="string">&quot;parseInt&quot;</span>, String.class);</span><br><span class="line">        <span class="comment">// 调用该静态方法并获取结果:</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">n</span> <span class="operator">=</span> (Integer) m.invoke(<span class="literal">null</span>, <span class="string">&quot;12345&quot;</span>);</span><br><span class="line">        <span class="comment">// 打印调用结果:</span></span><br><span class="line">        System.out.println(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="调用非public方法"><a href="#调用非public方法" class="headerlink" title="调用非public方法"></a>调用非public方法</h3><p>和Field类似，对于非public方法，我们虽然可以通过<code>Class.getDeclaredMethod()</code>获取该方法实例，但直接对其调用将得到一个<code>IllegalAccessException</code>。为了调用非public方法，我们通过<code>Method.setAccessible(true)</code>允许其调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// reflection</span></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        <span class="type">Method</span> <span class="variable">m</span> <span class="operator">=</span> p.getClass().getDeclaredMethod(<span class="string">&quot;setName&quot;</span>, String.class);</span><br><span class="line">        m.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        m.invoke(p, <span class="string">&quot;Bob&quot;</span>);</span><br><span class="line">        System.out.println(p.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此外，<code>setAccessible(true)</code>可能会失败。如果JVM运行期存在<code>SecurityManager</code>，那么它会根据规则进行检查，有可能阻止<code>setAccessible(true)</code>。例如，某个<code>SecurityManager</code>可能不允许对<code>java</code>和<code>javax</code>开头的<code>package</code>的类调用<code>setAccessible(true)</code>，这样可以保证JVM核心库的安全。</p>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>我们来考察这样一种情况：一个<code>Person</code>类定义了<code>hello()</code>方法，并且它的子类<code>Student</code>也覆写了<code>hello()</code>方法，那么，从<code>Person.class</code>获取的<code>Method</code>，作用于<code>Student</code>实例时，调用的方法到底是哪个？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// reflection</span></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 获取Person的hello方法:</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">h</span> <span class="operator">=</span> Person.class.getMethod(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        <span class="comment">// 对Student实例调用hello方法:</span></span><br><span class="line">        h.invoke(<span class="keyword">new</span> <span class="title class_">Student</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Person:hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Student:hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行上述代码，发现打印出的是<code>Student:hello</code>，因此，使用反射调用方法时，仍然遵循多态原则：即总是调用实际类型的覆写方法（如果存在）。上述的反射代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Method</span> <span class="variable">m</span> <span class="operator">=</span> Person.class.getMethod(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">m.invoke(<span class="keyword">new</span> <span class="title class_">Student</span>());</span><br></pre></td></tr></table></figure>

<p>实际上相当于：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">p.hello();</span><br></pre></td></tr></table></figure>

<h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p>Java的反射API提供的Method对象封装了方法的所有信息：</p>
<p>通过<code>Class</code>实例的方法可以获取<code>Method</code>实例：<code>getMethod()</code>，<code>getMethods()</code>，<code>getDeclaredMethod()</code>，<code>getDeclaredMethods()</code>；</p>
<p>通过<code>Method</code>实例可以获取方法信息：<code>getName()</code>，<code>getReturnType()</code>，<code>getParameterTypes()</code>，<code>getModifiers()</code>；</p>
<p>通过<code>Method</code>实例可以调用某个对象的方法：<code>Object invoke(Object instance, Object... parameters)</code>；</p>
<p>通过设置<code>setAccessible(true)</code>来访问非<code>public</code>方法；</p>
<p>通过反射调用方法时，仍然遵循多态原则。</p>
<h2 id="调用构造方法"><a href="#调用构造方法" class="headerlink" title="调用构造方法"></a>调用构造方法</h2><p>我们通常使用<code>new</code>操作符创建新的实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br></pre></td></tr></table></figure>

<p>如果通过反射来创建新的实例，可以调用Class提供的newInstance()方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> Person.class.newInstance();</span><br></pre></td></tr></table></figure>

<p>调用<code>Class.newInstance()</code>的局限是，它只能调用该类的public无参数构造方法。如果构造方法带有参数，或者不是public，就无法直接通过<code>Class.newInstance()</code>来调用。</p>
<p>为了调用任意的构造方法，Java的反射API提供了<code>Constructor</code>对象，它包含一个构造方法的所有信息，可以创建一个实例。<code>Constructor</code>对象和Method非常类似，不同之处仅在于它是一个构造方法，并且，调用结果总是返回实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 获取构造方法Integer(int):</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">cons1</span> <span class="operator">=</span> Integer.class.getConstructor(<span class="type">int</span>.class);</span><br><span class="line">        <span class="comment">// 调用构造方法:</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">n1</span> <span class="operator">=</span> (Integer) cons1.newInstance(<span class="number">123</span>);</span><br><span class="line">        System.out.println(n1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取构造方法Integer(String)</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">cons2</span> <span class="operator">=</span> Integer.class.getConstructor(String.class);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">n2</span> <span class="operator">=</span> (Integer) cons2.newInstance(<span class="string">&quot;456&quot;</span>);</span><br><span class="line">        System.out.println(n2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过Class实例获取Constructor的方法如下：</p>
<ul>
<li><code>getConstructor(Class...)</code>：获取某个<code>public</code>的<code>Constructor</code>；</li>
<li><code>getDeclaredConstructor(Class...)</code>：获取某个<code>Constructor</code>；</li>
<li><code>getConstructors()</code>：获取所有<code>public</code>的<code>Constructor</code>；</li>
<li><code>getDeclaredConstructors()</code>：获取所有<code>Constructor</code>。</li>
</ul>
<p>注意<code>Constructor</code>总是当前类定义的构造方法，和父类无关，因此不存在多态的问题。</p>
<p>调用非<code>public</code>的<code>Constructor</code>时，必须首先通过<code>setAccessible(true)</code>设置允许访问。<code>setAccessible(true)</code>可能会失败。</p>
<h3 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h3><p><code>Constructor</code>对象封装了构造方法的所有信息；</p>
<p>通过<code>Class</code>实例的方法可以获取<code>Constructor</code>实例：<code>getConstructor()</code>，<code>getConstructors()</code>，<code>getDeclaredConstructor()</code>，<code>getDeclaredConstructors()</code>；</p>
<p>通过<code>Constructor</code>实例可以创建一个实例对象：<code>newInstance(Object... parameters)</code>； 通过设置<code>setAccessible(true)</code>来访问非<code>public</code>构造方法。</p>
<h2 id="获取继承关系"><a href="#获取继承关系" class="headerlink" title="获取继承关系"></a>获取继承关系</h2><p>当我们获取到某个<code>Class</code>对象时，实际上就获取到了一个类的类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> String.class; <span class="comment">// 获取到String的Class</span></span><br></pre></td></tr></table></figure>

<p>还可以用实例的<code>getClass()</code>方法获取：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> s.getClass(); <span class="comment">// s是String，因此获取到String的Class</span></span><br></pre></td></tr></table></figure>

<p>最后一种获取<code>Class</code>的方法是通过<code>Class.forName(&quot;&quot;)</code>，传入<code>Class</code>的完整类名获取：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">s</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.lang.String&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>这三种方式获取的<code>Class</code>实例都是同一个实例，因为JVM对每个加载的<code>Class</code>只创建一个<code>Class</code>实例来表示它的类型。</p>
<h3 id="获取父类的Class"><a href="#获取父类的Class" class="headerlink" title="获取父类的Class"></a>获取父类的Class</h3><p>有了<code>Class</code>实例，我们还可以获取它的父类的<code>Class</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// reflection</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">i</span> <span class="operator">=</span> Integer.class;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">n</span> <span class="operator">=</span> i.getSuperclass();</span><br><span class="line">        System.out.println(n);</span><br><span class="line">        <span class="type">Class</span> <span class="variable">o</span> <span class="operator">=</span> n.getSuperclass();</span><br><span class="line">        System.out.println(o);</span><br><span class="line">        System.out.println(o.getSuperclass());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行上述代码，可以看到，<code>Integer</code>的父类类型是<code>Number</code>，<code>Number</code>的父类是<code>Object</code>，<code>Object</code>的父类是<code>null</code>。除<code>Object</code>外，其他任何非<code>interface</code>的<code>Class</code>都必定存在一个父类类型。</p>
<h3 id="获取interface"><a href="#获取interface" class="headerlink" title="获取interface"></a>获取interface</h3><p>由于一个类可能实现一个或多个接口，通过<code>Class</code>我们就可以查询到实现的接口类型。例如，查询<code>Integer</code>实现的接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// reflection</span></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">s</span> <span class="operator">=</span> Integer.class;</span><br><span class="line">        Class[] is = s.getInterfaces();</span><br><span class="line">        <span class="keyword">for</span> (Class i : is) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行上述代码可知，<code>Integer</code>实现的接口有：</p>
<ul>
<li>java.lang.Comparable</li>
<li>java.lang.constant.Constable</li>
<li>java.lang.constant.ConstantDesc</li>
</ul>
<p>要特别注意：<code>getInterfaces()</code>只返回当前类直接实现的接口类型，并不包括其父类实现的接口类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// reflection</span></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">s</span> <span class="operator">=</span> Integer.class.getSuperclass();</span><br><span class="line">        Class[] is = s.getInterfaces();</span><br><span class="line">        <span class="keyword">for</span> (Class i : is) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Integer</code>的父类是<code>Number</code>，<code>Number</code>实现的接口是<code>java.io.Serializable</code>。</p>
<p>此外，对所有<code>interface</code>的<code>Class</code>调用<code>getSuperclass()</code>返回的是<code>null</code>，获取接口的父接口要用<code>getInterfaces()</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(java.io.DataInputStream.class.getSuperclass()); <span class="comment">// java.io.FilterInputStream，因为DataInputStream继承自FilterInputStream</span></span><br><span class="line">System.out.println(java.io.Closeable.class.getSuperclass()); <span class="comment">// null，对接口调用getSuperclass()总是返回null，获取接口的父接口要用getInterfaces()</span></span><br></pre></td></tr></table></figure>

<p>如果一个类没有实现任何<code>interface</code>，那么<code>getInterfaces()</code>返回空数组。</p>
<h3 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h3><p>当我们判断一个实例是否是某个类型时，正常情况下，使用<code>instanceof</code>操作符：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">n</span> <span class="operator">=</span> Integer.valueOf(<span class="number">123</span>);</span><br><span class="line"><span class="type">boolean</span> <span class="variable">isDouble</span> <span class="operator">=</span> n <span class="keyword">instanceof</span> Double; <span class="comment">// false</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">isInteger</span> <span class="operator">=</span> n <span class="keyword">instanceof</span> Integer; <span class="comment">// true</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">isNumber</span> <span class="operator">=</span> n <span class="keyword">instanceof</span> Number; <span class="comment">// true</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">isSerializable</span> <span class="operator">=</span> n <span class="keyword">instanceof</span> java.io.Serializable; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>如果是两个<code>Class</code>实例，要判断一个向上转型是否成立，可以调用<code>isAssignableFrom()</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Integer i = ?</span></span><br><span class="line">Integer.class.isAssignableFrom(Integer.class); <span class="comment">// true，因为Integer可以赋值给Integer</span></span><br><span class="line"><span class="comment">// Number n = ?</span></span><br><span class="line">Number.class.isAssignableFrom(Integer.class); <span class="comment">// true，因为Integer可以赋值给Number</span></span><br><span class="line"><span class="comment">// Object o = ?</span></span><br><span class="line">Object.class.isAssignableFrom(Integer.class); <span class="comment">// true，因为Integer可以赋值给Object</span></span><br><span class="line"><span class="comment">// Integer i = ?</span></span><br><span class="line">Integer.class.isAssignableFrom(Number.class); <span class="comment">// false，因为Number不能赋值给Integer</span></span><br></pre></td></tr></table></figure>

<h3 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h3><p>通过<code>Class</code>对象可以获取继承关系：</p>
<ul>
<li><code>Class getSuperclass()</code>：获取父类类型；</li>
<li><code>Class[] getInterfaces()</code>：获取当前类实现的所有接口。</li>
</ul>
<p>通过<code>Class</code>对象的<code>isAssignableFrom()</code>方法可以判断一个向上转型是否可以实现。</p>
<h1 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h1><blockquote>
<p>资料参考：<a href="https://www.cnblogs.com/tera/p/13911819.html">https://www.cnblogs.com/tera/p/13911819.html</a></p>
<p><a href="https://liaoxuefeng.com/books/java/reflection/proxy/index.html">https://liaoxuefeng.com/books/java/reflection/proxy/index.html</a></p>
</blockquote>
<blockquote>
<p>我们来比较Java的<code>class</code>和<code>interface</code>的区别：</p>
<ul>
<li>可以实例化<code>class</code>（非<code>abstract</code>）；</li>
<li>不能实例化<code>interface</code>。</li>
</ul>
<p>所有<code>interface</code>类型的变量总是通过某个实例向上转型并赋值给接口类型变量的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">CharSequence</span> <span class="variable">cs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br></pre></td></tr></table></figure>

<p>有没有可能不编写实现类，直接在运行期创建某个<code>interface</code>的实例呢？</p>
<p>这是可能的，因为Java标准库提供了一种动态代理（Dynamic Proxy）的机制：可以在运行期动态创建某个<code>interface</code>的实例。</p>
</blockquote>
<p>动态代理是 Java 提供的一种 <strong>动态生成代理类</strong> 的机制，用于在运行时对目标方法进行增强，例如添加日志、事务处理、权限校验等。</p>
<h2 id="java动态代理的使用方式和应用场景"><a href="#java动态代理的使用方式和应用场景" class="headerlink" title="java动态代理的使用方式和应用场景"></a>java动态代理的使用方式和应用场景</h2><ol>
<li>为什么要使用java动态代理</li>
<li>如何使用java动态代理</li>
<li>框架中java动态代理的应用</li>
<li>java动态代理的基本原理</li>
</ol>
<h3 id="1-为何要使用动态代理"><a href="#1-为何要使用动态代理" class="headerlink" title="1.为何要使用动态代理"></a>1.为何要使用动态代理</h3><p>在设计模式中有一个非常常用的模式：代理模式。学术一些来讲，就是为某些对象的某种行为提供一个代理对象，并由代理对象完全控制该行为的实际执行。</p>
<p>通俗来说，就是我想点份外卖，但是手机没电了，于是我让同学用他手机帮我点外卖。在这个过程中，其实就是我<strong>同学（代理对象</strong>）帮<strong>我（被代理的对象）</strong>代理了<strong>点外卖（被代理的行为）</strong>，在这个过程中，同学可以完全控制点外卖的店铺、使用的APP，甚至把外卖直接吃了都行<strong>（对行为的完全控制）</strong>。</p>
<p>因此总结一下代理的4个要素：</p>
<ol>
<li><p>代理对象</p>
</li>
<li><p>被代理的行为</p>
</li>
<li><p>被代理的对象</p>
</li>
<li><p>行为的完全控制</p>
</li>
</ol>
<p>从实际编码的角度来说，我们假设遇到了这样一个需求，需要记录下一些方法的执行时间，于是最简单的方式当然就是在方法的开头记录一个时间戳，在return之前记录一个时间戳。但如果方法的流程很复杂，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Executor</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;start：&#123;&#125;&quot;</span>, System.nanoTime());</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">3</span>) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;end：&#123;&#125;&quot;</span>, System.nanoTime());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (y == <span class="number">5</span>) &#123;</span><br><span class="line">                log.info(<span class="string">&quot;end：&#123;&#125;&quot;</span>, System.nanoTime());</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(<span class="string">&quot;end：&#123;&#125;&quot;</span>, System.nanoTime());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们需要在每一个return前都增加一行记录时间戳的代码，很麻烦。于是我们想到可以由方法的调用者来记录时间，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Invoker</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Executor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Executor</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">invoke</span><span class="params">()</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;start：&#123;&#125;&quot;</span>, System.nanoTime());</span><br><span class="line">        executor.execute(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        log.info(<span class="string">&quot;end：&#123;&#125;&quot;</span>, System.nanoTime());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们又遇到一个问题，如果该方法在很多地方调用，或者需要记录的方法有多个，那么依然会面临重复手动写log代码的问题。</p>
<p>于是，我们就可以考虑创建一个代理对象，让它负责帮我们统一记录时间戳，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Proxy</span> &#123;</span><br><span class="line">    <span class="type">Executor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Executor</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;start：&#123;&#125;&quot;</span>, System.nanoTime());</span><br><span class="line">        executor.execute(x, y);</span><br><span class="line">        log.info(<span class="string">&quot;start：&#123;&#125;&quot;</span>, System.nanoTime());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而在Invoker中，则由直接调用Executor中的方法改为调用Proxy的方法，当然方法的名字和签名是完全相同的。当其他地方需要调用execute方法时，只需要调用Proxy中的execute方法，就会自动记录下时间戳，而对于使用者来说是感知不到区别的。如下示例：</p>
<p>而在Invoker中，则由直接调用Executor中的方法改为调用Proxy的方法，当然方法的名字和签名是完全相同的。当其他地方需要调用execute方法时，只需要调用Proxy中的execute方法，就会自动记录下时间戳，而对于使用者来说是感知不到区别的。如下示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Invoker</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Proxy proxy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">invoke</span><span class="params">()</span> &#123;</span><br><span class="line">        proxy.execute(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面展示的代理，就是一个典型的静态代理，“静态”体现在代理方法是我们直接编码在类中的。</p>
<p>接着我们就遇到了下一个问题，如果Executor新增了一个方法，同样要记录时间，那我们就不得不修改Proxy的代码。并且如果其他类也有同样的需求，那就需要新建不同的Proxy类才能较好的实现该功能，同样非常麻烦。</p>
<p>那么我们就需要将静态代理升级成为动态代理了，而“动态”正是为了优化前面提到的2个静态代理遇到的问题。</p>
<h3 id="2-如何使用java动态代理"><a href="#2-如何使用java动态代理" class="headerlink" title="2.如何使用java动态代理"></a>2.如何使用java动态代理</h3><p>创建java动态代理需要使用如下类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.lang.reflect.Proxy</span><br></pre></td></tr></table></figure>

<p>调用其newProxyInstance方法，例如我们需要为Map创建一个代理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Map</span> <span class="variable">mapProxy</span> <span class="operator">=</span> (Map) Proxy.newProxyInstance(</span><br><span class="line">        HashMap.class.getClassLoader(),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Map.class&#125;,</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InvocationHandler</span>()&#123;...&#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>我们接着就来分析这个方法。先查看其签名：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">newProxyInstance</span><span class="params">(ClassLoader loader,</span></span><br><span class="line"><span class="params">                                      Class&lt;?&gt;[] interfaces,</span></span><br><span class="line"><span class="params">                                      InvocationHandler h)</span></span><br></pre></td></tr></table></figure>

<p><em>ClassLoader类型的loader</em>：被代理的类的加载器，可以认为对应4要素中的<strong>被代理的对象</strong>。</p>
<p><em>Class数组的interfaces</em>：被代理的接口，这里其实对应的就是4要素中的<strong>被代理的行为</strong>，可以注意到，这里需要传入的是接口而不是某个具体的类，因此表示行为。</p>
<p><em>InvocationHandler接口的h</em>：代理的具体行为，对应的是4要素中的<strong>行为的完全控制</strong>，当然也是java动态代理的核心。</p>
<p>最后返回的对象Object对应的是4要素中的<strong>代理对象</strong>。</p>
<p>接着我们来示例用java动态代理来完成记录方法执行时间戳的需求：</p>
<p>首先定义<strong>被代理的行为</strong>，即接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ExecutorInterface</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着定义<strong>被代理的对象</strong>，即实现了接口的类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Executor</span> <span class="keyword">implements</span> <span class="title class_">ExecutorInterface</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;execute method executed&quot;</span> + x + y);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着是代理的核心，即<strong>行为的控制</strong>，需要一个实现了InvocationHandler接口的类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TimeLogHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个接口中的方法并不复杂，我们还是先分析其签名</p>
<p><em>Object类型的proxy</em>：最终生成的<strong>代理对象</strong></p>
<p>Method类型的method：被代理的方法。这里其实是2个要素的复合，即<strong>被代理的对象</strong>是如何执行<strong>被代理的行为</strong>的。因为虽然我们说要对行为完全控制，但大部分时候，我们只是对行为增添一些额外的功能，因此依然是要利用被代理对象原先的执行过程的。</p>
<p><em>Object数组的args</em>：方法执行的参数</p>
<p><strong>因为我们的目的是要记录方法的执行的时间戳，并且原方法本身还是依然要执行的，所以在TimeLogHandler的构造函数中，将一个原始对象传入，method在调用invoke方法时即可使用。</strong></p>
<p>定义代理的行为如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TimeLogHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TimeLogHandler</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;invoke method executed start&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line">        System.out.println(<span class="string">&quot;invoke method executed end&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完整代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.sql.Time;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DynamicProxyDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">ExecutorInterface</span> <span class="variable">executor</span> <span class="operator">=</span> (ExecutorInterface) Proxy.newProxyInstance(Executor.class.getClassLoader(), <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;ExecutorInterface.class&#125;, <span class="keyword">new</span> <span class="title class_">TimeLogHandler</span>(<span class="keyword">new</span> <span class="title class_">Executor</span>()));</span><br><span class="line">        executor.execute(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Executor</span> <span class="keyword">implements</span> <span class="title class_">ExecutorInterface</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;execute method executed&quot;</span> + x + y);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TimeLogHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TimeLogHandler</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;invoke method executed start&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line">        System.out.println(<span class="string">&quot;invoke method executed end&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>注解</title>
    <url>/%E6%B3%A8%E8%A7%A3/</url>
    <content><![CDATA[<blockquote>
<p>参考：<a href="https://www.cnblogs.com/ziph/p/13056092.html">https://www.cnblogs.com/ziph/p/13056092.html</a> &amp;&amp; chatgpt</p>
</blockquote>
<h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><p>什么是注解（Annotation）？注解是放在Java源码的类、方法、字段、参数前的一种特殊“注释”：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// this is a component:</span></span><br><span class="line"><span class="meta">@Resource(&quot;hello&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">(<span class="meta">@Param</span> String name)</span> &#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注释会被编译器直接忽略，注解则可以被编译器打包进入class文件，因此，注解是一种用作标注的“元数据”。</p>
<p>从JVM的角度看，注解本身对代码逻辑没有任何影响，如何使用注解完全由工具决定。</p>
<h2 id="定义注解"><a href="#定义注解" class="headerlink" title="定义注解"></a>定义注解</h2><p>Java语言使用<code>@interface</code>语法来定义注解（<code>Annotation</code>），它的格式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Report &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">type</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">    String <span class="title function_">level</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;info&quot;</span>;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注解的参数类似无参数方法，可以用<code>default</code>设定一个默认值（强烈推荐）。最常用的参数应当命名为<code>value</code>。</p>
<h3 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h3><blockquote>
<p>有一些注解可以修饰其他注解，这些注解就称为元注解（meta annotation）。Java标准库已经定义了一些元注解，我们只需要使用元注解，通常不需要自己去编写元注解。</p>
</blockquote>
<h4 id="Target"><a href="#Target" class="headerlink" title="@Target"></a>@Target</h4><p>最常用的元注解是<code>@Target</code>。使用<code>@Target</code>可以定义<code>Annotation</code>能够被应用于源码的哪些位置：</p>
<ul>
<li><code>ElementType.TYPE</code>：允许被修饰的注解作用在类、接口和枚举上</li>
<li><code>ElementType.FIELD</code>：允许作用在属性字段上</li>
<li><code>ElementType.METHOD</code>：允许作用在方法上</li>
<li><code>ElementType.PARAMETER</code>：允许作用在方法参数上</li>
<li><code>ElementType.CONSTRUCTOR</code>：允许作用在构造器上</li>
<li><code>ElementType.LOCAL_VARIABLE</code>：允许作用在本地局部变量上</li>
<li><code>ElementType.ANNOTATION_TYPE</code>：允许作用在注解上</li>
<li><code>ElementType.PACKAGE</code>：允许作用在包上</li>
</ul>
<p>例如，定义注解<code>@Report</code>可用在方法上，我们必须添加一个<code>@Target(ElementType.METHOD)</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Report &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">type</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">    String <span class="title function_">level</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;info&quot;</span>;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义注解<code>@Report</code>可用在方法或字段上，可以把<code>@Target</code>注解参数变为数组<code>&#123; ElementType.METHOD, ElementType.FIELD &#125;</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;</span></span><br><span class="line"><span class="meta">    ElementType.METHOD,</span></span><br><span class="line"><span class="meta">    ElementType.FIELD</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Report &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上<code>@Target</code>定义的<code>value</code>是<code>ElementType[]</code>数组，只有一个元素时，可以省略数组的写法。</p>
<h4 id="Retention"><a href="#Retention" class="headerlink" title="@Retention"></a>@Retention</h4><p>另一个重要的元注解<code>@Retention</code>定义了<code>Annotation</code>的生命周期：</p>
<ul>
<li><code>RetentionPolicy.SOURCE</code>：当前注解编译期可见，不会写入 class 文件</li>
<li><code>RetentionPolicy.CLASS</code>：类加载阶段丢弃，在class文件的属性表中用 <strong>RuntimeInvisibleAnnotations</strong>表示</li>
<li><code>RetentionPolicy.RUNTIME</code>：<strong>永久保存，可以反射获取，一般自定义注解都是RUNTIME</strong>，在class文件的属性表中用<strong>RuntimeVisibleAnnotations</strong> 表示</li>
</ul>
<p>如果<code>@Retention</code>不存在，则该<code>Annotation</code>默认为<code>CLASS</code>。因为通常我们自定义的<code>Annotation</code>都是<code>RUNTIME</code>，所以，务必要加上<code>@Retention(RetentionPolicy.RUNTIME)</code>这个元注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Report &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">type</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">    String <span class="title function_">level</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;info&quot;</span>;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Repeatable"><a href="#Repeatable" class="headerlink" title="@Repeatable"></a>@Repeatable</h4><p>使用<code>@Repeatable</code>这个元注解可以定义<code>Annotation</code>是否可重复。这个注解应用不是特别广泛。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repeatable(Reports.class)</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Report &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">type</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">    String <span class="title function_">level</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;info&quot;</span>;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Reports &#123;</span><br><span class="line">    Report[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经过<code>@Repeatable</code>修饰后，在某个类型声明处，就可以添加多个<code>@Report</code>注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Report(type=1, level=&quot;debug&quot;)</span></span><br><span class="line"><span class="meta">@Report(type=2, level=&quot;warning&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Inherited"><a href="#Inherited" class="headerlink" title="@Inherited"></a>@Inherited</h4><p>使用<code>@Inherited</code>定义子类是否可继承父类定义的<code>Annotation</code>。<code>@Inherited</code>仅针对<code>@Target(ElementType.TYPE)</code>类型的<code>annotation</code>有效，并且仅针对<code>class</code>的继承，对<code>interface</code>的继承无效：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Report &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">type</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">    String <span class="title function_">level</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;info&quot;</span>;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在使用的时候，如果一个类用到了<code>@Report</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Report(type=1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>则它的子类默认也定义了该注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="如何定义Annotation"><a href="#如何定义Annotation" class="headerlink" title="如何定义Annotation"></a>如何定义Annotation</h3><p>我们总结一下定义<code>Annotation</code>的步骤：</p>
<p>第一步，用<code>@interface</code>定义注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Report &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二步，添加参数、默认值：</p>
<blockquote>
<p>我们的注解中也是可以写有属性的，它的属性不同于普通的属性，它的属性是抽象方法。既然注解也是一个接口，那么我们可以说接口体中可以定义什么，它同样也可以定义，而它的修饰符与接口一样，也是默认被<code>public abstract</code>修饰。</p>
</blockquote>
<blockquote>
<p>而注解体中的属性也是有要求的。其属性要求如下：</p>
<ul>
<li><strong>属性的返回值类型必须是以下几种：</strong></li>
<li>基本数据类型</li>
<li>String类型</li>
<li>枚举类型</li>
<li>注解</li>
<li>以上类型的数组</li>
<li><strong>注意：</strong> 在这里不能有void的无返回值类型和以上类型以外的类型</li>
<li><strong>定义的属性，在使用时需要给注解中的属性赋值</strong></li>
<li>如果定义属性时，使用<code>default</code>关键字给属性默认初始化值，则使用注解时可以不为属性赋值，它取的是默认值。如果为它再次传入值，那么就发生了对原值的覆盖。</li>
<li>如果只有一个属性需要赋值，并且属性的名称为value，则赋值时value可以省略，可以直接定义值</li>
<li>数组赋值时，值使用<code>&#123;&#125;</code>存储值。如果数组中只有一个值，则可以省略<code>&#123;&#125;</code>。</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnno &#123;</span><br><span class="line">    <span class="comment">//基本数据类型</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">num</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//String类型</span></span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//枚举类型</span></span><br><span class="line">    Lamp <span class="title function_">lamp</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注解类型</span></span><br><span class="line">    MyAnno2 <span class="title function_">myAnno2</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//以上类型的数组</span></span><br><span class="line">    String[] values();</span><br><span class="line">    Lamp[] lamps();</span><br><span class="line">    MyAnno2[] myAnno2s();</span><br><span class="line">    <span class="type">int</span>[] nums();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果没有默认初始化，那么在使用注解时需要进行传参赋值</p>
<img src="image-20241203133211951.png" class title="image-20241203133211951">

<p>格式为：<code>名称 = 返回值类型参数</code></p>
<img src="image-20241203133236797.png" class title="image-20241203133236797">

<img src="image-20241203133301572.png" class title="image-20241203133301572">

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Report &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">type</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">    String <span class="title function_">level</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;info&quot;</span>;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>把最常用的参数定义为<code>value()</code>，推荐所有参数都尽量设置默认值。</p>
<p>第三步，用元注解配置注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Report &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">type</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">    String <span class="title function_">level</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;info&quot;</span>;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，必须设置<code>@Target</code>和<code>@Retention</code>，<code>@Retention</code>一般设置为<code>RUNTIME</code>，因为我们自定义的注解通常要求在运行期读取。一般情况下，不必写<code>@Inherited</code>和<code>@Repeatable</code>。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>Java使用<code>@interface</code>定义注解；</p>
<p>可定义多个参数和默认值，核心参数使用<code>value</code>名称；</p>
<p>必须设置<code>@Target</code>来指定<code>Annotation</code>可以应用的范围；</p>
<p>应当设置<code>@Retention(RetentionPolicy.RUNTIME)</code>便于运行期读取该<code>Annotation</code>。</p>
<h2 id="注解分类"><a href="#注解分类" class="headerlink" title="注解分类"></a>注解分类</h2><h3 id="jdk的内置注解"><a href="#jdk的内置注解" class="headerlink" title="jdk的内置注解"></a>jdk的内置注解</h3><blockquote>
<ul>
<li><strong>@Override：</strong> 标记在成员方法上，用于标识当前方法是重写父类（父接口）方法，编译器在对该方法进行编译时会检查是否符合重写规则，如果不符合，编译报错。</li>
<li><strong>@Deprecated：</strong> 用于标记当前类、成员变量、成员方法或者构造方法过时如果开发者调用了被标记为过时的方法，编译器在编译期进行警告。</li>
<li><strong>@SuppressWarnings：</strong> 压制警告注解，可放置在类和方法上，该注解的作用是阻止编译器发出某些警告信息。</li>
</ul>
</blockquote>
<h3 id="根据注解参数分类"><a href="#根据注解参数分类" class="headerlink" title="根据注解参数分类"></a>根据注解参数分类</h3><p>注解可以根据注解参数分为三大类：</p>
<blockquote>
<ul>
<li>标记注解： 没有参数的注解，仅用自身的存在与否为程序提供信息，如@Override注解，该注解没有参数，用于表示当前方法为重写方法。</li>
<li>单值注解： 只有一个参数的注解，如果该参数的名字为value，那么可以省略参数名，如 @SuppressWarnings(value &#x3D; “all”)，可以简写为@SuppressWarnings(“all”)。</li>
<li>完整注解： 有多个参数的注解。</li>
</ul>
</blockquote>
<h4 id="标记注解"><a href="#标记注解" class="headerlink" title="标记注解"></a>标记注解</h4><blockquote>
<p>说到@Override注解是一个标记注解，那我们进入到该注解的源码查看一下。从上往下看该注解源码，发现它继承了导入了<code>java.lang.annotation.*</code>，也就是有使用到该包的内容。然后下面就是元注解，其实发现注解的定义格式是public修饰的@Interface，最终看到该注解中方法体并没有任何参数，也就是只起到标记作用。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>  Peter von der Ah&amp;eacute;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>  Joshua Bloch</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@jls</span> 8.4.8 Inheritance, Overriding, and Hiding</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@jls</span> 9.4.1 Inheritance and Overriding</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@jls</span> 9.6.4.4 <span class="doctag">@Override</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Override &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="单值注解"><a href="#单值注解" class="headerlink" title="单值注解"></a>单值注解</h4><blockquote>
<p>我们用到的@SuppressWarnings注解就是一个单值注解。那我们进入到它的源码看一下是怎么个情况。其实，和标记注解比较，它就多一个value参数而已，而这就是单值注解的必要条件，即只有一个参数。并且这一个参数为value时，我们可以省略value。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.annotation.ElementType.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Josh Bloch</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.5</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@jls</span> 4.8 Raw Types</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@jls</span> 4.12.2 Variables of Reference Type</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@jls</span> 5.1.9 Unchecked Conversion</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@jls</span> 5.5.2 Checked Casts and Unchecked Casts</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@jls</span> 9.6.4.5 <span class="doctag">@SuppressWarnings</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE, MODULE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SuppressWarnings &#123;</span><br><span class="line">    String[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="完整注解"><a href="#完整注解" class="headerlink" title="完整注解"></a>完整注解</h4><blockquote>
<p>有多个参数，每个参数都需要明确指定。</p>
<ul>
<li><p>参数可以是 <strong>基本类型</strong>、<strong>字符串</strong>、<strong>枚举</strong>、<strong>类对象</strong> 或 <strong>其他注解</strong>。</p>
</li>
<li><p>所有参数都需要在注解使用时赋值，除非参数定义了默认值。</p>
</li>
<li><p>例如：@RequestMapping（Spring 中）：用于映射 HTTP 请求。</p>
<ul>
<li><pre><code class="java">@RequestMapping(
    value = &quot;/home&quot;,
    method = RequestMethod.GET,
    produces = &quot;application/json&quot;
)
public String home() &#123;
    return &quot;Welcome to the home page&quot;;
&#125;
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">```java</span><br><span class="line">package org.springframework.web.bind.annotation;</span><br><span class="line"></span><br><span class="line">import java.lang.annotation.Documented;</span><br><span class="line">import java.lang.annotation.ElementType;</span><br><span class="line">import java.lang.annotation.Retention;</span><br><span class="line">import java.lang.annotation.RetentionPolicy;</span><br><span class="line">import java.lang.annotation.Target;</span><br><span class="line">import org.springframework.core.annotation.AliasFor;</span><br><span class="line"></span><br><span class="line">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">@Mapping</span><br><span class="line">public @interface RequestMapping &#123;</span><br><span class="line">   String name() default &quot;&quot;;</span><br><span class="line"></span><br><span class="line">   @AliasFor(&quot;path&quot;)</span><br><span class="line">   String[] value() default &#123;&#125;;</span><br><span class="line"></span><br><span class="line">   @AliasFor(&quot;value&quot;)</span><br><span class="line">   String[] path() default &#123;&#125;;</span><br><span class="line"></span><br><span class="line">   RequestMethod[] method() default &#123;&#125;;</span><br><span class="line"></span><br><span class="line">   String[] params() default &#123;&#125;;</span><br><span class="line"></span><br><span class="line">   String[] headers() default &#123;&#125;;</span><br><span class="line"></span><br><span class="line">   String[] consumes() default &#123;&#125;;</span><br><span class="line"></span><br><span class="line">   String[] produces() default &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="注解、反射与动态代理"><a href="#注解、反射与动态代理" class="headerlink" title="注解、反射与动态代理"></a>注解、反射与动态代理</h2><h3 id="使用反射机制解析注解"><a href="#使用反射机制解析注解" class="headerlink" title="使用反射机制解析注解"></a>使用反射机制解析注解</h3><p>自定义注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span> <span class="comment">// 要想使用反射解析必须是RUNTIME</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Sign &#123;</span><br><span class="line">    String <span class="title function_">methodName</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    String <span class="title function_">className</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Cat：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;猫吃鱼&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>准备好，上述代码后，我们就可以开始编写使用反射技术来解析注解的测试类。如下：</p>
<p>首先，我们先通过反射来获取注解中的methodName和className参数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.mylifes1110.anno.Sign;</span><br><span class="line"><span class="meta">@Sign(className = &quot;com.mylifes1110.java.Cat&quot;, methodName = &quot;eat&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SignTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//获取该类的类对象</span></span><br><span class="line">        Class&lt;SignTest&gt; signTestClass = SignTest.class;</span><br><span class="line">        <span class="comment">//获取类对象中的注解对象</span></span><br><span class="line">        <span class="comment">//原理实际上是在内存中生成了一个注解接口的子类实现对象</span></span><br><span class="line">        <span class="type">Sign</span> <span class="variable">sign</span> <span class="operator">=</span> signTestClass.getAnnotation(Sign.class);</span><br><span class="line">        <span class="comment">//调用注解对象中定义的抽象方法（注解中的属性）来获取返回值</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> sign.className();</span><br><span class="line">        <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> sign.methodName();</span><br><span class="line">        System.out.println(className);</span><br><span class="line">        System.out.println(methodName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong> 获取类对象中的注解对象时，其原理实际上是在内存中生成了一个注解接口的子类实现对象并返回的字符串内容。如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SignImpl</span> <span class="keyword">implements</span> <span class="title class_">Sign</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">methodName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;eat&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">className</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;com.mylifes1110.java.Cat&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完整代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.mylifes1110.anno.Sign;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Sign(className = &quot;com.mylifes1110.java.Cat&quot;, methodName = &quot;eat&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SignTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException &#123;</span><br><span class="line">        <span class="comment">//获取该类的类对象</span></span><br><span class="line">        Class&lt;SignTest&gt; signTestClass = SignTest.class;</span><br><span class="line">        <span class="comment">//获取类对象中的注解对象</span></span><br><span class="line">        <span class="comment">//原理实际上是在内存中生成了一个注解接口的子类实现对象</span></span><br><span class="line">        <span class="type">Sign</span> <span class="variable">sign</span> <span class="operator">=</span> signTestClass.getAnnotation(Sign.class);</span><br><span class="line">        <span class="comment">//调用注解对象中定义的抽象方法（注解中的属性）来获取返回值</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> sign.className();</span><br><span class="line">        <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> sign.methodName();</span><br><span class="line">        <span class="comment">//获取className名称的类对象</span></span><br><span class="line">        Class&lt;?&gt; clazz = Class.forName(className);</span><br><span class="line">        <span class="comment">//创建对象</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> clazz.newInstance();</span><br><span class="line">        <span class="comment">//获取methodName名称的方法对象</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> clazz.getMethod(methodName);</span><br><span class="line">        <span class="comment">//执行该方法</span></span><br><span class="line">        method.invoke(o);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注解与动态代理"><a href="#注解与动态代理" class="headerlink" title="注解与动态代理"></a>注解与动态代理</h3><blockquote>
<p><strong>Java 注解</strong> 和 <strong>动态代理</strong> 是两个独立的功能，但在实际开发中，这两者常被结合使用，尤其是在框架开发（如 Spring、MyBatis）中，动态代理通过解析注解实现功能增强。以下从基础到结合使用的原理和实现逐步展开讲解。</p>
</blockquote>
<h4 id="1-注解的作用"><a href="#1-注解的作用" class="headerlink" title="1. 注解的作用"></a><strong>1. 注解的作用</strong></h4><p>注解本质上是 <strong>元数据</strong>，用于标记类、方法、字段等，并可以附加额外信息。注解的主要功能是：</p>
<ul>
<li>在 <strong>编译期</strong> 提供信息（通过 APT）；</li>
<li>在 <strong>运行时</strong> 提供信息（通过反射）；</li>
<li>用于扩展框架功能（如依赖注入、事务管理）；</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> LogExecution &#123;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;Executing method&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-动态代理的作用"><a href="#2-动态代理的作用" class="headerlink" title="2. 动态代理的作用"></a><strong>2. 动态代理的作用</strong></h4><p>动态代理是 Java 提供的一种 <strong>动态生成代理类</strong> 的机制，用于在运行时对目标方法进行增强，例如添加日志、事务处理、权限校验等。</p>
<ul>
<li><strong>代理模式</strong>：通过代理对象访问目标对象。</li>
<li><strong>动态代理的特点</strong>：<ul>
<li><strong>JDK 动态代理</strong>：只能代理实现了接口的类。</li>
<li><strong>CGLIB 动态代理</strong>：可代理类本身（通过子类继承方式）。</li>
</ul>
</li>
</ul>
<p>JDK 动态代理实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Service</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">perform</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RealService</span> <span class="keyword">implements</span> <span class="title class_">Service</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">perform</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;RealService performing...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProxyHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ProxyHandler</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Before method call...&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line">        System.out.println(<span class="string">&quot;After method call...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DynamicProxyDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Service</span> <span class="variable">realService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RealService</span>();</span><br><span class="line">        <span class="type">Service</span> <span class="variable">proxy</span> <span class="operator">=</span> (Service) Proxy.newProxyInstance(</span><br><span class="line">                realService.getClass().getClassLoader(),</span><br><span class="line">                realService.getClass().getInterfaces(),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ProxyHandler</span>(realService)</span><br><span class="line">        );</span><br><span class="line">        proxy.perform();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<blockquote>
<p>Before method call…<br>RealService performing…<br>After method call…</p>
</blockquote>
<h4 id="3-注解与动态代理的结合"><a href="#3-注解与动态代理的结合" class="headerlink" title="3. 注解与动态代理的结合"></a><strong>3. 注解与动态代理的结合</strong></h4><p>在实际开发中，动态代理通过读取注解的元数据来实现特定逻辑，例如：</p>
<ul>
<li><strong>日志增强</strong>：根据注解添加日志功能。</li>
<li><strong>权限校验</strong>：通过注解标记需要校验的方法。</li>
<li><strong>事务管理</strong>：基于注解动态开启或关闭事务。</li>
</ul>
<p>使用注解标记方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RealService</span> <span class="keyword">implements</span> <span class="title class_">Service</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">perform</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;RealService performing...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在代理类中通过反射读取注解信息，并在执行目标方法前后添加逻辑</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LogInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LogInvocationHandler</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">// 检查是否存在 LogExecution 注解</span></span><br><span class="line">        <span class="keyword">if</span> (method.isAnnotationPresent(LogExecution.class)) &#123;</span><br><span class="line">            <span class="type">LogExecution</span> <span class="variable">logExecution</span> <span class="operator">=</span> method.getAnnotation(LogExecution.class);</span><br><span class="line">            System.out.println(<span class="string">&quot;Before method: &quot;</span> + logExecution.value());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行目标方法</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 方法后增强逻辑</span></span><br><span class="line">        System.out.println(<span class="string">&quot;After method execution&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用动态代理生成代理对象，并执行增强功能：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnnotationProxyDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Service</span> <span class="variable">realService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RealService</span>();</span><br><span class="line">        <span class="type">Service</span> <span class="variable">proxy</span> <span class="operator">=</span> (Service) Proxy.newProxyInstance(</span><br><span class="line">                realService.getClass().getClassLoader(),</span><br><span class="line">                realService.getClass().getInterfaces(),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">LogInvocationHandler</span>(realService)</span><br><span class="line">        );</span><br><span class="line">        proxy.perform();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="框架中的应用场景"><a href="#框架中的应用场景" class="headerlink" title="框架中的应用场景"></a>框架中的应用场景</h3><p><strong>Spring 框架中的注解与动态代理</strong></p>
<ul>
<li><p>事务管理（@Transactional）</p>
</li>
<li><p>Spring 使用动态代理拦截标记了 @Transactional 的方法，在调用方法前开启事务，方法执行后提交或回滚事务。</p>
</li>
<li><p>AOP（Aspect-Oriented Programming）</p>
<ul>
<li><p>通过注解（如 @Around, @Before）定义切面逻辑。</p>
</li>
<li><p>Spring 使用动态代理或 CGLIB 实现切面增强。</p>
</li>
</ul>
</li>
<li><p>日志记录（@Loggable）</p>
<ul>
<li>自定义注解配合动态代理实现方法调用的日志记录。</li>
</ul>
</li>
</ul>
<p><strong>MyBatis 中的注解与动态代理</strong></p>
<ul>
<li><p>MyBatis 使用动态代理生成 DAO 接口的实现类。</p>
</li>
<li><p>注解（如 @Select, @Insert）直接标记 SQL 查询，动态代理读取注解内容执行数据库操作。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
</search>
