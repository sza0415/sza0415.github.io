<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Go WEB | Ziang Sun's Blog</title><meta name="author" content="Ziang Sun"><meta name="copyright" content="Ziang Sun"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="HTTP 简介 HTTP 是一种无状态、由文本构成的请求-响应（request-response）协议，这种协议使用的是客户端-服务器（client-server）计算模型。   请求-响应是两台计算机进行通信的基本方式，其中一台计算机会向另一台计算机发送请求，而接收到请求的计算机则会对请求进行响应。在客户端-服务器计算模型中，发送请求的一方（客户端）负责向返回响应的一方（服务器）发起会话，而服务">
<meta property="og:type" content="article">
<meta property="og:title" content="Go WEB">
<meta property="og:url" content="https://sza0415.github.io/GowebProgramming/index.html">
<meta property="og:site_name" content="Ziang Sun&#39;s Blog">
<meta property="og:description" content="HTTP 简介 HTTP 是一种无状态、由文本构成的请求-响应（request-response）协议，这种协议使用的是客户端-服务器（client-server）计算模型。   请求-响应是两台计算机进行通信的基本方式，其中一台计算机会向另一台计算机发送请求，而接收到请求的计算机则会对请求进行响应。在客户端-服务器计算模型中，发送请求的一方（客户端）负责向返回响应的一方（服务器）发起会话，而服务">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://sza0415.github.io/img/image1.png">
<meta property="article:published_time" content="2025-03-08T16:00:00.000Z">
<meta property="article:modified_time" content="2025-03-09T11:06:26.439Z">
<meta property="article:author" content="Ziang Sun">
<meta property="article:tag" content="GO">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://sza0415.github.io/img/image1.png"><link rel="shortcut icon" href="/img/image1.png"><link rel="canonical" href="https://sza0415.github.io/GowebProgramming/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":3,"unescape":false,"languages":{"hits_empty":"No results found for: ${query}","hits_stats":"${hits} articles found"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Go WEB',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/image1.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">16</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">5</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">1</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-book"></i><span> 文章</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/contact/"><i class="fa-fw fas fa-comments"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/img/image1.png" alt="Logo"><span class="site-name">Ziang Sun's Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">Go WEB</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> Search</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-book"></i><span> 文章</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/contact/"><i class="fa-fw fas fa-comments"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Go WEB</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2025-03-08T16:00:00.000Z" title="Created 2025-03-09 00:00:00">2025-03-09</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2025-03-09T11:06:26.439Z" title="Updated 2025-03-09 19:06:26">2025-03-09</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%BC%96%E7%A8%8B/">编程</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word Count:</span><span class="word-count">3.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading Time:</span><span>12mins</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h2 id="HTTP-简介"><a href="#HTTP-简介" class="headerlink" title="HTTP 简介"></a>HTTP 简介</h2><blockquote>
<p>HTTP 是一种无状态、由文本构成的请求-响应（request-response）协议，这种协议使用的是客户端-服务器（client-server）计算模型。</p>
</blockquote>
<blockquote>
<p>请求-响应是两台计算机进行通信的基本方式，其中一台计算机会向另一台计算机发送请求，而接收到请求的计算机则会对请求进行响应。在客户端-服务器计算模型中，发送请求的一方（客户端）负责向返回响应的一方（服务器）发起会话，而服务器则负责为客户端提供服务。在 HTTP协议中，客户端也被称作用户代理（user-agent），而服务器则通常会被称为 Web 服务器。在大多数情况下，HTTP 客户端都是一个Web 浏览器。</p>
<p>HTTP 是一种无状态协议，它唯一知道的就是客户端会向服务器发送请求，而服务器则会向客户端返回响应，并且后续发生的请求对之前发生过的请求一无所知。相对的，像 FTP、Telnet这类面向连接的协议则会在客户端和服务器之间创建一个持续存在的通信通道（其中 Telnet 在进行通信时使用的也是请求-响应方式以及客户端-服务器计算模型）。顺带提一下，HTTP 1.1 也可以通过持久化连接来提升性能。</p>
<p>跟很多互联网协议一样，HTTP也是以纯文本方式而不是二进制方式发送和接收协议数据的。</p>
<p>这样做是为了让开发者可以在无需使用专门的协议分析工具的情况下，弄清楚通信中正在发生的事情，从而更容易进行故障排查。</p>
</blockquote>
<h2 id="HTTP-请求"><a href="#HTTP-请求" class="headerlink" title="HTTP 请求"></a>HTTP 请求</h2><p>HTTP 是一种请求-响应协议，协议涉及的所有事情都以一个请求开始。HTTP请求跟其他所有HTTP报文（message）一样，都由一系列文本行组成，这些文本行会按照以下顺序进行排列：</p>
<ol>
<li>请求行（request-line）；</li>
<li>零个或任意多个请求首部（header）；</li>
<li>一个空行；</li>
<li>可选的报文主体（body）。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GET /Protocols/rfc2616/rfc2616.html HTTP/1.1</span><br><span class="line">Host: www.w3.org</span><br><span class="line">User-Agent: Mozilla/5.0|</span><br><span class="line">(empty line)</span><br></pre></td></tr></table></figure>

<p>这个请求中的第一个文本行就是请求行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /Protocols/rfc2616/rfc2616.html HTTP/1.1</span><br></pre></td></tr></table></figure>

<p>请求行中的第一个单词为请求方法（request method），之后跟着的是统一资源标识符（UniformResource Identifier, URI）以及所的HTTP 版本。位于请求行之后的两个文本行为请求的首部。注意，这个报文的最后一行为空行，即使报文的主体部分为空，这个空行也必须存在，至于报文是否包含主体则需要根据请求使用的方法而定。</p>
<h3 id="请求方法"><a href="#请求方法" class="headerlink" title="请求方法"></a>请求方法</h3><p>请求方法是请求行中的第一个单词，它指明了客户端想要对资源执行的操作。HTTP O.9只有GET一个方法，HTTP 1.0 添加了 POST方法和 HEAD方法，而HTTP 1.1 则添加了 PUT、DELETE、OPTIONS、TRACE 和 CONNECT这5个方法，并允许开发者自行添加更多方法—很多人立即就把这个功能付诸实践了。</p>
<p>关于请求方法的一个有趣之处在于，HTTP 1.1 要求必须实现的只有GET 方法和 HEAD方法，</p>
<p>而其他方法的实现则是可选的，甚至连POST方法也是可选的。</p>
<p>各个 HTTP方法的作用说明如下：</p>
<blockquote>
<p>GET—命令服务器返回指定的资源。</p>
<p>HEAD—与 GET 方法的作用类似，唯一的不同在于这个方法不要求服务器返回报文的</p>
<p>主体。这个方法通常用于在不获取报文主体的情况下，取得响应的首部。</p>
<p>POST—命令服务器将报文主体中的数据传递给URI 指定的资源，至于服务器具体会对</p>
<p>这些数据执行什么动作则取决于服务器本身。</p>
<p>PUT—命令服务器将报文主体中的数据设置为URI 指定的资源。如果 URI 指定的位置上已经有数据存在，那么使用报文主体中的数据去代替已有的数据。如果资源尚未存在，那么在 URI 指定的位置上新创建一个资源。</p>
<p>DELETE—命令服务器删除URI 指定的资源</p>
<p>TRACE——命令服务器返回请求本身。通过这个方法，客户端可以知道介于它和服务器之间的其他服务器是如何处理请求的。</p>
<p>﻿﻿OPTIONS—命令服务器返回它支持的 HTTP方法列表。</p>
<p>﻿﻿CONNECT—命令服务器与客户端建立一个网络连接。这个方法通常用于设置SSL 隧道以开启 HTTPS功能。</p>
<p>﻿﻿PATCH——命令服务器使用报文主体中的数据对 URI 指定的资源进行修改。</p>
</blockquote>
<h3 id="浏览器对请求方法的支持"><a href="#浏览器对请求方法的支持" class="headerlink" title="浏览器对请求方法的支持"></a>浏览器对请求方法的支持</h3><p>GET 方法是最基本的HTTP 方法，它负责从服务器上获取内容，所有浏览器都支持这个方法。POST 方法从 HTMIL 2.0 开始可以通过添加 HTML 表单来实现：HTML 的form 标签有一个名为method 的属性，用户可以通过将这个属性的值设置为 get 或者post 来指定要使用哪种方法。</p>
<p>HTML 不支持除 GET 和 POST之外的其他HTTP 方法：在 HTML5 规范的早期草案中，HTML表单的method 属性曾经添加过对 PUT 方法和 DBLBTE 方法的支持，但这些支持在之后又被删除了。</p>
<p>话虽如此，但流行的浏览器通常都不会只支持 HTML 一种数据格式——用户可以使用XMLHttpRequest （XHR） 来获得对 PUT方法和 DEITE 方法的支持。XHR 是一系列浏览器 API，这些 API 通常由 JavaScript 包裹（实际上 XHR 就是一个名为 XMLHttpRequest 的浏览器对象）。</p>
<p>XHR 允许程序员向服务器发送 HTTP 请求，并且跟“XMILHttpRequest” 这个名字所暗示的不一样，这项技术并不仅仅局限于 XML格式—包括JSON以及纯文本在内的任何格式的请求和响应都可以通过XHR发送。</p>
<h3 id="请求首部"><a href="#请求首部" class="headerlink" title="请求首部"></a>请求首部</h3><p>HTTP 请求方法定义了发送请求的客户端想要执行的动作，而HTTP 请求的首部则记录了与请求本身以及客户端有关的信息。请求的首部由任意多个用冒号分隔的纯文本键值对组成，最后以回车（CR）和换行（LF）结尾。</p>
<p>作为 HTTP 1.1 RFC 的一部分，RFC 7231 对主要的一些 HTTP 请求字段（request field）进行了标准化。过去，非标准的HTTP 请求通常以×-作为前缀，但标准并没有沿用这一惯例。</p>
<p>大多数 HTTP 请求首部都是可选的，宿主（Host）首部字段是 HTTP 1.1 唯一强制要求的首部。根据请求使用的方法不同，如果请求的报文中包含有可选的主体，那么请求的首部还需要带有内容长度（Content-Length）字段或者传输编码（Transfer-Encoding）字段。表1-1展示了一些常见的请求首部。</p>
<table>
<thead>
<tr>
<th align="center">首部字段</th>
<th align="center">作用描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Accept</td>
<td align="center">客户端在 HTTP 响应中能够接收的内容类型。比如说，客户端可以通过 Accept： text&#x2F;html 这个首部，告知服务器自己希望在响应的主体中收到 HTML 类型的内容</td>
</tr>
<tr>
<td align="center">Accept-Charset</td>
<td align="center">客户端要求服务器使用的字符集编码。比如说，客户端可以通过 Accept-Charset： utf-8这个首部，告知服务器自己希望响应的主体使用UTF-8字符集</td>
</tr>
<tr>
<td align="center">Authorization</td>
<td align="center">这个首部用于向服务器发送基本的身份验证证书</td>
</tr>
<tr>
<td align="center">Cookie</td>
<td align="center">客户端应该在这个首部中把服务器之前设置的所有 cookie 回传给服务器。比如说，如果服务器之前在浏览器上设置了3个 cookie，那么 Cookie 首部字段将在一个字符串里面包含这3个 cookie，并使用分号对这些 cookie 进行分隔。以下是一个 Cookie 首部示 9: Cookie: my_first_cookie&#x3D;hello; my_second_cookie&#x3D;world</td>
</tr>
<tr>
<td align="center">Content-Length</td>
<td align="center">请求主体的字节长度</td>
</tr>
<tr>
<td align="center">Content-Type</td>
<td align="center">当请求包含主体的时候，这个首部用于记录主体内容的类型。在发送 POST 或 PUT 请求时，内容的类型默认为 x-ww-form-urlen-coded，但是在上传文件时，内容的类型应该设置为 multipart&#x2F;form-data（上传文件这一操作可以通过将 input 标签的类型设置为 王ile 来实现）</td>
</tr>
<tr>
<td align="center">Host</td>
<td align="center">服务器的名字以及端口号。如果这个首部没有记录服务器的端口号，就表示服务器使用的是 80端口</td>
</tr>
<tr>
<td align="center">Referrer</td>
<td align="center">发起请求的页面所在的地址</td>
</tr>
<tr>
<td align="center">User-Agent</td>
<td align="center">对发起请求的客户端进行描述</td>
</tr>
</tbody></table>
<h2 id="HTTP-响应"><a href="#HTTP-响应" class="headerlink" title="HTTP 响应"></a>HTTP 响应</h2><p>HTTP 响应报文是对 HTTP 请求报文的回复。跟HTTP 请求一样，HTTP 响应也是由一系列</p>
<p>文本行组成的，其中包括：</p>
<ol>
<li>一个状态行</li>
<li>零个或任意数量的响应首部</li>
<li>一个空行</li>
<li>一个可选的报文主体</li>
</ol>
<p>也许你已经发现了，HTTP 响应的组织方式跟 HTTP 请求的组织方式是完全相同的。以下是一个典型的HTTP 响应的样子（为了节省篇幅，我们省略了报文主体中的部分内容）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">200 OK</span><br><span class="line">Date: Sat, 22 Nov 2014</span><br><span class="line">12:58:58</span><br><span class="line">GMT</span><br><span class="line">Server: Apache/2</span><br><span class="line">Last-Modified: Thu, 28 Aug 2014 21:01:33</span><br><span class="line">GMT</span><br><span class="line">Content-Length: 33115</span><br><span class="line">Content-Type: text/html; charset=iso-8859-1|</span><br><span class="line">&lt;! DOCTYPE html PUBLIC</span><br><span class="line">&quot;-//W3C//DTD XHTML 1.0 Strict//EN&quot; &quot;http://www.w3.org/</span><br><span class="line">TR/xhtm11/DTD/xhtmll-strict.dtd&quot;&gt; &lt;html xmlns=&#x27;http://www.w3.org/1999/</span><br><span class="line">xhtml&#x27;&gt; ‹head&gt;&lt;title&gt;Hypertext Transfer Protocol -- HTTP/1.1&lt;/title&gt;&lt;/ head&gt;&lt;body&gt;...&lt;/body&gt;&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>HTTP 响应的第一行为状态行，这个文本行包含了状态码（status code）和相应的原因短语（reason phrase），原因短语对状态码进行了简单的描述。除此之外，这个例子中的 HTTP 响应还包含了一个HTML格式的报文主体。</p>
<h3 id="响应状态码"><a href="#响应状态码" class="headerlink" title="响应状态码"></a>响应状态码</h3><p>正如之前所说，HTTP 响应中的状态码表明了响应的类型。HTTP 响应状态码共有5种类型，</p>
<p>它们分别以不同的数字作为前缀。</p>
<table>
<thead>
<tr>
<th align="center">状态码类型</th>
<th align="center">作用描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1XX</td>
<td align="center">情报状态码。服务器通过这些状态码来告知客户端，自己已经接收到了客户端发送的请求，并且已经对请求进行了处理</td>
</tr>
<tr>
<td align="center">2XX</td>
<td align="center">成功状态码。这些状态码说明服务器已经接收到了客户端发送的请求，并且己经成功地对请求进行了处理。这类状态码的标准响应为“200OK”</td>
</tr>
<tr>
<td align="center">3XX</td>
<td align="center">重定向状态码。这些状态码表示服务器已经接收到了客户端发送的请求，并且已经成功处理了请求，但为了完成请求指定的动作，客户端还需要再做一些其他工作。 这类状态码大多用于实现 URL 重定向</td>
</tr>
<tr>
<td align="center">4XX</td>
<td align="center">客户端错误状态码。这类状态码说明客户端发送的请求出现了某些问题。在这一类型的状态码中，最常见的就是“404 Not Found”了，这个状态码表示服务器无法从请求指定的 URL 中找到客户端想要的资源</td>
</tr>
<tr>
<td align="center">5XX</td>
<td align="center">服务器错误状态码。当服务器因为某些原因而无法正确地处理请求时，服务器就会使用这类状态码来通知客户端。在这一类状态码中，最常见的就是“500 InternalServer Error”状态码了</td>
</tr>
</tbody></table>
<h3 id><a href="#" class="headerlink" title></a></h3><h2 id="Web应用的各个组成部分"><a href="#Web应用的各个组成部分" class="headerlink" title="Web应用的各个组成部分"></a>Web应用的各个组成部分</h2><p>Web应用是一个执行以下任务的程序：</p>
<ol>
<li>通过HTTP 协议，以HTTP 请求报文的形式获取客户端输人</li>
<li>对HTTP 请求报文进行处理，并执行必要的操作</li>
<li>生成 HTML，并以 HTTP 响应报文的形式将其返回给客户端</li>
</ol>
<p>为了完成这些任务，Web 应用被分成了处理器（handler） 和模板引擎（template engine）这两个部分。</p>
<h3 id="处理器handler"><a href="#处理器handler" class="headerlink" title="处理器handler"></a>处理器handler</h3><p>web 应用中的处理器除了要接收和处理客户端发来的请求，还需要调用模板引擎，然后由模板引擎生成 HTML 并把数据填充至将要回传给客户端的响应报文当中。</p>
<p>用MVC 模式来讲，处理器既是控制器（controller），也是模型（model）。在理想的 MVC模式实现中，控制器应该是“苗条的”，它应该只包含路由（routing）代码以及 HTTP 报文的解包和打包逻辑；而模型则应该是“丰满的”，它应该包含应用的逻辑以及数据。</p>
<blockquote>
<p>“模型-视图-控制器”模式</p>
<p>模型-视图一控制器（Model-View-Controller, MVC）模式是编写Web应用时常用的模式，这个模式是如此的流行，以至于人们有时候会错误地把这一模式当成了Web应用开发本身。</p>
<p>实际上，MVC模式最初是在20世纪70年代未的施乐帕罗奥多研究中心（Xerox PARC）被引入到Smaltalk语言里面的，这一模式将程序分成了模型、视图和控制器3个部分，其中模型用于表示底层的数据，而视图则以可视化的方式向用户展示模型，至于控制器则会根据用户的输入对模型进行修改。每当模型发生变化时，视图都会自动进行更新，从而展现出模型的最新状态。</p>
<p>尽管 MVC模式起源于桌面开发，但它在编写Web 应用方面也流行了起来一包括 Ruby on Rails、</p>
<p>Codelgniter、Play 和 Spring MVC在内的很多Web 应用框架都把MVC用作它们的基本模式。在这些框架里面，模型一般都会通过结构（struct）或对象（object）映射（map）到数据库，而视图则会被渲染为 HTML，至于控制器则负责对请求进行路由，并管理对模型的访问。</p>
<p>使用MVC框架进行Web应用开发的新手程序员常常会误以为MVC模式是开发Web 应用的唯一方法，但Web 应用本质上只是一个通过HTTP 协议与用户互动的程序，只要能够实现这种互动，程序本身可以使用任何一种模式开发，甚至不使用模式也是可以的。</p>
</blockquote>
<p>为了防止模型变得过于臃肿，并且出于代码复用的需要，开发者有时候会使用服务对象（service object ）或者函数（function）对模型进行操作。尽管服务对象严格来说并不是 MVC模式的一部分，但是通过把相同的逻辑放置到服务对象里面，并将同一个服务对象应用到不同的模型之上，可以有效地避免在多个模型里面复制相同代码的窘境。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="https://sza0415.github.io">Ziang Sun</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://sza0415.github.io/GowebProgramming/">https://sza0415.github.io/GowebProgramming/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/GO/">GO</a></div><div class="post-share"><div class="social-share" data-image="/img/image1.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related full-width" href="/go%20package%20module%20work/" title="go package module work"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">Next</div><div class="info-item-2">go package module work</div></div><div class="info-2"><div class="info-item-1">package 定义  包是 Go 语言的基本组织单元，用于将代码分组。每个 Go 文件都必须属于一个包，包名通常在文件顶部通过 package 关键字声明。 包可以包含多个 .go 文件，这些文件共享相同的包名，并位于同一目录下。  用途  代码复用：通过包可以将功能模块化，方便在不同项目中复用。 命名空间：包提供命名空间，防止命名冲突。例如，math 包中的 Sin 函数不会与 time 包中的 Sleep 函数冲突。 访问控制：包内的标识符可以根据首字母大小写控制访问权限（大写为公开，小写为私有）。   12345678// math.gopackage mathutilimport &quot;math&quot;func Add(a, b float64) float64 &#123;    return a + b&#125;  123456789// main.gopackage mainimport &quot;yourproject/mathutil&quot;func main() &#123;    result := mathutil.Add(3.0,...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/Go%E8%AF%AD%E6%B3%95%EF%BC%9ARange%E7%9A%84%E4%BD%BF%E7%94%A8/" title="Go语法：range的使用"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-01</div><div class="info-item-2">Go语法：range的使用</div></div><div class="info-2"><div class="info-item-1"> 转载+修改：https://lewinblog.com/blog/page/2019/191216-Go%E8%AF%AD%E6%B3%95-Range%E7%9A%84%E4%BD%BF%E7%94%A8.md  语法定义 range iterates over elements in a variety of data structures.  range可以遍历多种数据结构体的元素。包括『数组array』、『切片slice』、『字典map』、『字符串string』等，还有一个比较特殊的『通道chan』。 数组与切片这个是最基础的了吧。常用形式是for i := range s &#123;&#125;，此时只遍历索引；还有for i, n := range s &#123;&#125;同时获取索引和元素值；如果只要元素值，用for _, n := range s &#123;&#125;。 我个人经验是，把range看成一个函数，可以破解一切问题： 1func Range(s iterable) (index int, value int)...</div></div></div></a><a class="pagination-related" href="/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/" title="go 语言学习"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-01</div><div class="info-item-2">go 语言学习</div></div><div class="info-2"><div class="info-item-1">引用类型（reference type）特指slice、map、channel new 函数new是go语言的内置函数，用于为制定类型分配内存，并返回一个指向该类型零值的指针。  适用于基本数据类型（如int、float64、bool等）以及结构体（struct）等类型。 不适用于切片（slice）、映射（map）、和通道（channel）引用类型的初始化，因为new仅分配内存并返回指向零值的指针，不会初始化这些类型的内部数据结构。 返回值：指向所分配类型的指针，例如：*int、*struct  12345678910package mainimport &quot;fmt&quot;func main() &#123;    p := new(int)    // 为 int 类型分配内存，返回 *int    fmt.Println(*p)  // 输出 0（int 的零值）    *p = 10          // 通过指针修改值    fmt.Println(*p)  // 输出 10&#125;  make 函数make是 Go...</div></div></div></a><a class="pagination-related" href="/Go_Slices_usage_and_internals/" title="Go 切片：用法和内部机制"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-01</div><div class="info-item-2">Go 切片：用法和内部机制</div></div><div class="info-2"><div class="info-item-1"> 翻译+截取：https://go.dev/blog/slices-intro  Go 切片：用法和内部机制 Andrew Gerrand 安德鲁·杰拉德5 January 2011   Arrays切片类型是在 Go 的数组类型之上构建的一个抽象，因此要理解切片，我们首先必须理解数组。 数组类型定义指定了长度和元素类型。例如，类型 [4]int 表示一个包含四个整数的数组。数组的大小是固定的；其长度是其类型的一部分（ [4]int 和 [5]int 是不同的、不兼容的类型）。数组可以按常规方式索引，因此表达式 s[n] 访问从零开始的第 n 个元素。 1234var a [4]inta[0] = 1i := a[0]// i == 1  数组不需要显式初始化；数组的零值是一个可直接使用的数组，其元素本身为零： 1// a[2] == 0, the zero value of the int type  内存中 [4]int 的表示只是四个按顺序排列的整数值：   Go 的数组是值。数组变量表示整个数组；它不是指向第一个数组元素的指针（如在 C...</div></div></div></a><a class="pagination-related" href="/go%20package%20module%20work/" title="go package module work"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-09</div><div class="info-item-2">go package module work</div></div><div class="info-2"><div class="info-item-1">package 定义  包是 Go 语言的基本组织单元，用于将代码分组。每个 Go 文件都必须属于一个包，包名通常在文件顶部通过 package 关键字声明。 包可以包含多个 .go 文件，这些文件共享相同的包名，并位于同一目录下。  用途  代码复用：通过包可以将功能模块化，方便在不同项目中复用。 命名空间：包提供命名空间，防止命名冲突。例如，math 包中的 Sin 函数不会与 time 包中的 Sleep 函数冲突。 访问控制：包内的标识符可以根据首字母大小写控制访问权限（大写为公开，小写为私有）。   12345678// math.gopackage mathutilimport &quot;math&quot;func Add(a, b float64) float64 &#123;    return a + b&#125;  123456789// main.gopackage mainimport &quot;yourproject/mathutil&quot;func main() &#123;    result := mathutil.Add(3.0,...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> Comments</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/image1.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Ziang Sun</div><div class="author-info-description">直到有另一个人 能体会我的感觉</div><div class="site-data"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">16</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">5</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">1</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/sza0415"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP-%E7%AE%80%E4%BB%8B"><span class="toc-number">1.</span> <span class="toc-text">HTTP 简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP-%E8%AF%B7%E6%B1%82"><span class="toc-number">2.</span> <span class="toc-text">HTTP 请求</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95"><span class="toc-number">2.1.</span> <span class="toc-text">请求方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AF%B9%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95%E7%9A%84%E6%94%AF%E6%8C%81"><span class="toc-number">2.2.</span> <span class="toc-text">浏览器对请求方法的支持</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E9%A6%96%E9%83%A8"><span class="toc-number">2.3.</span> <span class="toc-text">请求首部</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP-%E5%93%8D%E5%BA%94"><span class="toc-number">3.</span> <span class="toc-text">HTTP 响应</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%8D%E5%BA%94%E7%8A%B6%E6%80%81%E7%A0%81"><span class="toc-number">3.1.</span> <span class="toc-text">响应状态码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">3.2.</span> <span class="toc-text"></span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Web%E5%BA%94%E7%94%A8%E7%9A%84%E5%90%84%E4%B8%AA%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86"><span class="toc-number">4.</span> <span class="toc-text">Web应用的各个组成部分</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E5%99%A8handler"><span class="toc-number">4.1.</span> <span class="toc-text">处理器handler</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Posts</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/GowebProgramming/" title="Go WEB">Go WEB</a><time datetime="2025-03-08T16:00:00.000Z" title="Created 2025-03-09 00:00:00">2025-03-09</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/go%20package%20module%20work/" title="go package module work">go package module work</a><time datetime="2025-03-08T16:00:00.000Z" title="Created 2025-03-09 00:00:00">2025-03-09</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/Go%E8%AF%AD%E6%B3%95%EF%BC%9ARange%E7%9A%84%E4%BD%BF%E7%94%A8/" title="Go语法：range的使用">Go语法：range的使用</a><time datetime="2025-02-28T16:00:00.000Z" title="Created 2025-03-01 00:00:00">2025-03-01</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/" title="go 语言学习">go 语言学习</a><time datetime="2025-02-28T16:00:00.000Z" title="Created 2025-03-01 00:00:00">2025-03-01</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/Go_Slices_usage_and_internals/" title="Go 切片：用法和内部机制">Go 切片：用法和内部机制</a><time datetime="2025-02-28T16:00:00.000Z" title="Created 2025-03-01 00:00:00">2025-03-01</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By Ziang Sun</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="Scroll to Comments"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.isShuoshuo
  const option = {"language":"zh-CN","perPage":10,"distractionFreeMode":false,"createIssueManually":true}

  const commentCount = n => {
    const isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
    if (isCommentCount) {
      isCommentCount.textContent= n
    }
  }

  const initGitalk = (el, path) => {
    if (isShuoshuo) {
      window.shuoshuoComment.destroyGitalk = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }

    const gitalk = new Gitalk({
      clientID: 'Ov23li1nXnygRWmrL22n',
      clientSecret: 'fdcfbe11c7b66e8cbfe98aeb17100017159cb6d5',
      repo: 'sza0415.github.io',
      owner: 'sza0415',
      admin: ['sza0415'],
      updateCountCallback: commentCount,
      ...option,
      id: isShuoshuo ? path : (option && option.id) || 'eae43774efb4378536a6893b02df5411'
    })

    gitalk.render('gitalk-container')
  }

  const loadGitalk = async(el, path) => {
    if (typeof Gitalk === 'function') initGitalk(el, path)
    else {
      await btf.getCSS('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css')
      await btf.getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js')
      initGitalk(el, path)
    }
  }

  if (isShuoshuo) {
    'Gitalk' === 'Gitalk'
      ? window.shuoshuoComment = { loadComment: loadGitalk }
      : window.loadOtherComment = loadGitalk
    return
  }

  if ('Gitalk' === 'Gitalk' || !false) {
    if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
    else loadGitalk()
  } else {
    window.loadOtherComment = loadGitalk
  }
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">Search</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  Loading Database</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>