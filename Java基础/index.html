<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Java基础 | Ziang Sun's Blog</title><meta name="author" content="Ziang Sun"><meta name="copyright" content="Ziang Sun"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="多线程基础 source from https:&#x2F;&#x2F;liaoxuefeng.com&#x2F;books&#x2F;java&#x2F;threading&#x2F;basic&#x2F;index.html  现代操作系统（Windows，macOS，Linux）都可以执行多任务。多任务就是同时运行多个任务。 CPU执行代码都是一条一条顺序执行的，但是，即使是单核cpu，也可以同时运行多个任务。因为操作系统执行多任务实际上就是让CPU对多个任务">
<meta property="og:type" content="article">
<meta property="og:title" content="Java基础">
<meta property="og:url" content="https://sza0415.github.io/Java%E5%9F%BA%E7%A1%80/index.html">
<meta property="og:site_name" content="Ziang Sun&#39;s Blog">
<meta property="og:description" content="多线程基础 source from https:&#x2F;&#x2F;liaoxuefeng.com&#x2F;books&#x2F;java&#x2F;threading&#x2F;basic&#x2F;index.html  现代操作系统（Windows，macOS，Linux）都可以执行多任务。多任务就是同时运行多个任务。 CPU执行代码都是一条一条顺序执行的，但是，即使是单核cpu，也可以同时运行多个任务。因为操作系统执行多任务实际上就是让CPU对多个任务">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://sza0415.github.io/img/image1.png">
<meta property="article:published_time" content="2024-11-03T09:34:50.963Z">
<meta property="article:modified_time" content="2024-11-28T12:21:45.197Z">
<meta property="article:author" content="Ziang Sun">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://sza0415.github.io/img/image1.png"><link rel="shortcut icon" href="/img/image1.png"><link rel="canonical" href="https://sza0415.github.io/Java%E5%9F%BA%E7%A1%80/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":3,"unescape":false,"languages":{"hits_empty":"No results found for: ${query}","hits_stats":"${hits} articles found"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java基础',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/image1.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">7</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">1</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-book"></i><span> 文章</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/todo/"><i class="fa-fw fas fa-list-alt"></i><span> ToDo</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/contact/"><i class="fa-fw fas fa-comments"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/img/image1.png" alt="Logo"><span class="site-name">Ziang Sun's Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">Java基础</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> Search</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-book"></i><span> 文章</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/todo/"><i class="fa-fw fas fa-list-alt"></i><span> ToDo</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/contact/"><i class="fa-fw fas fa-comments"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Java基础</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2024-11-03T09:34:50.963Z" title="Created 2024-11-03 17:34:50">2024-11-03</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2024-11-28T12:21:45.197Z" title="Updated 2024-11-28 20:21:45">2024-11-28</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word Count:</span><span class="word-count">10.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading Time:</span><span>37mins</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="多线程基础"><a href="#多线程基础" class="headerlink" title="多线程基础"></a>多线程基础</h1><blockquote>
<p>source from <a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/threading/basic/index.html">https://liaoxuefeng.com/books/java/threading/basic/index.html</a></p>
</blockquote>
<p>现代操作系统（Windows，macOS，Linux）都可以执行多任务。多任务就是同时运行多个任务。</p>
<p>CPU执行代码都是一条一条顺序执行的，但是，即使是单核cpu，也可以同时运行多个任务。因为操作系统执行多任务实际上就是让CPU对多个任务轮流交替执行。</p>
<p>例如，假设我们有语文、数学、英语3门作业要做，每个作业需要30分钟。我们把这3门作业看成是3个任务，可以做1分钟语文作业，再做1分钟数学作业，再做1分钟英语作业。</p>
<p>类似的，操作系统轮流让多个任务交替执行，例如，让浏览器执行0.001秒，让QQ执行0.001秒，再让音乐播放器执行0.001秒，在人看来，CPU就是在同时执行多个任务。</p>
<p>即使是多核CPU，因为通常任务的数量远远多于CPU的核数，所以任务也是交替执行的。</p>
<h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>在计算机中，我们把一个任务称为一个进程，浏览器就是一个进程，视频播放器是另一个进程，类似的，音乐播放器和Word都是进程。</p>
<p>某些进程内部还需要同时执行多个子任务。例如，我们在使用Word时，Word可以让我们一边打字，一边进行拼写检查，同时还可以在后台进行打印，我们把子任务称为线程。</p>
<p>进程和线程的关系就是：一个进程可以包含一个或多个线程，但至少会有一个线程。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">                        ┌──────────┐</span><br><span class="line">                        │Process   │</span><br><span class="line">                        │┌────────┐│</span><br><span class="line">            ┌──────────┐││ Thread ││┌──────────┐</span><br><span class="line">            │Process   ││└────────┘││Process   │</span><br><span class="line">            │┌────────┐││┌────────┐││┌────────┐│</span><br><span class="line">┌──────────┐││ Thread ││││ Thread ││││ Thread ││</span><br><span class="line">│Process   ││└────────┘││└────────┘││└────────┘│</span><br><span class="line">│┌────────┐││┌────────┐││┌────────┐││┌────────┐│</span><br><span class="line">││ Thread ││││ Thread ││││ Thread ││││ Thread ││</span><br><span class="line">│└────────┘││└────────┘││└────────┘││└────────┘│</span><br><span class="line">└──────────┘└──────────┘└──────────┘└──────────┘</span><br><span class="line">┌──────────────────────────────────────────────┐</span><br><span class="line">│               Operating System               │</span><br><span class="line">└──────────────────────────────────────────────┘</span><br></pre></td></tr></table></figure>

<p>操作系统调度的最小任务单位其实不是进程，而是线程。常用的Windows、Linux等操作系统都采用抢占式多任务，如何调度线程完全由操作系统决定，程序自己不能决定什么时候执行，以及执行多长时间。</p>
<p>因为同一个应用程序，既可以有多个进程，也可以有多个线程，因此，实现多任务的方法，有以下几种：</p>
<p>多进程模式（每个进程只有一个线程）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">┌──────────┐ ┌──────────┐ ┌──────────┐</span><br><span class="line">│Process   │ │Process   │ │Process   │</span><br><span class="line">│┌────────┐│ │┌────────┐│ │┌────────┐│</span><br><span class="line">││ Thread ││ ││ Thread ││ ││ Thread ││</span><br><span class="line">│└────────┘│ │└────────┘│ │└────────┘│</span><br><span class="line">└──────────┘ └──────────┘ └──────────┘</span><br></pre></td></tr></table></figure>

<p>多线程模式（一个进程有多个线程）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">┌────────────────────┐</span><br><span class="line">│Process             │</span><br><span class="line">│┌────────┐┌────────┐│</span><br><span class="line">││ Thread ││ Thread ││</span><br><span class="line">│└────────┘└────────┘│</span><br><span class="line">│┌────────┐┌────────┐│</span><br><span class="line">││ Thread ││ Thread ││</span><br><span class="line">│└────────┘└────────┘│</span><br><span class="line">└────────────────────┘</span><br></pre></td></tr></table></figure>

<p>多进程＋多线程模式（复杂度最高）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">┌──────────┐┌──────────┐┌──────────┐</span><br><span class="line">│Process   ││Process   ││Process   │</span><br><span class="line">│┌────────┐││┌────────┐││┌────────┐│</span><br><span class="line">││ Thread ││││ Thread ││││ Thread ││</span><br><span class="line">│└────────┘││└────────┘││└────────┘│</span><br><span class="line">│┌────────┐││┌────────┐││┌────────┐│</span><br><span class="line">││ Thread ││││ Thread ││││ Thread ││</span><br><span class="line">│└────────┘││└────────┘││└────────┘│</span><br><span class="line">└──────────┘└──────────┘└──────────┘</span><br></pre></td></tr></table></figure>

<h3 id="进程-vs-线程"><a href="#进程-vs-线程" class="headerlink" title="进程 vs 线程"></a>进程 vs 线程</h3><p>进程和线程是包含关系，但是多任务既可以由多进程实现，也可以由单进程内的多线程实现，还可以混合多进程＋多线程。</p>
<p>具体采用哪种方式，要考虑到进程和线程的特点。</p>
<p>和多线程相比，多进程的缺点在于：</p>
<ul>
<li>创建进程比创建线程开销大，尤其是在Windows系统上；</li>
<li>进程间通信比线程间通信要慢，因为线程间通信就是读写同一个变量，速度很快。</li>
</ul>
<p>而多进程的优点在于：</p>
<p>多进程稳定性比多线程高，因为在多进程的情况下，一个进程崩溃不会影响其他进程，而在多线程的情况下，任何一个线程崩溃会直接导致整个进程崩溃。</p>
<h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><p>Java语言内置了多线程支持：一个Java程序实际上是一个JVM进程，JVM进程用一个主线程来执行<code>main()</code>方法，在<code>main()</code>方法内部，我们又可以启动多个线程。此外，JVM还有负责垃圾回收的其他工作线程等。</p>
<p>因此，对于大多数Java程序来说，我们说多任务，实际上是说如何使用多线程实现多任务。</p>
<p>和单线程相比，多线程编程的特点在于：多线程经常需要读写共享数据，并且需要同步。例如，播放电影时，就必须由一个线程播放视频，另一个线程播放音频，两个线程需要协调运行，否则画面和声音就不同步。因此，多线程编程的复杂度高，调试更困难。</p>
<p>Java多线程编程的特点又在于：</p>
<ul>
<li>多线程模型是Java程序最基本的并发模型；</li>
<li>后续读写网络、数据库、Web开发等都依赖Java多线程模型。</li>
</ul>
<h2 id="创建新线程"><a href="#创建新线程" class="headerlink" title="创建新线程"></a>创建新线程</h2><p>Java语言内置了多线程支持。当Java程序启动的时候，实际上是启动了一个JVM进程，然后，JVM启动主线程来执行<code>main()</code>方法。在<code>main()</code>方法中，我们又可以启动其他线程。</p>
<p>要创建一个新线程非常容易，我们需要实例化一个<code>Thread</code>实例，然后调用它的<code>start()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 多线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>();</span><br><span class="line">        t.start(); <span class="comment">// 启动新线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这个线程启动后实际上什么也不做就立刻结束了。我们希望新线程能执行指定的代码，有以下几种方法：</p>
<p>方法一：从<code>Thread</code>派生一个自定义类，然后覆写<code>run()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 多线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        t.start(); <span class="comment">// 启动新线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;start new thread!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行上述代码，注意到<code>start()</code>方法会在内部自动调用实例的<code>run()</code>方法。</p>
<p>方法二：创建<code>Thread</code>实例时，传入一个<code>Runnable</code>实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 多线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>());</span><br><span class="line">        t.start(); <span class="comment">// 启动新线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;start new thread!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者用Java 8引入的lambda语法进一步简写为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 多线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;start new thread!&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        t.start(); <span class="comment">// 启动新线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有童鞋会问，使用线程执行的打印语句，和直接在<code>main()</code>方法执行有区别吗？</p>
<p>区别大了去了。我们看以下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;main start...&quot;);</span><br><span class="line">        Thread t = new Thread() &#123;</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                System.out.println(&quot;thread run...&quot;);</span><br><span class="line">                System.out.println(&quot;thread end.&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t.start();</span><br><span class="line">        System.out.println(&quot;main end...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们用蓝色表示主线程，也就是<code>main</code>线程，<code>main</code>线程执行的代码有4行，首先打印<code>main start</code>，然后创建<code>Thread</code>对象，紧接着调用<code>start()</code>启动新线程。当<code>start()</code>方法被调用时，JVM就创建了一个新线程，我们通过实例变量<code>t</code>来表示这个新线程对象，并开始执行。</p>
<p>接着，<code>main</code>线程继续执行打印<code>main end</code>语句，而<code>t</code>线程在<code>main</code>线程执行的同时会并发执行，打印<code>thread run</code>和<code>thread end</code>语句。</p>
<p>当<code>run()</code>方法结束时，新线程就结束了。而<code>main()</code>方法结束时，主线程也结束了。</p>
<p>我们再来看线程的执行顺序：</p>
<ol>
<li><code>main</code>线程肯定是先打印<code>main start</code>，再打印<code>main end</code>；</li>
<li><code>t</code>线程肯定是先打印<code>thread run</code>，再打印<code>thread end</code>。</li>
</ol>
<p>但是，除了可以肯定，<code>main start</code>会先打印外，<code>main end</code>打印在<code>thread run</code>之前、<code>thread end</code>之后或者之间，都无法确定。因为从<code>t</code>线程开始运行以后，两个线程就开始同时运行了，并且由操作系统调度，程序本身无法确定线程的调度顺序。</p>
<p>要模拟并发执行的效果，我们可以在线程中调用<code>Thread.sleep()</code>，强迫当前线程暂停一段时间：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 多线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;main start...&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;thread run...&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;&#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;thread end.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">20</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;&#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;main end...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>sleep()</code>传入的参数是毫秒。调整暂停时间的大小，我们可以看到<code>main</code>线程和<code>t</code>线程执行的先后顺序。</p>
<p>要特别注意：直接调用<code>Thread</code>实例的<code>run()</code>方法是无效的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        t.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接调用<code>run()</code>方法，相当于调用了一个普通的Java方法，当前线程并没有任何改变，也不会启动新线程。上述代码实际上是在<code>main()</code>方法内部又调用了<code>run()</code>方法，打印<code>hello</code>语句是在<code>main</code>线程中执行的，没有任何新线程被创建。</p>
<p>必须调用<code>Thread</code>实例的<code>start()</code>方法才能启动新线程，如果我们查看<code>Thread</code>类的源代码，会看到<code>start()</code>方法内部调用了一个<code>private native void start0()</code>方法，<code>native</code>修饰符表示这个方法是由JVM虚拟机内部的C代码实现的，不是由Java代码实现的。</p>
<h3 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h3><p>可以对线程设定优先级，设定优先级的方法是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread.setPriority(<span class="type">int</span> n) <span class="comment">// 1~10, 默认值5</span></span><br></pre></td></tr></table></figure>

<p>JVM自动把1（低）~10（高）的优先级映射到操作系统实际优先级上（不同操作系统有不同的优先级数量）。优先级高的线程被操作系统调度的优先级较高，操作系统对高优先级线程可能调度更频繁，但我们决不能通过设置优先级来确保高优先级的线程一定会先执行。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>Java用<code>Thread</code>对象表示一个线程，通过调用<code>start()</code>启动一个新线程；</p>
<p>一个线程对象只能调用一次<code>start()</code>方法；</p>
<p>线程的执行代码写在<code>run()</code>方法中；</p>
<p>线程调度由操作系统决定，程序本身无法决定调度顺序；</p>
<p><code>Thread.sleep()</code>可以把当前线程暂停一段时间。</p>
<h1 id="深拷贝与浅拷贝"><a href="#深拷贝与浅拷贝" class="headerlink" title="深拷贝与浅拷贝"></a>深拷贝与浅拷贝</h1><ol>
<li><p>利用序列化和反序列化实现深拷贝的原理</p>
<ul>
<li>当对一个对象进行序列化时，对象的状态（包括基本数据类型成员变量的值和引用数据类型成员变量所指向对象的状态）会被转换为字节流。在反序列化过程中，会根据字节流重新构建对象。这个重新构建的过程实际上是创建了全新的对象，而不是简单地复制引用。</li>
<li>对于引用数据类型的成员变量，会根据字节流中的信息重新创建这些对象，而不是共享原始对象的引用。这样就实现了深拷贝，即新对象和原始对象在内存中是完全独立的，修改其中一个对象不会影响到另一个对象。</li>
</ul>
</li>
<li><p>示例代码实现步骤</p>
<ul>
<li>步骤一：定义可序列化的类<ul>
<li>假设有一个<code>Person</code>类，包含基本数据类型的<code>age</code>和引用数据类型的<code>Address</code>。<code>Address</code>类也需要是可序列化的。</li>
</ul>
</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Address</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String city;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Address</span><span class="params">(String city)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.city = city;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getCity</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> city;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCity</span><span class="params">(String city)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.city = city;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> Address address;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(<span class="type">int</span> age, Address address)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Address <span class="title function_">getAddress</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> address;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAddress</span><span class="params">(Address address)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>步骤二：实现深拷贝的方法<ul>
<li>在<code>Person</code>类中可以定义一个方法来进行深拷贝，通过序列化和反序列化来实现。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.ByteArrayInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="comment">// 前面的成员变量和构造函数等代码省略</span></span><br><span class="line">    <span class="keyword">public</span> Person <span class="title function_">deepCopy</span><span class="params">()</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(bos);</span><br><span class="line">        oos.writeObject(<span class="built_in">this</span>);</span><br><span class="line">        <span class="type">ByteArrayInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(bos.toByteArray());</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(bis);</span><br><span class="line">        <span class="keyword">return</span> (Person) ois.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码定义了一个名为<code>deepCopy</code>的方法，用于在 Java 中通过序列化和反序列化的机制实现对<code>Person</code>对象的深拷贝。其目的是创建一个与原始<code>Person</code>对象完全独立的副本，使得对副本对象的修改不会影响到原始对象。</p>
<h3 id="代码逐行分析"><a href="#代码逐行分析" class="headerlink" title="代码逐行分析"></a>代码逐行分析</h3><ol>
<li><strong>创建字节数组输出流对象</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ByteArrayOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br></pre></td></tr></table></figure>

<p>这里创建了一个<code>ByteArrayOutputStream</code>对象<code>bos</code>。<code>ByteArrayOutputStream</code>是一个可以将数据写入字节数组的输出流类。它的作用是在内存中开辟一块缓冲区，用于暂存即将要序列化的<code>Person</code>对象转化成的字节流数据。</p>
<ol>
<li><strong>创建对象输出流对象并关联字节数组输出流</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(bos);</span><br></pre></td></tr></table></figure>

<p>创建了一个<code>ObjectOutputStream</code>对象<code>oos</code>，并将之前创建的<code>ByteArrayOutputStream</code>对象<code>bos</code>作为参数传递给它。<code>ObjectOutputStream</code>用于将对象转换为字节流进行序列化操作。通过这种关联，后续调用<code>oos.writeObject(this)</code>时，会将<code>Person</code>对象（由<code>this</code>指代当前对象，也就是调用<code>deepCopy</code>方法的那个<code>Person</code>对象）序列化后的字节流数据写入到<code>bos</code>所指向的内存缓冲区中。</p>
<ol>
<li><strong>执行对象序列化操作</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">oos.writeObject(<span class="built_in">this</span>);</span><br></pre></td></tr></table></figure>

<p>这行代码是真正执行对象序列化的步骤。<code>writeObject</code>方法是<code>ObjectOutputStream</code>类的核心方法之一，它会根据<code>Person</code>对象的内部结构（包括其成员变量的类型和值等信息），将整个<code>Person</code>对象转换为字节流，并将这些字节流数据写入到与之关联的<code>ByteArrayOutputStream</code>（即<code>bos</code>）的内存缓冲区中。此时，<code>Person</code>对象的所有状态信息，包括基本数据类型的属性值以及引用数据类型所指向对象的状态（如果引用类型也可序列化），都被转化成了字节流形式存储在<code>bos</code>的缓冲区中。</p>
<ol>
<li><strong>创建字节数组输入流对象</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ByteArrayInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(bos.toByteArray());</span><br></pre></td></tr></table></figure>

<p>在完成对象的序列化并将字节流数据暂存到<code>bos</code>的缓冲区后，接下来要进行反序列化操作以重建对象。首先创建一个<code>ByteArrayInputStream</code>对象<code>bis</code>，它的构造函数接受一个字节数组作为参数。这里通过调用<code>bos.toByteArray()</code>获取到存储在<code>ByteArrayOutputStream</code>缓冲区中的字节流数据数组，并将其作为参数传递给<code>ByteArrayInputStream</code>的构造函数，使得<code>bis</code>可以从这个字节流数据数组中读取数据，为后续的反序列化操作做准备。</p>
<ol>
<li><strong>创建对象输入流对象并关联字节数组输入流</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(bis);</span><br></pre></td></tr></table></figure>

<p>创建一个<code>ObjectInputStream</code>对象<code>ois</code>，并将刚才创建的<code>ByteArrayInputStream</code>对象<code>bis</code>作为参数传递给它。<code>ObjectInputStream</code>用于从字节流中读取数据并将其转换为对象，也就是执行反序列化操作。通过这种关联，后续<code>ois.readObject()</code>就能从<code>bis</code>所指向的字节流数据中读取并重建<code>Person</code>对象。</p>
<ol>
<li><strong>执行对象反序列化操作并返回拷贝后的对象</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> (Person) ois.readObject();</span><br></pre></td></tr></table></figure>

<p>这行代码执行反序列化的核心操作。<code>readObject</code>方法是<code>ObjectInputStream</code>类的核心方法之一，它会从与之关联的<code>ByteArrayInputStream</code>（即<code>bis</code>）所提供的字节流数据中读取信息，并根据这些信息重建一个<code>Person</code>对象。由于<code>readObject</code>方法返回的是一个<code>Object</code>类型的对象，所以需要将其强制转换为<code>Person</code>类型，以符合方法定义的返回值类型要求，最后将这个重建的<code>Person</code>对象作为深拷贝的结果返回。</p>
<p>通过以上一系列步骤，实现了对<code>Person</code>对象的深拷贝，创建出一个与原始<code>Person</code>对象在内存中完全独立的副本对象。</p>
<ul>
<li>步骤三：测试深拷贝<ul>
<li>可以通过以下代码来测试深拷贝的效果。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeepCopySerializationTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">        <span class="type">Address</span> <span class="variable">address</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Address</span>(<span class="string">&quot;Beijing&quot;</span>);</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">20</span>, address);</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person2</span> <span class="operator">=</span> person1.deepCopy();</span><br><span class="line">        System.out.println(<span class="string">&quot;Before change:&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;person1&#x27;s age: &quot;</span> + person1.getAge() + <span class="string">&quot;, address city: &quot;</span> + person1.getAddress().getCity());</span><br><span class="line">        System.out.println(<span class="string">&quot;person2&#x27;s age: &quot;</span> + person2.getAge() + <span class="string">&quot;, address city: &quot;</span> + person2.getAddress().getCity());</span><br><span class="line">        person2.setAge(<span class="number">21</span>);</span><br><span class="line">        person2.getAddress().setCity(<span class="string">&quot;Shanghai&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;After change:&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;person1&#x27;s age: &quot;</span> + person1.getAge() + <span class="string">&quot;, address city: &quot;</span> + person1.getAddress().getCity());</span><br><span class="line">        System.out.println(<span class="string">&quot;person2&#x27;s age: &quot;</span> + person2.getAge() + <span class="string">&quot;, address city: &quot;</span> + person2.getAddress().getCity());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在这个测试代码中，首先创建了<code>person1</code>，然后通过<code>deepCopy</code>方法得到<code>person2</code>。当修改<code>person2</code>的<code>age</code>和<code>Address</code>的<code>city</code>属性时，<code>person1</code>的相应属性不会受到影响，这就验证了通过序列化和反序列化实现了深拷贝。</li>
</ul>
<ol>
<li>注意事项<ul>
<li><strong>类必须实现<code>Serializable</code>接口</strong>：参与序列化和反序列化过程的类（包括包含引用数据类型成员变量的类及其引用的类）都必须实现<code>Serializable</code>接口，否则会抛出<code>NotSerializableException</code>异常。</li>
<li><strong>性能考虑</strong>：序列化和反序列化操作会带来一定的性能开销。这包括对象转换为字节流和字节流转换回对象的时间成本，以及字节流的存储或传输成本。如果对性能要求较高，需要谨慎使用这种方式来实现深拷贝。</li>
</ul>
</li>
</ol>
<h1 id="Java-IO操作"><a href="#Java-IO操作" class="headerlink" title="Java IO操作"></a>Java IO操作</h1><p>IO 即 Input&#x2F;Output，数据输入到计算机内存的过程即输入，反之输出到外部存储（比如数据库，文件，远程主机）的过程即输出。数据传输过程类似于水流，因此称为 IO 流。IO 流在 Java 中分为输入流和输出流，而根据数据的处理方式又分为字节流和字符流。</p>
<p>字节输入流FileInputStream（它用于从文件系统中的文件读取数据）。<u>当你实例化FileInputStream时，实际上是创建一个对象，这个对象可以用来打开一个到文件的输入流通道，以便后续从该文件中读取数据。</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;文件路径&quot;</span>);</span><br></pre></td></tr></table></figure>

<img src="image-20241027203118411.png" class title="image-20241027203118411">

<h2 id="InputStream（字节输入流）"><a href="#InputStream（字节输入流）" class="headerlink" title="InputStream（字节输入流）"></a>InputStream（字节输入流）</h2><p>常见的字节输入流FileInputStream（它用于从文件系统中的文件读取数据）。<u>当你实例化FileInputStream时，实际上是创建一个对象，这个对象可以用来打开一个到文件的输入流通道，以便后续从该文件中读取数据。</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;文件路径&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><font color="blue">值得注意的是</font><code>InputStream</code>本身不会直接进行硬盘数据的读取操作，它只是在需要读取数据时，通过调用底层系统的 I&#x2F;O 函数（这些函数会和硬件驱动等进行交互）来从已经定位的地址处获取数据。</p>
<p>InputStream常用方法：</p>
<p>（1）read():</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">从输入流中读取下一个数据字节。 值字节返回`int` ，范围为`0`至`255` 。 如果由于到达流末尾而没有可用字节，则返回值`-1` 。 此方法将阻塞，直到输入数据可用，检测到流的末尾或抛出异常。</span></span><br><span class="line"><span class="comment">- 结果</span></span><br><span class="line"><span class="comment">  数据的下一个字节，如果到达流的末尾， `-1` 。</span></span><br><span class="line"><span class="comment">- 异常</span></span><br><span class="line"><span class="comment">  `IOException` - 如果发生I / O错误。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><font color="blue">理解：</font></p>
<p>read()方法没有缓冲区，每次的read操作会直接通过inputstream从磁盘读取到程序当中（程序运行时，也就是读取到内存当中），而read操作每次读取一个字节，那么意味着read方法会频繁地与硬盘进行交互，而若inputstream并没有准备好这一个字节的数据的地址，read则无法进行读取数据到内存当中，因而会阻塞（等待数据的地址定位）。</p>
<img src="shangtou-04.png" class title="img">

<p>至于为什么read()读取一个字节却不是返回byte，而是将字节转为int返回，这涉及到计算机的编码问题：返回的int类型（32位bit）的-1可以表示为文件到了末尾，而如果是byte类型，如果文件的某个字节为-1，则无法判断是到了末尾还是文件本身存在-1的内容。<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1L34y1R7Xs/?p=4&vd_source=f4c23eef1d4e259929ac8b44b97dd07b">https://www.bilibili.com/video/BV1L34y1R7Xs/?p=4&amp;vd_source=f4c23eef1d4e259929ac8b44b97dd07b</a></p>
<p>Demo:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">FileInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// 111.txt中存储  helloworld世界</span></span><br><span class="line">			inputStream = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;E:\\111.txt&quot;</span>);</span><br><span class="line">			<span class="type">int</span> readdata;<span class="comment">//每次读取一个字节，转成int类型返回</span></span><br><span class="line">			<span class="keyword">while</span> ( (readdata = inputStream.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">				System.out.println((<span class="type">char</span>)readdata);</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		</span><br><span class="line">		&#125;<span class="keyword">catch</span>(FileNotFoundException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;<span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				inputStream.close();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">				<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>返回的结果是<code>helloworldä¸ç</code>，出现乱码，这是因为windows的txt默认编码为utf-8，而英文字符占一个字节，中文字符占3个字节，因此无法打出世界这个两个中文</p>
<p>（2）read(byte[] b)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">从输入流中读取一些字节数并将它们存储到缓冲区数组b 。 实际读取的字节数以整数形式返回。 此方法将阻塞，直到输入数据可用，检测到文件结尾或引发异常。</span></span><br><span class="line"><span class="comment">如果b的长度为零，则不读取任何字节，并返回0 ; 否则，尝试读取至少一个字节。 如果由于流位于文件末尾而没有可用字节，则返回值-1 ; 否则，至少读取一个字节并存储到b 。</span></span><br><span class="line"><span class="comment">参数</span></span><br><span class="line"><span class="comment">b - 读取数据的缓冲区。</span></span><br><span class="line"><span class="comment">结果</span></span><br><span class="line"><span class="comment">读入缓冲区的总字节数，如果由于已到达流末尾而没有更多数据， -1 。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">(<span class="type">byte</span>[] b)</span> <span class="keyword">throws</span> IOException</span><br></pre></td></tr></table></figure>

<p>byte[]b缓冲区，之前read()，每一个字节的数据都需要调动一次IO操作，从硬盘再到内存当中，设立一个缓冲区，每次读取的数据存储在该缓冲区内（程序里自建当然在内存当中），再读取数据时候就可以直接从缓冲区中拿，内存之间的传输就很快了，避免了之前频繁访问硬盘的问题。</p>
<p><font color="blue">这里需要注意的是:</font> byte[] b（假设你开辟了8个字节大小 byte[] b &#x3D; new byte[8]）作为缓冲区是重复使用的，当到了文件的末尾，最后只剩下6个，那么b的前6个字节会被覆盖，而最后2个字节则仍然是上一次读取的数据，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">FileInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// 111.txt中存储helloworld世界你好</span></span><br><span class="line">			<span class="comment">// 10个英文10个字节 + 4个中文每个中文3个字节12个字节 = 22</span></span><br><span class="line">			inputStream = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;E:\\111.txt&quot;</span>);</span><br><span class="line">			<span class="type">int</span> readlength;<span class="comment">//读入到缓冲区的字节数，返回实际读取的字节数</span></span><br><span class="line">			<span class="type">byte</span>[] buf = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">8</span>];</span><br><span class="line">			<span class="keyword">while</span> ( (readlength = inputStream.read(buf)) != -<span class="number">1</span>) &#123;</span><br><span class="line">				System.out.print(readlength); <span class="comment">// 886</span></span><br><span class="line">				</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		</span><br><span class="line">		&#125;<span class="keyword">catch</span>(FileNotFoundException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;<span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				inputStream.close();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">				<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>最后一次实际的读取字节数为6，打印出来：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">inputStream = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;E:\\111.txt&quot;</span>);</span><br><span class="line"><span class="type">int</span> readlength;<span class="comment">//读入到缓冲区的字节数，返回实际读取的字节数</span></span><br><span class="line"><span class="type">byte</span>[] buf = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">8</span>];</span><br><span class="line"><span class="keyword">while</span> ( (readlength = inputStream.read(buf)) != -<span class="number">1</span>) &#123;</span><br><span class="line">	<span class="comment">//System.out.print(readlength); // 886</span></span><br><span class="line">	System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(buf,<span class="number">0</span>,readlength));</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*结果：（这里也是碰巧没有将中文三个字节分开来）</span></span><br><span class="line"><span class="comment">	 * hellowor</span></span><br><span class="line"><span class="comment">	   ld世界</span></span><br><span class="line"><span class="comment">	   你好</span></span><br><span class="line"><span class="comment">	 * */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(3) available()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 返回可以从此输入流中无阻塞地读取（或跳过）的字节数的估计值，可以是0，或者在检测到流结束时为0。</span></span><br><span class="line"><span class="comment">// InputStream类的available()方法用于返回此输入流中可以无阻塞地读取的字节数估计值。注意这是一个估计值，在某些情况下可能并不准确。</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">available</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span><br></pre></td></tr></table></figure>

<h2 id="OutputStream（字节输入流）"><a href="#OutputStream（字节输入流）" class="headerlink" title="OutputStream（字节输入流）"></a>OutputStream（字节输入流）</h2><p>和InputStream相似不多赘述</p>
<p>FileOutputStream 方法:</p>
<p>(1) <code>void write(int b)</code>： 写入一个字节，虽然参数是一个 int 类型，但只有低 8 位才会写入，高 24 位会舍弃</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// b - 要写入的字节</span></span><br><span class="line"><span class="comment">// 将指定的字节写入此文件输出流。 实现write的方法OutputStream 。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> b)</span> <span class="keyword">throws</span> IOException</span><br></pre></td></tr></table></figure>

<p>(2) <code>void write(byte b[], int off, int len)</code>： 将数组 b 中的从 off 位置开始，长度为 len 的字节写入</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将指定字节数组中的 b.length个字节写入此文件输出流。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">byte</span>[] b)</span> <span class="keyword">throws</span> IOException</span><br></pre></td></tr></table></figure>

<p>(3) <code>void flush()</code>： 强制刷新，将缓冲区的数据写入 ,<font color="red">FileOutputStream flush方法为空s</font>，原因是FileOutputStream没有使用任何的缓冲区，因此flush()为空</p>
<p>要写入字节数组，可以调用getBytes()方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">outputStream.write(<span class="string">&quot;helloworld123&quot;</span>.getBytes());</span><br></pre></td></tr></table></figure>

<h2 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h2><p>Java 的缓冲流是对字节流和字符流的一种封装，通过在内存中开辟缓冲区来提高 I&#x2F;O 操作的效率。Java 通过 BufferedInputStream 和 BufferedOutputStream 来实现字节流的缓冲，通过 BufferedReader 和 BufferedWriter 来实现字符流的缓冲。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BufferedInputStream</span> <span class="keyword">extends</span> <span class="title class_">FilterInputStream</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">DEFAULT_BUFFER_SIZE</span> <span class="operator">=</span> <span class="number">8192</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The maximum size of array to allocate.</span></span><br><span class="line"><span class="comment">     * Some VMs reserve some header words in an array.</span></span><br><span class="line"><span class="comment">     * Attempts to allocate larger arrays may result in</span></span><br><span class="line"><span class="comment">     * OutOfMemoryError: Requested array size exceeds VM limit</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAX_BUFFER_SIZE</span> <span class="operator">=</span> Integer.MAX_VALUE - <span class="number">8</span>;</span><br></pre></td></tr></table></figure>

<p>直接使用默认缓冲流读取：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 记录开始时间</span></span><br><span class="line"><span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"><span class="comment">// 创建流对象</span></span><br><span class="line"><span class="keyword">try</span> (<span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;py.mp4&quot;</span>));</span><br><span class="line">        <span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;copyPy.mp4&quot;</span>));)&#123;</span><br><span class="line">    <span class="comment">// 读写数据</span></span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    <span class="keyword">while</span> ((b = bis.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">        bos.write(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 记录结束时间</span></span><br><span class="line"><span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis(); </span><br><span class="line">System.out.println(<span class="string">&quot;缓冲流使用数组复制时间:&quot;</span>+(end - start)+<span class="string">&quot; 毫秒&quot;</span>); <span class="comment">// 8016ms</span></span><br></pre></td></tr></table></figure>

<p>可以换数组的方式来读写，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 记录开始时间</span></span><br><span class="line"><span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"><span class="comment">// 创建流对象</span></span><br><span class="line"><span class="keyword">try</span> (<span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;py.mp4&quot;</span>));</span><br><span class="line">        <span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;copyPy.mp4&quot;</span>));)&#123;</span><br><span class="line">    <span class="comment">// 读写数据</span></span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">8</span>*<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">while</span> ((len = bis.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">        bos.write(bytes, <span class="number">0</span> , len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 记录结束时间</span></span><br><span class="line"><span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">System.out.println(<span class="string">&quot;缓冲流使用数组复制时间:&quot;</span>+(end - start)+<span class="string">&quot; 毫秒&quot;</span>); <span class="comment">// 521ms</span></span><br></pre></td></tr></table></figure>

<h3 id="缓冲流是内置了一个数组，增加了效率，不是内置了数组吗，为何还需要传递一个数组增加效率呢？"><a href="#缓冲流是内置了一个数组，增加了效率，不是内置了数组吗，为何还需要传递一个数组增加效率呢？" class="headerlink" title="缓冲流是内置了一个数组，增加了效率，不是内置了数组吗，为何还需要传递一个数组增加效率呢？"></a><font color="red"><strong>缓冲流是内置了一个数组，增加了效率，不是内置了数组吗，为何还需要传递一个数组增加效率呢？</strong></font></h3><p>首先声明一下缓冲流的基本原理：是在创建流对象时，会创建一个内置的默认大小的缓冲区数组，<font color="red">通过缓冲区读写，减少系统IO次数，</font>从而提高读写的效率。通过看源码，知道了这个默认的缓冲区数组大小是8192。</p>
<p>标红的部分，减少的是 系统IO次数 ，但是 缓冲区读写  这个部分，缓冲流做了优化吗，答案是没有</p>
<p>我们回到源码，字节缓冲输入流的add()无参方法如下，看返回值我们知道它返回的是int，诶，为什么不是返回数组呢，不是内置了数组吗？</p>
<img src="2135194-20201115031408498-651802370.png" class title="img">

<p>画一个示意图来说明吧，为什么说返回的是数组呢，因为返回给缓冲流的的确是数组，但是我们还有一个返回值就是我们每次读取的一个字节，源码的数据返回类型是int也证明了这一点，我们可以输出上面我提供的代码里面的b</p>
<p>就会知道的确每一次从被读取的文件中读数据是一个个字节读的，这样效率就很低下</p>
<img src="2135194-20201115032051472-76660950.png" class title="img">

<p>因此就有了我提供的代码里面的那种写法，缓冲区数组不再一个个读取，而是一次读取一个字符数组，这样在缓冲区读写这个部分进行了再次优化，实际过程如下（部分）</p>
<img src="2135194-20201115033226792-699674964.png" class title="img">

<p>缓冲流内置的缓冲区数组增加的效率的原因是在文件所在位置，也就是磁盘位置，到缓冲流这个部分的IO次数进行了优化，但是没有对读取磁盘文件这个步骤做优化，仍是单字节读取</p>
<p>我们可以使用数组读取的方式从磁盘读，进一步提升速度。</p>
<h3 id="为什么字节缓冲流会加快"><a href="#为什么字节缓冲流会加快" class="headerlink" title="为什么字节缓冲流会加快"></a>为什么字节缓冲流会加快</h3><p>字节缓冲流解决的就是这个问题：<strong>一次多读点多写点，减少读写的频率，用空间换时间</strong>。</p>
<ul>
<li>减少系统调用次数：在使用字节缓冲流时，数据不是立即写入磁盘或输出流，而是先写入缓冲区，当缓冲区满时再一次性写入磁盘或输出流。这样可以减少系统调用的次数，从而提高 I&#x2F;O 操作的效率。</li>
<li>减少磁盘读写次数：在使用字节缓冲流时，当需要读取数据时，缓冲流会先从缓冲区中读取数据，如果缓冲区中没有足够的数据，则会一次性从磁盘或输入流中读取一定量的数据。同样地，当需要写入数据时，缓冲流会先将数据写入缓冲区，如果缓冲区满了，则会一次性将缓冲区中的数据写入磁盘或输出流。这样可以减少磁盘读写的次数，从而提高 I&#x2F;O 操作的效率。</li>
<li>提高数据传输效率：在使用字节缓冲流时，由于数据是以块的形式进行传输，因此可以减少数据传输的次数，从而提高数据传输的效率。</li>
</ul>
<p>我们来看 BufferedInputStream 的 read 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">if</span> (pos &gt;= count) &#123;     <span class="comment">// 如果当前位置已经到达缓冲区末尾</span></span><br><span class="line">        fill();             <span class="comment">// 填充缓冲区</span></span><br><span class="line">        <span class="keyword">if</span> (pos &gt;= count)   <span class="comment">// 如果填充后仍然到达缓冲区末尾，说明已经读取完毕</span></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;      <span class="comment">// 返回 -1 表示已经读取完毕</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> getBufIfOpen()[pos++] &amp; <span class="number">0xff</span>; <span class="comment">// 返回当前位置的字节，并将位置加 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再来看 FileInputStream 的 read 方法：</p>
<img src="buffer-20230321154534.png" class title="img">

<p>在这段代码中，<code>read0()</code> 方法是一个<a target="_blank" rel="noopener" href="https://javabetter.cn/oo/native-method.html">本地方法</a>，它的实现是由底层操作系统提供的，并不是 Java 语言实现的。在不同的操作系统上，<code>read0()</code> 方法的实现可能会有所不同，但是它们的功能都是相同的，都是用于<strong>读取一个字节</strong>。</p>
<p>再来看一下 BufferedOutputStream 的 <code>write(byte b[], int off, int len)</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">byte</span> b[], <span class="type">int</span> off, <span class="type">int</span> len)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">if</span> (len &gt;= buf.length) &#123;    <span class="comment">// 如果写入的字节数大于等于缓冲区长度</span></span><br><span class="line">        <span class="comment">/* 如果请求的长度超过了输出缓冲区的大小，</span></span><br><span class="line"><span class="comment">           先刷新缓冲区，然后直接将数据写入。</span></span><br><span class="line"><span class="comment">           这样可以避免缓冲流级联时的问题。*/</span></span><br><span class="line">        flushBuffer();          <span class="comment">// 先刷新缓冲区</span></span><br><span class="line">        out.write(b, off, len); <span class="comment">// 直接将数据写入输出流</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (len &gt; buf.length - count) &#123; <span class="comment">// 如果写入的字节数大于空余空间</span></span><br><span class="line">        flushBuffer();              <span class="comment">// 先刷新缓冲区</span></span><br><span class="line">    &#125;</span><br><span class="line">    System.arraycopy(b, off, buf, count, len); <span class="comment">// 将数据拷贝到缓冲区中</span></span><br><span class="line">    count += len;                             <span class="comment">// 更新计数器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先，该方法会检查写入的字节数是否大于等于缓冲区长度，如果是，则先将缓冲区中的数据刷新到磁盘中，然后直接将数据写入输出流。这样做是为了避免缓冲流级联时的问题，即缓冲区的大小不足以容纳写入的数据时，可能会引发级联刷新，导致效率降低。</p>
<blockquote>
<p>级联问题（Cascade Problem）是指在一组缓冲流（Buffered Stream）中，由于缓冲区的大小不足以容纳要写入的数据，导致数据被分割成多个部分，并分别写入到不同的缓冲区中，最终需要逐个刷新缓冲区，从而导致性能下降的问题。</p>
</blockquote>
<p>其次，如果写入的字节数小于缓冲区长度，则检查缓冲区中剩余的空间是否足够容纳要写入的字节数，如果不够，则先将缓冲区中的数据刷新到磁盘中。然后，使用 <code>System.arraycopy()</code> 方法将要写入的数据拷贝到缓冲区中，并更新计数器 count。</p>
<p>最后，如果写入的字节数小于缓冲区长度且缓冲区中还有剩余空间，则直接将要写入的数据拷贝到缓冲区中，并更新计数器 count。</p>
<p>也就是说，只有当 buf 写满了，才会 flush，将数据刷到磁盘，默认一次刷 8192 个字节。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">BufferedOutputStream</span><span class="params">(OutputStream out)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(out, <span class="number">8192</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果 buf 没有写满，会继续写 buf。</p>
<p>对比一下 FileOutputStream 的 write 方法，同样是本地方法，一次只能写入一个字节。</p>
<img src="buffer-20230321162808.png" class title="img">

<p>当把 BufferedOutputStream 和 BufferedInputStream 配合起来使用后，就减少了大量的读写次数，尤其是 <code>byte[] bytes = new byte[8*1024]</code>，就相当于缓冲区的空间有 8 个 1024 字节，那读写效率就会大大提高。</p>
<h2 id="字符流Reader-Writer"><a href="#字符流Reader-Writer" class="headerlink" title="字符流Reader&#x2F;Writer"></a>字符流Reader&#x2F;Writer</h2><p>字节流是将内容转为了字节形式进行传输，1字节&#x3D;8二进制，二进制可以传输任何类型的数据，因此字节流可以传输任何类型的数据</p>
<p>字符流处理的是16位的unicode字符</p>
<p>字符输入流Reader方法：</p>
<p>(1) <code>read()</code>：从输入流读取一个字符。</p>
<p>(2) <code>read(char[] cbuf)</code>：从输入流中读取一些字符，并将它们存储到字符数组 <code>cbuf</code>中</p>
<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1>



<h2 id="Java-HashMap"><a href="#Java-HashMap" class="headerlink" title="Java HashMap"></a>Java HashMap</h2><h4 id="Java-HashMap-put-方法"><a href="#Java-HashMap-put-方法" class="headerlink" title="Java HashMap put() 方法"></a><font color="blue">Java HashMap put() 方法</font></h4><p>put()方法将指定的键值对插入到HashMap中。若插入的key对应的value已经存在，则执行value替换操作，返回旧的value值，如果不存在则执行插入，返回null</p>
<p>语法为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hashmap.put（K key，V value）</span><br></pre></td></tr></table></figure>

<p>Demo：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;Character, Integer&gt; dic = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">System.out.println( dic.put(<span class="string">&#x27;a&#x27;</span>, <span class="number">0</span>) ); <span class="comment">// null</span></span><br><span class="line">System.out.println( dic.put(<span class="string">&#x27;a&#x27;</span>, <span class="number">1</span>) ); <span class="comment">// 1</span></span><br><span class="line">System.out.println(dic); <span class="comment">// &#123;a=1&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="Java-HashMap-getOrDefault-方法"><a href="#Java-HashMap-getOrDefault-方法" class="headerlink" title="Java HashMap getOrDefault() 方法"></a><font color="blue">Java HashMap getOrDefault() 方法</font></h4><p>getOrDefault()方法获取指定key对应value，如果找不到key，则返回设置的默认值。</p>
<p>语法为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hashmap.getOrDefault(Object key, V defaultValue)</span><br></pre></td></tr></table></figure>

<p>Demo：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;Character, Integer&gt; dic = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">		<span class="comment">// 字符串的字符频率统计</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;abcdefabc&quot;</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;str.length();i++) &#123;</span><br><span class="line">			dic.put(str.charAt(i), dic.getOrDefault(str.charAt(i), <span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		System.out.println(dic); <span class="comment">//  &#123;a=2, b=2, c=2, d=1, e=1, f=1&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="Java-HashMap-containsValue-方法"><a href="#Java-HashMap-containsValue-方法" class="headerlink" title="Java HashMap containsValue() 方法"></a><font color="blue">Java HashMap containsValue() 方法</font></h4><p>containsValue() 方法检查 hashMap 中是否存在指定的 value 对应的映射关系。</p>
<p>语法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containsValue</span><span class="params">(Object value)</span></span><br></pre></td></tr></table></figure>

<p>Demo：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个 HashMap</span></span><br><span class="line">      HashMap&lt;Integer, String&gt; sites = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 往 HashMap 添加一些元素</span></span><br><span class="line">      sites.put(<span class="number">1</span>, <span class="string">&quot;Google&quot;</span>);</span><br><span class="line">      sites.put(<span class="number">2</span>, <span class="string">&quot;Runoob&quot;</span>);</span><br><span class="line">      sites.put(<span class="number">3</span>, <span class="string">&quot;Taobao&quot;</span>);</span><br><span class="line">      System.out.println(<span class="string">&quot;sites HashMap: &quot;</span> + sites);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//检查映射中值value是否有Java</span></span><br><span class="line">      <span class="keyword">if</span>(sites.containsValue(<span class="string">&quot;Runoob&quot;</span>)) &#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;Runoob 存在于 sites 中&quot;</span>);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<h4 id="Java-HashMap-containsKey-方法"><a href="#Java-HashMap-containsKey-方法" class="headerlink" title="Java HashMap containsKey() 方法"></a><font color="blue">Java HashMap containsKey() 方法</font></h4><p>containsKey() 方法检查 hashMap 中是否存在指定的 key 对应的映射关系。</p>
<p>语法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containsKey</span><span class="params">(Object key)</span></span><br></pre></td></tr></table></figure>

<p>Demo：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个 HashMap</span></span><br><span class="line">      HashMap&lt;Integer, String&gt; sites = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 往 HashMap 添加一些元素</span></span><br><span class="line">      sites.put(<span class="number">1</span>, <span class="string">&quot;Google&quot;</span>);</span><br><span class="line">      sites.put(<span class="number">2</span>, <span class="string">&quot;Runoob&quot;</span>);</span><br><span class="line">      sites.put(<span class="number">3</span>, <span class="string">&quot;Taobao&quot;</span>);</span><br><span class="line">      System.out.println(<span class="string">&quot;sites HashMap: &quot;</span> + sites);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//检查 key 为 1 是否存在</span></span><br><span class="line">      <span class="keyword">if</span>(sites.containsKey(<span class="number">1</span>)) &#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;key 为 1 存在于 sites 中&quot;</span>);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>



<h4 id="Java-HashMap-values-方法"><a href="#Java-HashMap-values-方法" class="headerlink" title="Java HashMap values() 方法 "></a><font color="blue">Java HashMap values() 方法 </font></h4><p>values() 方法返回映射中所有 value 组成的 Set 视图。</p>
<p>语法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Collection&lt;V&gt; <span class="title function_">values</span><span class="params">()</span></span><br></pre></td></tr></table></figure>

<p>Demo：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;Character, Integer&gt; dic = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// 字符串的字符频率统计</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;abcdefabc&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;str.length();i++) &#123;</span><br><span class="line">	dic.put(str.charAt(i), dic.getOrDefault(str.charAt(i), <span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Collection&lt;Integer&gt; values = dic.values();</span><br><span class="line">System.out.println(values);</span><br><span class="line"><span class="keyword">for</span> (Integer value:values) &#123;</span><br><span class="line">	System.out.print(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Java-HashSet"><a href="#Java-HashSet" class="headerlink" title="Java HashSet"></a><font color="red"><strong>Java HashSet</strong></font></h2><p>HashSet 基于 HashMap 来实现的，是一个不允许有重复元素的集合。<br>HashSet 允许有 null 值。<br>HashSet 是无序的，即不会记录插入的顺序。<br>HashSet 不是线程安全的， 如果多个线程尝试同时修改 HashSet，则最终结果是不确定的。 您必须在多线程访问时显式同步对 HashSet 的并发访问。<br>HashSet 实现了 Set 接口。</p>
<h4 id="Java-HashSet-add-方法"><a href="#Java-HashSet-add-方法" class="headerlink" title="Java HashSet add() 方法"></a><font color="blue">Java HashSet add() 方法</font></h4><p>添加元素：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HashSet&lt;Integer&gt; set1 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Integer&gt;();</span><br><span class="line">	</span><br><span class="line">set1.add(<span class="number">1</span>);</span><br><span class="line">set1.add(<span class="number">1</span>);</span><br><span class="line">System.out.println(set1); <span class="comment">// [1]</span></span><br></pre></td></tr></table></figure>

<h4 id="Java-HashSet-contains-方法"><a href="#Java-HashSet-contains-方法" class="headerlink" title="Java HashSet contains() 方法"></a><font color="blue">Java HashSet contains() 方法</font></h4><p>如果此set包含指定的元素，则返回<code>true</code> 。 更正式地说，返回<code>true</code>当且仅当此set包含的元素<code>e</code> ，使得<code>Objects.equals(o, e)</code> 。</p>
<p>语法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span></span><br></pre></td></tr></table></figure>

<p>Demo：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HashSet&lt;String&gt; sites = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;String&gt;();</span><br><span class="line">    sites.add(<span class="string">&quot;Google&quot;</span>);</span><br><span class="line">    sites.add(<span class="string">&quot;Runoob&quot;</span>);</span><br><span class="line">    sites.add(<span class="string">&quot;Taobao&quot;</span>);</span><br><span class="line">    sites.add(<span class="string">&quot;Zhihu&quot;</span>);</span><br><span class="line">    sites.add(<span class="string">&quot;Runoob&quot;</span>);  <span class="comment">// 重复的元素不会被添加</span></span><br><span class="line">    System.out.println(sites.contains(<span class="string">&quot;Taobao&quot;</span>)); <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Java-HashSet-size-方法"><a href="#Java-HashSet-size-方法" class="headerlink" title="Java HashSet size() 方法"></a><font color="blue">Java HashSet size() 方法</font></h4><p>返回此集合中的元素数（基数）。<br>语法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span></span><br></pre></td></tr></table></figure>



<h2 id="Java-String"><a href="#Java-String" class="headerlink" title="Java String"></a><font color="red"><u>Java String</u></font></h2><p><strong>length——数组的属性；</strong></p>
<p><strong>length()——String的方法；</strong></p>
<p><strong>size()——集合的方法；</strong></p>
<h4 id="Java-charAt-方法"><a href="#Java-charAt-方法" class="headerlink" title="Java charAt() 方法"></a><font color="blue">Java charAt() 方法</font></h4><p>charAt()方法用于返回指定索引处的字符。索引范围为从 0 到 length() - 1。</p>
<p>语法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">char</span> <span class="title function_">charAt</span><span class="params">(<span class="type">int</span> index)</span></span><br></pre></td></tr></table></figure>

<p>Demo:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;www.baidu.com&quot;</span>;</span><br><span class="line"><span class="type">char</span> <span class="variable">result</span> <span class="operator">=</span> s.charAt(<span class="number">6</span>);</span><br><span class="line">   System.out.println(result);<span class="comment">// i </span></span><br></pre></td></tr></table></figure>

<h4 id="Java-String-遍历方法"><a href="#Java-String-遍历方法" class="headerlink" title="Java String 遍历方法"></a><font color="blue">Java String 遍历方法</font></h4><p>使用toCharArray()，增强for：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;1243523&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">char</span> c:str.toCharArray()) &#123;</span><br><span class="line">	System.out.println(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用charAt()，普通for循环：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;1243523&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;str.length() ; i++) &#123;</span><br><span class="line">	System.out.println(str.charAt(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Java-ArrayList"><a href="#Java-ArrayList" class="headerlink" title="Java ArrayList"></a><font color="red"><strong><u>Java ArrayList</u></strong></font></h3><p>ArrayList 和 Vector 都实现了List接口，List接口继承了Collection接口，都是有序集合</p>
<p>区别在于Vector使用了<strong>Synchronized</strong> 来实现<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5&spm=1001.2101.3001.7020">线程同步</a>，是线程安全的，而 ArrayList 是非线程安全的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList; <span class="comment">// 引入 ArrayList 类</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// E:泛型数据类型，用于设置objectName的数据类型，只能为引用类型</span></span><br><span class="line">ArrayList&lt;E&gt; objectName =<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();　 <span class="comment">// 初始化</span></span><br><span class="line"><span class="comment">// 错误ArrayList&lt;char&gt; ==&gt; 正确ArrayList&lt;Character&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="ArrayList-添加元素add"><a href="#ArrayList-添加元素add" class="headerlink" title="ArrayList 添加元素add"></a><font color="blue">ArrayList 添加元素add</font></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; sites = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        sites.add(<span class="string">&quot;Google&quot;</span>);</span><br><span class="line">        sites.add(<span class="string">&quot;Runoob&quot;</span>);</span><br><span class="line">        sites.add(<span class="string">&quot;Taobao&quot;</span>);</span><br><span class="line">        sites.add(<span class="string">&quot;Weibo&quot;</span>);</span><br><span class="line">        System.out.println(sites);</span><br></pre></td></tr></table></figure>

<h4 id="ArrayList-访问元素get"><a href="#ArrayList-访问元素get" class="headerlink" title="ArrayList 访问元素get()"></a><font color="blue">ArrayList 访问元素get()</font></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; sites = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        sites.add(<span class="string">&quot;Google&quot;</span>);</span><br><span class="line">        sites.add(<span class="string">&quot;Runoob&quot;</span>);</span><br><span class="line">        sites.add(<span class="string">&quot;Taobao&quot;</span>);</span><br><span class="line">        sites.add(<span class="string">&quot;Weibo&quot;</span>);</span><br><span class="line">        System.out.println(sites.get(<span class="number">1</span>));  <span class="comment">// 访问第二个元素</span></span><br></pre></td></tr></table></figure>

<h4 id="ArrayList-修改元素set-int-index-E-element"><a href="#ArrayList-修改元素set-int-index-E-element" class="headerlink" title="ArrayList 修改元素set(int index, E element)"></a><font color="blue">ArrayList 修改元素set(int index, E element)</font></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; sites = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        sites.add(<span class="string">&quot;Google&quot;</span>);</span><br><span class="line">        sites.add(<span class="string">&quot;Runoob&quot;</span>);</span><br><span class="line">        sites.add(<span class="string">&quot;Taobao&quot;</span>);</span><br><span class="line">        sites.add(<span class="string">&quot;Weibo&quot;</span>);</span><br><span class="line">        sites.set(<span class="number">2</span>, <span class="string">&quot;Wiki&quot;</span>); <span class="comment">// 第一个参数为索引位置，第二个为要修改的值</span></span><br><span class="line">        System.out.println(sites);</span><br></pre></td></tr></table></figure>

<h4 id="ArrayList-删除元素remove"><a href="#ArrayList-删除元素remove" class="headerlink" title="ArrayList 删除元素remove()"></a><font color="blue">ArrayList 删除元素remove()</font></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; sites = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        sites.add(<span class="string">&quot;Google&quot;</span>);</span><br><span class="line">        sites.add(<span class="string">&quot;Runoob&quot;</span>);</span><br><span class="line">        sites.add(<span class="string">&quot;Taobao&quot;</span>);</span><br><span class="line">        sites.add(<span class="string">&quot;Weibo&quot;</span>);</span><br><span class="line">        sites.remove(<span class="number">3</span>); <span class="comment">// 删除第四个元素</span></span><br><span class="line">        System.out.println(sites);</span><br></pre></td></tr></table></figure>

<h4 id="ArrayList-计算大小size-Collection都是size"><a href="#ArrayList-计算大小size-Collection都是size" class="headerlink" title="ArrayList 计算大小size() Collection都是size()"></a><font color="blue">ArrayList 计算大小size()</font> Collection都是size()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; sites = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">System.out.println(sites.size());</span><br></pre></td></tr></table></figure>

<h2 id="Java-Arrays：专为数组而生的工具类"><a href="#Java-Arrays：专为数组而生的工具类" class="headerlink" title="Java Arrays：专为数组而生的工具类"></a><u>Java Arrays：专为数组而生的工具类</u></h2><h4 id="Arrays-创建数组"><a href="#Arrays-创建数组" class="headerlink" title="Arrays 创建数组"></a><font color="blue">Arrays 创建数组</font></h4><ol>
<li>copyOf：复制指定的数组，截取或用 null 填充</li>
</ol>
   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String[] intro = <span class="keyword">new</span> <span class="title class_">String</span>[] &#123; <span class="string">&quot;沉&quot;</span>, <span class="string">&quot;默&quot;</span>, <span class="string">&quot;王&quot;</span>, <span class="string">&quot;二&quot;</span> &#125;;</span><br><span class="line">String[] revised = Arrays.copyOf(intro, <span class="number">3</span>);</span><br><span class="line">String[] expanded = Arrays.copyOf(intro, <span class="number">5</span>);</span><br><span class="line">System.out.println(Arrays.toString(revised));</span><br><span class="line">System.out.println(Arrays.toString(expanded));</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>copyOfRange，复制指定范围内的数组到一个新的数组：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String[] intro = <span class="keyword">new</span> <span class="title class_">String</span>[] &#123; <span class="string">&quot;沉&quot;</span>, <span class="string">&quot;默&quot;</span>, <span class="string">&quot;王&quot;</span>, <span class="string">&quot;二&quot;</span> &#125;;</span><br><span class="line">String[] abridgement = Arrays.copyOfRange(intro, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">System.out.println(Arrays.toString(abridgement));</span><br></pre></td></tr></table></figure>
</li>
<li><p>fill，对数组进行填充：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String[] stutter = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">4</span>];</span><br><span class="line">Arrays.fill(stutter, <span class="string">&quot;沉默王二&quot;</span>);</span><br><span class="line">System.out.println(Arrays.toString(stutter)); </span><br><span class="line"><span class="comment">// [沉默王二, 沉默王二, 沉默王二, 沉默王二] 如果想要一个元素完全相同的数组时 fill() 方法就派上用场了</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="Arrays-比较数组"><a href="#Arrays-比较数组" class="headerlink" title="Arrays 比较数组"></a><font color="blue">Arrays 比较数组</font></h4><p>Arrays 类的 <code>equals()</code> 方法用来判断两个数组是否相等：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String[] intro = <span class="keyword">new</span> <span class="title class_">String</span>[] &#123; <span class="string">&quot;沉&quot;</span>, <span class="string">&quot;默&quot;</span>, <span class="string">&quot;王&quot;</span>, <span class="string">&quot;二&quot;</span> &#125;;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> Arrays.equals(<span class="keyword">new</span> <span class="title class_">String</span>[] &#123; <span class="string">&quot;沉&quot;</span>, <span class="string">&quot;默&quot;</span>, <span class="string">&quot;王&quot;</span>, <span class="string">&quot;二&quot;</span> &#125;, intro);</span><br><span class="line">System.out.println(result);</span><br><span class="line"><span class="type">boolean</span> <span class="variable">result1</span> <span class="operator">=</span> Arrays.equals(<span class="keyword">new</span> <span class="title class_">String</span>[] &#123; <span class="string">&quot;沉&quot;</span>, <span class="string">&quot;默&quot;</span>, <span class="string">&quot;王&quot;</span>, <span class="string">&quot;三&quot;</span> &#125;, intro);</span><br><span class="line">System.out.println(result1);</span><br></pre></td></tr></table></figure>

<h4 id="Arrays-数组排序"><a href="#Arrays-数组排序" class="headerlink" title="Arrays 数组排序"></a><font color="blue">Arrays 数组排序</font></h4><p>Arrays 类的 <code>sort()</code> 方法用来对数组进行排序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String[] intro1 = <span class="keyword">new</span> <span class="title class_">String</span>[] &#123; <span class="string">&quot;chen&quot;</span>, <span class="string">&quot;mo&quot;</span>, <span class="string">&quot;wang&quot;</span>, <span class="string">&quot;er&quot;</span> &#125;;</span><br><span class="line">String[] sorted = Arrays.copyOf(intro1, <span class="number">4</span>);</span><br><span class="line">Arrays.sort(sorted);</span><br><span class="line">System.out.println(Arrays.toString(sorted));</span><br></pre></td></tr></table></figure>

<h4 id="Arrays-数组检索"><a href="#Arrays-数组检索" class="headerlink" title="Arrays 数组检索"></a><font color="blue">Arrays 数组检索</font></h4><p>数组排序后就可以使用 Arrays 类的 <code>binarySearch()</code> 方法进行二分查找了。否则的话，只能线性检索，效率就会低很多。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String[] intro1 = <span class="keyword">new</span> <span class="title class_">String</span>[] &#123; <span class="string">&quot;chen&quot;</span>, <span class="string">&quot;mo&quot;</span>, <span class="string">&quot;wang&quot;</span>, <span class="string">&quot;er&quot;</span> &#125;;</span><br><span class="line">String[] sorted = Arrays.copyOf(intro1, <span class="number">4</span>);</span><br><span class="line">Arrays.sort(sorted);</span><br><span class="line"><span class="type">int</span> <span class="variable">exact</span> <span class="operator">=</span> Arrays.binarySearch(sorted, <span class="string">&quot;wang&quot;</span>);</span><br><span class="line">System.out.println(exact);</span><br><span class="line"><span class="type">int</span> <span class="variable">caseInsensitive</span> <span class="operator">=</span> Arrays.binarySearch(sorted, <span class="string">&quot;Wang&quot;</span>, String::compareToIgnoreCase);</span><br><span class="line">System.out.println(caseInsensitive);</span><br></pre></td></tr></table></figure>

<h4 id="Arrays-数组打印"><a href="#Arrays-数组打印" class="headerlink" title="Arrays 数组打印"></a><font color="blue">Arrays 数组打印</font></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.toString()</span><br></pre></td></tr></table></figure>

<h4 id="Arrays-数组转-List"><a href="#Arrays-数组转-List" class="headerlink" title="Arrays 数组转 List"></a><font color="blue">Arrays 数组转 List</font></h4><p>尽管数组非常强大，但它自身可以操作的工具方法很少，比如说判断数组中是否包含某个值。如果能转成 List 的话，就简便多了，因为 Java 的<a target="_blank" rel="noopener" href="https://javabetter.cn/collection/gailan.html">集合框架 List</a> 中封装了很多常用的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String[] intro = <span class="keyword">new</span> <span class="title class_">String</span>[] &#123; <span class="string">&quot;沉&quot;</span>, <span class="string">&quot;默&quot;</span>, <span class="string">&quot;王&quot;</span>, <span class="string">&quot;二&quot;</span> &#125;;</span><br><span class="line">List&lt;String&gt; rets = Arrays.asList(intro);</span><br><span class="line">System.out.println(rets.contains(<span class="string">&quot;二&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>不过需要注意的是，<code>Arrays.asList()</code> 返回的是 <code>java.util.Arrays.ArrayList</code>，并不是<code> java.util.ArrayList</code>，它的长度是固定的，无法进行元素的删除或者添加。</p>
<p>要想操作元素的话，需要多一步转化，转成真正的 <code>java.util.ArrayList</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; rets1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(intro));</span><br><span class="line">rets1.add(<span class="string">&quot;三&quot;</span>);</span><br><span class="line">rets1.remove(<span class="string">&quot;二&quot;</span>);</span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="https://sza0415.github.io">Ziang Sun</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://sza0415.github.io/Java%E5%9F%BA%E7%A1%80/">https://sza0415.github.io/Java%E5%9F%BA%E7%A1%80/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-share"><div class="social-share" data-image="/img/image1.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/Spring/" title="Spring"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">Previous</div><div class="info-item-2">Spring</div></div><div class="info-2"><div class="info-item-1">MyBatisMyBatis是一款优秀的持久型（JavaEE三层架构：表现层、业务层和持久层&#x2F;数据访问层）框架，它支持自定义SQL、存储过程以及高级映射。MyBatis免除了几乎所有的JDBC代码以及设置参数和获取结果集的工作。MyBatis可以通过简单的XML或注解来配置和映射原始类型、接口和Java POJO（Plain Old Java Objects，普通老式Java对象）为数据库中的记录。  MyBatis快速入门创建user表，添加数据1234567891011121314create database mybatisDb; use mybatisDb;drop table if exists tb_user;create table tb_user( 	id int primary key auto_increment, 	username varchar(20), 	password varchar(20), 	gender char(1), 	addr varchar(30) ); INSERT INTO tb_user VALUES...</div></div></div></a><a class="pagination-related" href="/JavaWeb%E5%9F%BA%E7%A1%80/" title="JavaWeb基础"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">Next</div><div class="info-item-2">JavaWeb基础</div></div><div class="info-2"><div class="info-item-1">JSP页面元素  a.脚本Scriptlet  &lt;%         局部变量、java语句 %&gt;  &lt;%!         全局变量、定义方法  %&gt;  &lt;%= 输出表达式  %&gt; 这里的局部变量的作用域并不是局限于&lt;%	.....%&gt;，这是因为JSP最终都会转译为servlet，全局变量为该类的成员变量，作用域为整个类；而局部变量被写在了service方法当中，为客户端向服务端的servlet中，service()方法中的本地变量只能每响应一次请求就重建一次。 全局变量在关闭该网页、关闭浏览器、更换浏览器，再重新访问该jsp页面后仍然持续保留之前的值（服务器仍然保留着该servlet）； 但在清除tomcat的work文件夹，或重启tomcat后恢复初始值。 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Insert title...</div></div></div></a></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> Comments</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/image1.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Ziang Sun</div><div class="author-info-description">直到有另一个人 能体会我的感觉</div><div class="site-data"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">7</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">1</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/sza0415"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80"><span class="toc-number">1.</span> <span class="toc-text">多线程基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.0.1.</span> <span class="toc-text">进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B-vs-%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.0.2.</span> <span class="toc-text">进程 vs 线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.0.3.</span> <span class="toc-text">多线程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%96%B0%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.1.</span> <span class="toc-text">创建新线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">1.1.1.</span> <span class="toc-text">线程的优先级</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">1.1.2.</span> <span class="toc-text">小结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-number">2.</span> <span class="toc-text">深拷贝与浅拷贝</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E9%80%90%E8%A1%8C%E5%88%86%E6%9E%90"><span class="toc-number">2.0.1.</span> <span class="toc-text">代码逐行分析</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java-IO%E6%93%8D%E4%BD%9C"><span class="toc-number">3.</span> <span class="toc-text">Java IO操作</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#InputStream%EF%BC%88%E5%AD%97%E8%8A%82%E8%BE%93%E5%85%A5%E6%B5%81%EF%BC%89"><span class="toc-number">3.1.</span> <span class="toc-text">InputStream（字节输入流）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#OutputStream%EF%BC%88%E5%AD%97%E8%8A%82%E8%BE%93%E5%85%A5%E6%B5%81%EF%BC%89"><span class="toc-number">3.2.</span> <span class="toc-text">OutputStream（字节输入流）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E6%B5%81"><span class="toc-number">3.3.</span> <span class="toc-text">缓冲流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E6%B5%81%E6%98%AF%E5%86%85%E7%BD%AE%E4%BA%86%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%EF%BC%8C%E5%A2%9E%E5%8A%A0%E4%BA%86%E6%95%88%E7%8E%87%EF%BC%8C%E4%B8%8D%E6%98%AF%E5%86%85%E7%BD%AE%E4%BA%86%E6%95%B0%E7%BB%84%E5%90%97%EF%BC%8C%E4%B8%BA%E4%BD%95%E8%BF%98%E9%9C%80%E8%A6%81%E4%BC%A0%E9%80%92%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%E5%A2%9E%E5%8A%A0%E6%95%88%E7%8E%87%E5%91%A2%EF%BC%9F"><span class="toc-number">3.3.1.</span> <span class="toc-text">缓冲流是内置了一个数组，增加了效率，不是内置了数组吗，为何还需要传递一个数组增加效率呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AD%97%E8%8A%82%E7%BC%93%E5%86%B2%E6%B5%81%E4%BC%9A%E5%8A%A0%E5%BF%AB"><span class="toc-number">3.3.2.</span> <span class="toc-text">为什么字节缓冲流会加快</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E6%B5%81Reader-Writer"><span class="toc-number">3.4.</span> <span class="toc-text">字符流Reader&#x2F;Writer</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">4.</span> <span class="toc-text">数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-HashMap"><span class="toc-number">4.1.</span> <span class="toc-text">Java HashMap</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Java-HashMap-put-%E6%96%B9%E6%B3%95"><span class="toc-number">4.1.0.1.</span> <span class="toc-text">Java HashMap put() 方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java-HashMap-getOrDefault-%E6%96%B9%E6%B3%95"><span class="toc-number">4.1.0.2.</span> <span class="toc-text">Java HashMap getOrDefault() 方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java-HashMap-containsValue-%E6%96%B9%E6%B3%95"><span class="toc-number">4.1.0.3.</span> <span class="toc-text">Java HashMap containsValue() 方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java-HashMap-containsKey-%E6%96%B9%E6%B3%95"><span class="toc-number">4.1.0.4.</span> <span class="toc-text">Java HashMap containsKey() 方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java-HashMap-values-%E6%96%B9%E6%B3%95"><span class="toc-number">4.1.0.5.</span> <span class="toc-text">Java HashMap values() 方法 </span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-HashSet"><span class="toc-number">4.2.</span> <span class="toc-text">Java HashSet</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Java-HashSet-add-%E6%96%B9%E6%B3%95"><span class="toc-number">4.2.0.1.</span> <span class="toc-text">Java HashSet add() 方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java-HashSet-contains-%E6%96%B9%E6%B3%95"><span class="toc-number">4.2.0.2.</span> <span class="toc-text">Java HashSet contains() 方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java-HashSet-size-%E6%96%B9%E6%B3%95"><span class="toc-number">4.2.0.3.</span> <span class="toc-text">Java HashSet size() 方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-String"><span class="toc-number">4.3.</span> <span class="toc-text">Java String</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Java-charAt-%E6%96%B9%E6%B3%95"><span class="toc-number">4.3.0.1.</span> <span class="toc-text">Java charAt() 方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java-String-%E9%81%8D%E5%8E%86%E6%96%B9%E6%B3%95"><span class="toc-number">4.3.0.2.</span> <span class="toc-text">Java String 遍历方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-ArrayList"><span class="toc-number">4.3.1.</span> <span class="toc-text">Java ArrayList</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ArrayList-%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0add"><span class="toc-number">4.3.1.1.</span> <span class="toc-text">ArrayList 添加元素add</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ArrayList-%E8%AE%BF%E9%97%AE%E5%85%83%E7%B4%A0get"><span class="toc-number">4.3.1.2.</span> <span class="toc-text">ArrayList 访问元素get()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ArrayList-%E4%BF%AE%E6%94%B9%E5%85%83%E7%B4%A0set-int-index-E-element"><span class="toc-number">4.3.1.3.</span> <span class="toc-text">ArrayList 修改元素set(int index, E element)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ArrayList-%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0remove"><span class="toc-number">4.3.1.4.</span> <span class="toc-text">ArrayList 删除元素remove()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ArrayList-%E8%AE%A1%E7%AE%97%E5%A4%A7%E5%B0%8Fsize-Collection%E9%83%BD%E6%98%AFsize"><span class="toc-number">4.3.1.5.</span> <span class="toc-text">ArrayList 计算大小size() Collection都是size()</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-Arrays%EF%BC%9A%E4%B8%93%E4%B8%BA%E6%95%B0%E7%BB%84%E8%80%8C%E7%94%9F%E7%9A%84%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-number">4.4.</span> <span class="toc-text">Java Arrays：专为数组而生的工具类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Arrays-%E5%88%9B%E5%BB%BA%E6%95%B0%E7%BB%84"><span class="toc-number">4.4.0.1.</span> <span class="toc-text">Arrays 创建数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Arrays-%E6%AF%94%E8%BE%83%E6%95%B0%E7%BB%84"><span class="toc-number">4.4.0.2.</span> <span class="toc-text">Arrays 比较数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Arrays-%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F"><span class="toc-number">4.4.0.3.</span> <span class="toc-text">Arrays 数组排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Arrays-%E6%95%B0%E7%BB%84%E6%A3%80%E7%B4%A2"><span class="toc-number">4.4.0.4.</span> <span class="toc-text">Arrays 数组检索</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Arrays-%E6%95%B0%E7%BB%84%E6%89%93%E5%8D%B0"><span class="toc-number">4.4.0.5.</span> <span class="toc-text">Arrays 数组打印</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Arrays-%E6%95%B0%E7%BB%84%E8%BD%AC-List"><span class="toc-number">4.4.0.6.</span> <span class="toc-text">Arrays 数组转 List</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Posts</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/macEnvironment/" title="Mac环境配置">Mac环境配置</a><time datetime="2024-11-17T12:43:56.938Z" title="Created 2024-11-17 20:43:56">2024-11-17</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/ARFoundationLearning/" title="ARFoundation学习">ARFoundation学习</a><time datetime="2024-11-14T05:15:25.354Z" title="Created 2024-11-14 13:15:25">2024-11-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/react-guide/" title="React入门">React入门</a><time datetime="2024-11-04T07:45:19.239Z" title="Created 2024-11-04 15:45:19">2024-11-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/Spring/" title="Spring">Spring</a><time datetime="2024-11-03T09:34:50.969Z" title="Created 2024-11-03 17:34:50">2024-11-03</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/Java%E5%9F%BA%E7%A1%80/" title="Java基础">Java基础</a><time datetime="2024-11-03T09:34:50.963Z" title="Created 2024-11-03 17:34:50">2024-11-03</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2024 By Ziang Sun</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="Scroll to Comments"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.isShuoshuo
  const option = {"language":"zh-CN","perPage":10,"distractionFreeMode":false,"createIssueManually":true}

  const commentCount = n => {
    const isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
    if (isCommentCount) {
      isCommentCount.textContent= n
    }
  }

  const initGitalk = (el, path) => {
    if (isShuoshuo) {
      window.shuoshuoComment.destroyGitalk = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }

    const gitalk = new Gitalk({
      clientID: 'Ov23li1nXnygRWmrL22n',
      clientSecret: 'fdcfbe11c7b66e8cbfe98aeb17100017159cb6d5',
      repo: 'sza0415.github.io',
      owner: 'sza0415',
      admin: ['sza0415'],
      updateCountCallback: commentCount,
      ...option,
      id: isShuoshuo ? path : (option && option.id) || '0cbd4b41cde1da86e8fce4b56d1f7cb9'
    })

    gitalk.render('gitalk-container')
  }

  const loadGitalk = async(el, path) => {
    if (typeof Gitalk === 'function') initGitalk(el, path)
    else {
      await btf.getCSS('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css')
      await btf.getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js')
      initGitalk(el, path)
    }
  }

  if (isShuoshuo) {
    'Gitalk' === 'Gitalk'
      ? window.shuoshuoComment = { loadComment: loadGitalk }
      : window.loadOtherComment = loadGitalk
    return
  }

  if ('Gitalk' === 'Gitalk' || !false) {
    if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
    else loadGitalk()
  } else {
    window.loadOtherComment = loadGitalk
  }
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">Search</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  Loading Database</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>